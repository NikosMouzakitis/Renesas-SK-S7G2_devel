<?xml version='1.0' encoding='UTF-8'?>
<developerSupport><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s124" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s124.init" version="1"><moduleRef id="module.driver.analog_connect_s124"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s124.connect" version="1"><moduleRef id="module.driver.analog_connect_s124"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s124.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s124"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s124.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s124"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s128" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s128.init" version="1"><moduleRef id="module.driver.analog_connect_s128"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s128.connect" version="1"><moduleRef id="module.driver.analog_connect_s128"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s128.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s128"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s128.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s128"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s1ja" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s1ja.init" version="1"><moduleRef id="module.driver.analog_connect_s1ja"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s1ja.connect" version="1"><moduleRef id="module.driver.analog_connect_s1ja"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s1ja.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s1ja"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s1ja.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s1ja"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s3a1" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s3a1.init" version="1"><moduleRef id="module.driver.analog_connect_s3a1"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s3a1.connect" version="1"><moduleRef id="module.driver.analog_connect_s3a1"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s3a1.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s3a1"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s3a1.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s3a1"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s3a3" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s3a3.init" version="1"><moduleRef id="module.driver.analog_connect_s3a3"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s3a3.connect" version="1"><moduleRef id="module.driver.analog_connect_s3a3"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s3a3.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s3a3"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s3a3.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s3a3"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s3a6" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s3a6.init" version="1"><moduleRef id="module.driver.analog_connect_s3a6"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s3a6.connect" version="1"><moduleRef id="module.driver.analog_connect_s3a6"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s3a6.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s3a6"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s3a6.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s3a6"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s3a7" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s3a7.init" version="1"><moduleRef id="module.driver.analog_connect_s3a7"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s3a7.connect" version="1"><moduleRef id="module.driver.analog_connect_s3a7"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s3a7.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s3a7"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s3a7.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s3a7"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s5d3" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s5d3.init" version="1"><moduleRef id="module.driver.analog_connect_s5d3"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s5d3.connect" version="1"><moduleRef id="module.driver.analog_connect_s5d3"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s5d3.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s5d3"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s5d3.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s5d3"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s5d5" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s5d5.init" version="1"><moduleRef id="module.driver.analog_connect_s5d5"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s5d5.connect" version="1"><moduleRef id="module.driver.analog_connect_s5d5"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s5d5.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s5d5"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s5d5.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s5d5"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s5d9" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s5d9.init" version="1"><moduleRef id="module.driver.analog_connect_s5d9"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s5d9.connect" version="1"><moduleRef id="module.driver.analog_connect_s5d9"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s5d9.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s5d9"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s5d9.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s5d9"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.analog_connect_s7g2" /><description>
<![CDATA[<form><p><span color="header" font="header">Analog Connection HAL Module Introduction</span></p><p>The analog connection HAL module implements the analog connect API on r_analog_connect to simplify the connection of the analog components that comprise the analog front end on select Synergy MCUs. Previously these connections needed to be made using low-level register-based configuration instead of using the Synergy configurator. The analog connection module supports the OPAMP (operational amplifier), ACMPHS (high speed analog comparator), and ACMPLP (low power analog comparator) peripherals, and their allowed interconnections, available on the Synergy microcontroller hardware.</p><p><b>Analog Connection HAL Module Features</b></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li><p><span color="header" font="header">Analog Connection HAL Module Features</span></p><li bindent="0" vspace="false">Simplifies the interconnection of internal analog connections</li><li bindent="0" vspace="false">Selection of interconnects is limited to those available to the target MCU, simplifying the configuration process and eliminating common configuration errors</li><li bindent="0" vspace="false">Uses the time saving and intuitive SSP configuration GUI</li></form>]]>
</description><function display="ssp_err_t (*init) (analog_connect_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize the analog connect module.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (analog_connect_t const connection)" id="connect"><description>
<![CDATA[<form><p>Make one internal analog connection.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_Connect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">connection</span> :   Internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connectMultiple) (analog_connect_table_t const *const p_table)" id="connectMultiple"><description>
<![CDATA[<form><p>Make multiple internal analog connections. Connections are made in the order they are listed in the table. This API is most efficient when all connections for the same module/channel combination are grouped together.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_ConnectMultiple()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_table</span> :   Pointer to table of internal analog connection to make </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ANALOG_CONNECT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.analog_connect_s7g2.init" version="1"><moduleRef id="module.driver.analog_connect_s7g2"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.driver.analog_connect_s7g2.connect" version="1"><moduleRef id="module.driver.analog_connect_s7g2"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connect(${connection});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connectMultiple()" id="module.driver.analog_connect_s7g2.connectMultiple" version="1"><moduleRef id="module.driver.analog_connect_s7g2"><function id="connectMultiple" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;connectMultiple(${p_table});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.analog_connect_s7g2.versionGet" version="1"><moduleRef id="module.driver.analog_connect_s7g2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.analog_connect.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.elc_on_elc" /><description>
<![CDATA[<form><p><span color="header" font="header">ELC HAL Module Introduction</span></p><p>The Event Link Controller (ELC) HAL module provides a high-level API for connecting various MCU peripherals for autonomous operation and uses the ELC peripheral on the Synergy MCU. There are no callbacks associated with the ELC HAL module. The project configurator in the e 2  studio Integrated Solution Development Environment (ISDE) includes the ELC HAL module in every project by default. To configure the ELC HAL module, select it in the HAL/Common module in the <b>Threads</b> tab and click on it in the HAL/Common Stacks window.</p><p><b>ELC HAL Module Features</b></p><p>The ELC HAL module can perform the following functions:</p><li bindent="0" vspace="false">Creates an event link between two blocks.</li><li bindent="0" vspace="false">Breaks that event link between two blocks.</li><li bindent="0" vspace="false">Generates one of two software events that interrupt the CPU.</li><p><b>ELC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for ELC.</p><p>Legend:</p><p><span color="header" font="header">ELC HAL Module Features</span></p><p>The ELC HAL module can perform the following functions:</p><li bindent="0" vspace="false">Creates an event link between two blocks.</li><li bindent="0" vspace="false">Breaks that event link between two blocks.</li><li bindent="0" vspace="false">Generates one of two software events that interrupt the CPU.</li></form>]]>
</description><function display="ssp_err_t (*init) (elc_cfg_t const *const p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize all links in the Event Link Controller. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_Init()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*softwareEventGenerate) (elc_software_event_t event_num)" id="softwareEventGenerate"><description>
<![CDATA[<form><p>Generate a software event in the Event Link Controller. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_SoftwareEventGenerate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">eventNum</span> :   Software event number to be generated. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linkSet) (elc_peripheral_t peripheral, elc_event_t signal)" id="linkSet"><description>
<![CDATA[<form><p>Create a single event link. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_LinkSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">peripheral</span> :   The peripheral block that will receive the event signal. </li><li bindent="0" vspace="false"><span font="code">signal</span> :   The event signal. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linkBreak) (elc_peripheral_t peripheral)" id="linkBreak"><description>
<![CDATA[<form><p>Break an event link. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_LinkBreak()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">peripheral</span> :   The peripheral that should no longer be linked. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (void)" id="enable"><description>
<![CDATA[<form><p>Enable the operation of the Event Link Controller. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_Enable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (void)" id="disable"><description>
<![CDATA[<form><p>Disable the operation of the Event Link Controller. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_Disable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ELC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   is value returned. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.elc_on_elc.init" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call softwareEventGenerate()" id="module.driver.elc_on_elc.softwareEventGenerate" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="softwareEventGenerate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;softwareEventGenerate(${event_num});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linkSet()" id="module.driver.elc_on_elc.linkSet" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="linkSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;linkSet(${peripheral}, ${signal});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linkBreak()" id="module.driver.elc_on_elc.linkBreak" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="linkBreak" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;linkBreak(${peripheral});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.elc_on_elc.enable" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;enable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.elc_on_elc.disable" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;disable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.elc_on_elc.versionGet" version="1"><moduleRef id="module.driver.elc_on_elc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.elc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.ioport_on_ioport" /><description>
<![CDATA[<form><p><span color="header" font="header">I/O PORT HAL Module Introduction</span></p><p>The I/O Port HAL module implements a high-level API for controlling I/O pins, configuring the board's pins and manipulating I/O pins. The operating state of an I/O pin can be set via the Synergy configurator.  When the Synergy project is built, a pin configuration file is created. When the application runs, the BSP will configure the MCU IO port accordingly, using the same API functions described in this document.</p><p><b>I/O PORT HAL Module Features</b></p><p>The I/O PORT HAL module can perform the following functions:</p><li bindent="0" vspace="false">Create an event link between two blocks.</li><li bindent="0" vspace="false">Break that event link between two blocks.</li><li bindent="0" vspace="false">Generate one of two software events that interrupt the CPU.</li><p><b>I/O Port Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for GPIO.</p><p>Legend:</p><li bindent="0" vspace="false">Note: Event Linking would have to be set up by the user, rather than using the ELC API.</li><p><span color="header" font="header">I/O PORT HAL Module Features</span></p><p>The I/O PORT HAL module can perform the following functions:</p><li bindent="0" vspace="false">Create an event link between two blocks.</li><li bindent="0" vspace="false">Break that event link between two blocks.</li><li bindent="0" vspace="false">Generate one of two software events that interrupt the CPU.</li></form>]]>
</description><function display="ssp_err_t (*init) (const ioport_cfg_t *p_cfg)" id="init"><description>
<![CDATA[<form><p>Initialize internal driver data and initial pin configurations. Called during startup. Do not call this API during runtime. Use <span font="code">ioport_api_t::pinsCfg</span> for runtime reconfiguration of multiple pins. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_Init()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration data array. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinsCfg) (const ioport_cfg_t *p_cfg)" id="pinsCfg"><description>
<![CDATA[<form><p>Configure multiple pins. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinsCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration data array. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinCfg) (ioport_port_pin_t pin, uint32_t cfg)" id="pinCfg"><description>
<![CDATA[<form><p>Configure settings for an individual pin. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin to be read. </li><li bindent="0" vspace="false"><span font="code">cfg</span> :   Configuration options for the pin. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinDirectionSet) (ioport_port_pin_t pin, ioport_direction_t direction)" id="pinDirectionSet"><description>
<![CDATA[<form><p>Set the pin direction of a pin. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinDirectionSet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin being configured. </li><li bindent="0" vspace="false"><span font="code">direction</span> :   Direction to set pin to which is a member of ioport_direction_t. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinEventInputRead) (ioport_port_pin_t pin, ioport_level_t *p_pin_event)" id="pinEventInputRead"><description>
<![CDATA[<form><p>Read the event input data of the specified pin and return the level. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinEventInputRead()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin to be read. </li><li bindent="0" vspace="false"><span font="code">p_pin_event</span> :   Pointer to return the event data. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinEventOutputWrite) (ioport_port_pin_t pin, ioport_level_t pin_value)" id="pinEventOutputWrite"><description>
<![CDATA[<form><p>Write pin event data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinEventOutputWrite()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin event data is to be written to. </li><li bindent="0" vspace="false"><span font="code">pin_value</span> :   Level to be written to pin output event. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinEthernetModeCfg) (ioport_ethernet_channel_t channel, ioport_ethernet_mode_t mode)" id="pinEthernetModeCfg"><description>
<![CDATA[<form><p>Configure the PHY mode of the Ethernet channels. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_EthernetModeCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">channel</span> :   Channel configuration will be set for. </li><li bindent="0" vspace="false"><span font="code">mode</span> :   PHY mode to set the channel to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinRead) (ioport_port_pin_t pin, ioport_level_t *p_pin_value)" id="pinRead"><description>
<![CDATA[<form><p>Read level of a pin. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinRead()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin to be read. </li><li bindent="0" vspace="false"><span font="code">p_pin_value</span> :   Pointer to return the pin level. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pinWrite) (ioport_port_pin_t pin, ioport_level_t level)" id="pinWrite"><description>
<![CDATA[<form><p>Write specified level to a pin. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PinWrite()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">pin</span> :   Pin to be written to. </li><li bindent="0" vspace="false"><span font="code">level</span> :   State to be written to the pin. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*portDirectionSet) (ioport_port_t port, ioport_size_t direction_values, ioport_size_t mask)" id="portDirectionSet"><description>
<![CDATA[<form><p>Set the direction of one or more pins on a port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PortDirectionSet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">port</span> :   Port being configured. </li><li bindent="0" vspace="false"><span font="code">direction_values</span> :   Value controlling direction of pins on port (1 - output, 0 - input). </li><li bindent="0" vspace="false"><span font="code">mask</span> :   Mask controlling which pins on the port are to be configured. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*portEventInputRead) (ioport_port_t port, ioport_size_t *p_event_data)" id="portEventInputRead"><description>
<![CDATA[<form><p>Read captured event data for a port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PortEventInputRead()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">port</span> :   Port to be read. </li><li bindent="0" vspace="false"><span font="code">p_event_data</span> :   Pointer to return the event data. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*portEventOutputWrite) (ioport_port_t port, ioport_size_t event_data, ioport_size_t mask_value)" id="portEventOutputWrite"><description>
<![CDATA[<form><p>Write event output data for a port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PortEventOutputWrite()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">port</span> :   Port event data will be written to. </li><li bindent="0" vspace="false"><span font="code">event_data</span> :   Data to be written as event data to specified port. </li><li bindent="0" vspace="false"><span font="code">mask_value</span> :   Each bit set to 1 in the mask corresponds to that bit's value in event data. being written to port. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*portRead) (ioport_port_t port, ioport_size_t *p_port_value)" id="portRead"><description>
<![CDATA[<form><p>Read states of pins on the specified port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PortRead()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">port</span> :   Port to be read. </li><li bindent="0" vspace="false"><span font="code">p_port_value</span> :   Pointer to return the port value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*portWrite) (ioport_port_t port, ioport_size_t value, ioport_size_t mask)" id="portWrite"><description>
<![CDATA[<form><p>Write to multiple pins on a port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_PortWrite()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">port</span> :   Port to be written to. </li><li bindent="0" vspace="false"><span font="code">value</span> :   Value to be written to the port. </li><li bindent="0" vspace="false"><span font="code">mask</span> :   Mask controlling which pins on the port are written to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the IOPort driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_IOPORT_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.ioport_on_ioport.init" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;init(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinsCfg()" id="module.driver.ioport_on_ioport.pinsCfg" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinsCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinsCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinCfg()" id="module.driver.ioport_on_ioport.pinCfg" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinCfg(${pin}, ${cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinDirectionSet()" id="module.driver.ioport_on_ioport.pinDirectionSet" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinDirectionSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinDirectionSet(${pin}, ${direction});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinEventInputRead()" id="module.driver.ioport_on_ioport.pinEventInputRead" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinEventInputRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinEventInputRead(${pin}, ${p_pin_event});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinEventOutputWrite()" id="module.driver.ioport_on_ioport.pinEventOutputWrite" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinEventOutputWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinEventOutputWrite(${pin}, ${pin_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinEthernetModeCfg()" id="module.driver.ioport_on_ioport.pinEthernetModeCfg" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinEthernetModeCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinEthernetModeCfg(${channel}, ${mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinRead()" id="module.driver.ioport_on_ioport.pinRead" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinRead(${pin}, ${p_pin_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pinWrite()" id="module.driver.ioport_on_ioport.pinWrite" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="pinWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;pinWrite(${pin}, ${level});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call portDirectionSet()" id="module.driver.ioport_on_ioport.portDirectionSet" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="portDirectionSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;portDirectionSet(${port}, ${direction_values}, ${mask});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call portEventInputRead()" id="module.driver.ioport_on_ioport.portEventInputRead" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="portEventInputRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;portEventInputRead(${port}, ${p_event_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call portEventOutputWrite()" id="module.driver.ioport_on_ioport.portEventOutputWrite" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="portEventOutputWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;portEventOutputWrite(${port}, ${event_data}, ${mask_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call portRead()" id="module.driver.ioport_on_ioport.portRead" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="portRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;portRead(${port}, ${p_port_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call portWrite()" id="module.driver.ioport_on_ioport.portWrite" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="portWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;portWrite(${port}, ${value}, ${mask});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.ioport_on_ioport.versionGet" version="1"><moduleRef id="module.driver.ioport_on_ioport"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ioport.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.cgc_on_cgc" /><description>
<![CDATA[<form><p><span color="header" font="header">CGC HAL Module Introduction</span></p><p>The CGC HAL module provides a high-level API for clock-control applications and configures and controls the clock-control functions of a Synergy MCU using the clock-control peripheral. Since every project requires a clock function, the CGC HAL module is added to a project by default. (The module is configured in the ISDE.) A user-defined callback can be created to signal when the main oscillator has stopped.</p><p><b>CGC HAL Module Features</b></p><p>The CGC HAL module supports the configuration and control of the various clocking functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Selects the system clock source</li><p>• HOCO (high-speed on-chip oscillator), MOCO (middle-speed on-chip oscillator), LOCO (low-speed on-chip oscillator), Main Clock, PLL, or Sub-Oscillator</p><li bindent="0" vspace="false">Configures internal clocks and turns them on or off</li><li bindent="0" vspace="false">Configures the output clocks</li><li bindent="0" vspace="false">Sets up the Oscillation Stop Detection feature</li><li bindent="0" vspace="false">Sets up clock divisors on each of the up to six clock domains</li><li bindent="0" vspace="false">Some Synergy MCUs also support controllable external clock outputs, which may have independent divisors</li><p><b>CGC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Clock Generation Circuit specifications for the clock sources.</p><p>Legend:</p><p><span color="header" font="header">CGC HAL Module Features</span></p><p>The CGC HAL module supports the configuration and control of the various clocking functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Selects the system clock source</li><p>• HOCO (high-speed on-chip oscillator), MOCO (middle-speed on-chip oscillator), LOCO (low-speed on-chip oscillator), Main Clock, PLL, or Sub-Oscillator</p><li bindent="0" vspace="false">Configures internal clocks and turns them on or off</li><li bindent="0" vspace="false">Configures the output clocks</li><li bindent="0" vspace="false">Sets up the Oscillation Stop Detection feature</li><li bindent="0" vspace="false">Sets up clock divisors on each of the up to six clock domains</li><li bindent="0" vspace="false">Some Synergy MCUs also support controllable external clock outputs, which may have independent divisors</li></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initial configuration </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_Init()</span> </li><p><b>Note</b></p><p>The BSP module calls this function at startup. No further initialization is necessary. </p><p /></form>]]>
</description></function><function display="ssp_err_t (*clocksCfg) (cgc_clocks_cfg_t const *const p_clock_cfg)" id="clocksCfg"><description>
<![CDATA[<form><p>Configure all system clocks. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClocksCfg()</span> </li><p><b>Note</b></p><p>The BSP module calls this function at startup, but it can also be called from the application to change clocks at runtime. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to a structure that contains the dividers or multipliers to be used when configuring the PLL. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockStart) (cgc_clock_t clock_source, cgc_clock_cfg_t *p_clock_cfg)" id="clockStart"><description>
<![CDATA[<form><p>Start a clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockStart()</span> </li><p><b>Precondition</b></p><p>Clock to be started must not be running prior to calling this function or an error will be returned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Clock source to initialize. </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to a structure that contains the dividers or multipliers to be used when configuring the PLL. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockStop) (cgc_clock_t clock_source)" id="clockStop"><description>
<![CDATA[<form><p>Stop a clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockStop()</span> </li><p><b>Precondition</b></p><p>Clock to be stopped must not be stopped prior to calling this function or an error will be returned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   The clock source to stop. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockSet) (cgc_clock_t clock_source, cgc_system_clock_cfg_t const *const p_clock_cfg)" id="systemClockSet"><description>
<![CDATA[<form><p>Set the system clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockSet()</span> </li><p><b>Precondition</b></p><p>The clock to be set as the system clock must be running prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Clock source to set as system clock </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to the clock dividers configuration passed by the caller. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockGet) (cgc_clock_t *p_clock_source, cgc_system_clock_cfg_t *p_set_clock_cfg)" id="systemClockGet"><description>
<![CDATA[<form><p>Get the system clock information. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_set_clock_cfg</span> :   Pointer to clock configuration structure </li><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Returns the current system clock. </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Returns the current system clock dividers. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockFreqGet) (cgc_system_clocks_t clock, uint32_t *p_freq_hz)" id="systemClockFreqGet"><description>
<![CDATA[<form><p>Return the frequency of the selected clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockFreqGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Specifies the internal clock whose frequency is returned. </li><li bindent="0" vspace="false"><span font="code">p_freq_hz</span> :   Returns the frequency in Hz referenced by this pointer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockCheck) (cgc_clock_t clock_source)" id="clockCheck"><description>
<![CDATA[<form><p>Check the stability of the selected clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockCheck()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Which clock source to check for stability. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*oscStopDetect) (void(*p_callback)(cgc_callback_args_t *p_args), bool enable)" id="oscStopDetect"><description>
<![CDATA[<form><p>Configure the Main Oscillator stop detection. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_OscStopDetect()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_callback</span> :   Callback function that will be called by the NMI interrupt when an oscillation stop is detected. If the second argument is "false", then this argument can be NULL. </li><li bindent="0" vspace="false"><span font="code">enable</span> :   Enable/disable Oscillation Stop Detection. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*oscStopStatusClear) (void)" id="oscStopStatusClear"><description>
<![CDATA[<form><p>Clear the oscillator stop detection flag. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_OscStopStatusClear()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutCfg) (cgc_bclockout_dividers_t divider)" id="busClockOutCfg"><description>
<![CDATA[<form><p>Configure the bus clock output secondary divider. The primary divider is set using the bsp clock configuration and the <span font="code">cgc_api_t::systemClockSet</span> function (S7G2 and S3A7 only).</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">divider</span> :   The divider of 1 or 2 of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutEnable) (void)" id="busClockOutEnable"><description>
<![CDATA[<form><p>Enable the bus clock output (S7G2 and S3A7 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutDisable) (void)" id="busClockOutDisable"><description>
<![CDATA[<form><p>Disable the bus clock output (S7G2 and S3A7 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutCfg) (cgc_clock_t clock, cgc_clockout_dividers_t divider)" id="clockOutCfg"><description>
<![CDATA[<form><p>Configure clockOut. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Clock source. </li><li bindent="0" vspace="false"><span font="code">divider</span> :   Divider of between 1 and 128 of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutEnable) (void)" id="clockOutEnable"><description>
<![CDATA[<form><p>Enable clock output on the CLKOUT pin. The source of the clock is controlled by <span font="code">cgc_api_t::clockOutCfg</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutDisable) (void)" id="clockOutDisable"><description>
<![CDATA[<form><p>Disable clock output on the CLKOUT pin. The source of the clock is controlled by <span font="code">cgc_api_t::clockOutCfg</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockCfg) (cgc_clock_t clock)" id="lcdClockCfg"><description>
<![CDATA[<form><p>Configure the segment LCD Clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Segment LCD clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockEnable) (void)" id="lcdClockEnable"><description>
<![CDATA[<form><p>Enable the LCD clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockDisable) (void)" id="lcdClockDisable"><description>
<![CDATA[<form><p>Disables the LCD clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockCfg) (cgc_clock_t clock)" id="sdadcClockCfg"><description>
<![CDATA[<form><p>Configure the 24-bit Sigma-Delta A/D Converter Clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   SDADC clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockEnable) (void)" id="sdadcClockEnable"><description>
<![CDATA[<form><p>Enable the SDADC clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockDisable) (void)" id="sdadcClockDisable"><description>
<![CDATA[<form><p>Disables the SDADC clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdramClockOutEnable) (void)" id="sdramClockOutEnable"><description>
<![CDATA[<form><p>Enables the SDRAM clock output (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDRAMClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdramClockOutDisable) (void)" id="sdramClockOutDisable"><description>
<![CDATA[<form><p>Disables the SDRAM clock (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDRAMClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*usbClockCfg) (cgc_usb_clock_div_t divider)" id="usbClockCfg"><description>
<![CDATA[<form><p>Configures the USB clock (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_USBClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">divider</span> :   The divider of 3, 4 or 5, of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systickUpdate) (uint32_t period_count, cgc_systick_period_units_t units)" id="systickUpdate"><description>
<![CDATA[<form><p>Update the Systick timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystickUpdate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">period_count</span> :   The duration for the systick period. </li><li bindent="0" vspace="false"><span font="code">units</span> :   The units for the provided period. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets the CGC driver version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.cgc_on_cgc.init" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clocksCfg()" id="module.driver.cgc_on_cgc.clocksCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clocksCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clocksCfg(${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockStart()" id="module.driver.cgc_on_cgc.clockStart" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockStart(${clock_source}, ${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockStop()" id="module.driver.cgc_on_cgc.clockStop" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockStop(${clock_source});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockSet()" id="module.driver.cgc_on_cgc.systemClockSet" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="systemClockSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;systemClockSet(${clock_source}, ${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockGet()" id="module.driver.cgc_on_cgc.systemClockGet" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="systemClockGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;systemClockGet(${p_clock_source}, ${p_set_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockFreqGet()" id="module.driver.cgc_on_cgc.systemClockFreqGet" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="systemClockFreqGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;systemClockFreqGet(${clock}, ${p_freq_hz});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockCheck()" id="module.driver.cgc_on_cgc.clockCheck" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockCheck(${clock_source});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call oscStopDetect()" id="module.driver.cgc_on_cgc.oscStopDetect" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="oscStopDetect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;oscStopDetect(${p_args}, ${enable});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call oscStopStatusClear()" id="module.driver.cgc_on_cgc.oscStopStatusClear" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="oscStopStatusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;oscStopStatusClear();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutCfg()" id="module.driver.cgc_on_cgc.busClockOutCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="busClockOutCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;busClockOutCfg(${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutEnable()" id="module.driver.cgc_on_cgc.busClockOutEnable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="busClockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;busClockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutDisable()" id="module.driver.cgc_on_cgc.busClockOutDisable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="busClockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;busClockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutCfg()" id="module.driver.cgc_on_cgc.clockOutCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockOutCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockOutCfg(${clock}, ${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutEnable()" id="module.driver.cgc_on_cgc.clockOutEnable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutDisable()" id="module.driver.cgc_on_cgc.clockOutDisable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="clockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;clockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockCfg()" id="module.driver.cgc_on_cgc.lcdClockCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="lcdClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;lcdClockCfg(${clock});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockEnable()" id="module.driver.cgc_on_cgc.lcdClockEnable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="lcdClockEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;lcdClockEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockDisable()" id="module.driver.cgc_on_cgc.lcdClockDisable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="lcdClockDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;lcdClockDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockCfg()" id="module.driver.cgc_on_cgc.sdadcClockCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="sdadcClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;sdadcClockCfg(${clock});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockEnable()" id="module.driver.cgc_on_cgc.sdadcClockEnable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="sdadcClockEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;sdadcClockEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockDisable()" id="module.driver.cgc_on_cgc.sdadcClockDisable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="sdadcClockDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;sdadcClockDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdramClockOutEnable()" id="module.driver.cgc_on_cgc.sdramClockOutEnable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="sdramClockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;sdramClockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdramClockOutDisable()" id="module.driver.cgc_on_cgc.sdramClockOutDisable" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="sdramClockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;sdramClockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call usbClockCfg()" id="module.driver.cgc_on_cgc.usbClockCfg" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="usbClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;usbClockCfg(${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systickUpdate()" id="module.driver.cgc_on_cgc.systickUpdate" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="systickUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;systickUpdate(${period_count}, ${units});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.cgc_on_cgc.versionGet" version="1"><moduleRef id="module.driver.cgc_on_cgc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.cgc_cfg" /><description>
<![CDATA[<form><p><span color="header" font="header">CGC HAL Module Introduction</span></p><p>The CGC HAL module provides a high-level API for clock-control applications and configures and controls the clock-control functions of a Synergy MCU using the clock-control peripheral. Since every project requires a clock function, the CGC HAL module is added to a project by default. (The module is configured in the ISDE.) A user-defined callback can be created to signal when the main oscillator has stopped.</p><p><b>CGC HAL Module Features</b></p><p>The CGC HAL module supports the configuration and control of the various clocking functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Selects the system clock source</li><p>• HOCO (high-speed on-chip oscillator), MOCO (middle-speed on-chip oscillator), LOCO (low-speed on-chip oscillator), Main Clock, PLL, or Sub-Oscillator</p><li bindent="0" vspace="false">Configures internal clocks and turns them on or off</li><li bindent="0" vspace="false">Configures the output clocks</li><li bindent="0" vspace="false">Sets up the Oscillation Stop Detection feature</li><li bindent="0" vspace="false">Sets up clock divisors on each of the up to six clock domains</li><li bindent="0" vspace="false">Some Synergy MCUs also support controllable external clock outputs, which may have independent divisors</li><p><b>CGC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Clock Generation Circuit specifications for the clock sources.</p><p>Legend:</p><p><span color="header" font="header">CGC HAL Module Features</span></p><p>The CGC HAL module supports the configuration and control of the various clocking functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Selects the system clock source</li><p>• HOCO (high-speed on-chip oscillator), MOCO (middle-speed on-chip oscillator), LOCO (low-speed on-chip oscillator), Main Clock, PLL, or Sub-Oscillator</p><li bindent="0" vspace="false">Configures internal clocks and turns them on or off</li><li bindent="0" vspace="false">Configures the output clocks</li><li bindent="0" vspace="false">Sets up the Oscillation Stop Detection feature</li><li bindent="0" vspace="false">Sets up clock divisors on each of the up to six clock domains</li><li bindent="0" vspace="false">Some Synergy MCUs also support controllable external clock outputs, which may have independent divisors</li></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initial configuration </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_Init()</span> </li><p><b>Note</b></p><p>The BSP module calls this function at startup. No further initialization is necessary. </p><p /></form>]]>
</description></function><function display="ssp_err_t (*clocksCfg) (cgc_clocks_cfg_t const *const p_clock_cfg)" id="clocksCfg"><description>
<![CDATA[<form><p>Configure all system clocks. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClocksCfg()</span> </li><p><b>Note</b></p><p>The BSP module calls this function at startup, but it can also be called from the application to change clocks at runtime. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to a structure that contains the dividers or multipliers to be used when configuring the PLL. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockStart) (cgc_clock_t clock_source, cgc_clock_cfg_t *p_clock_cfg)" id="clockStart"><description>
<![CDATA[<form><p>Start a clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockStart()</span> </li><p><b>Precondition</b></p><p>Clock to be started must not be running prior to calling this function or an error will be returned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Clock source to initialize. </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to a structure that contains the dividers or multipliers to be used when configuring the PLL. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockStop) (cgc_clock_t clock_source)" id="clockStop"><description>
<![CDATA[<form><p>Stop a clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockStop()</span> </li><p><b>Precondition</b></p><p>Clock to be stopped must not be stopped prior to calling this function or an error will be returned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   The clock source to stop. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockSet) (cgc_clock_t clock_source, cgc_system_clock_cfg_t const *const p_clock_cfg)" id="systemClockSet"><description>
<![CDATA[<form><p>Set the system clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockSet()</span> </li><p><b>Precondition</b></p><p>The clock to be set as the system clock must be running prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Clock source to set as system clock </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Pointer to the clock dividers configuration passed by the caller. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockGet) (cgc_clock_t *p_clock_source, cgc_system_clock_cfg_t *p_set_clock_cfg)" id="systemClockGet"><description>
<![CDATA[<form><p>Get the system clock information. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_set_clock_cfg</span> :   Pointer to clock configuration structure </li><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Returns the current system clock. </li><li bindent="0" vspace="false"><span font="code">p_clock_cfg</span> :   Returns the current system clock dividers. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systemClockFreqGet) (cgc_system_clocks_t clock, uint32_t *p_freq_hz)" id="systemClockFreqGet"><description>
<![CDATA[<form><p>Return the frequency of the selected clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystemClockFreqGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Specifies the internal clock whose frequency is returned. </li><li bindent="0" vspace="false"><span font="code">p_freq_hz</span> :   Returns the frequency in Hz referenced by this pointer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockCheck) (cgc_clock_t clock_source)" id="clockCheck"><description>
<![CDATA[<form><p>Check the stability of the selected clock. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockCheck()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock_source</span> :   Which clock source to check for stability. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*oscStopDetect) (void(*p_callback)(cgc_callback_args_t *p_args), bool enable)" id="oscStopDetect"><description>
<![CDATA[<form><p>Configure the Main Oscillator stop detection. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_OscStopDetect()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_callback</span> :   Callback function that will be called by the NMI interrupt when an oscillation stop is detected. If the second argument is "false", then this argument can be NULL. </li><li bindent="0" vspace="false"><span font="code">enable</span> :   Enable/disable Oscillation Stop Detection. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*oscStopStatusClear) (void)" id="oscStopStatusClear"><description>
<![CDATA[<form><p>Clear the oscillator stop detection flag. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_OscStopStatusClear()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutCfg) (cgc_bclockout_dividers_t divider)" id="busClockOutCfg"><description>
<![CDATA[<form><p>Configure the bus clock output secondary divider. The primary divider is set using the bsp clock configuration and the <span font="code">cgc_api_t::systemClockSet</span> function (S7G2 and S3A7 only).</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">divider</span> :   The divider of 1 or 2 of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutEnable) (void)" id="busClockOutEnable"><description>
<![CDATA[<form><p>Enable the bus clock output (S7G2 and S3A7 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*busClockOutDisable) (void)" id="busClockOutDisable"><description>
<![CDATA[<form><p>Disable the bus clock output (S7G2 and S3A7 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_BusClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutCfg) (cgc_clock_t clock, cgc_clockout_dividers_t divider)" id="clockOutCfg"><description>
<![CDATA[<form><p>Configure clockOut. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Clock source. </li><li bindent="0" vspace="false"><span font="code">divider</span> :   Divider of between 1 and 128 of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutEnable) (void)" id="clockOutEnable"><description>
<![CDATA[<form><p>Enable clock output on the CLKOUT pin. The source of the clock is controlled by <span font="code">cgc_api_t::clockOutCfg</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clockOutDisable) (void)" id="clockOutDisable"><description>
<![CDATA[<form><p>Disable clock output on the CLKOUT pin. The source of the clock is controlled by <span font="code">cgc_api_t::clockOutCfg</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_ClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockCfg) (cgc_clock_t clock)" id="lcdClockCfg"><description>
<![CDATA[<form><p>Configure the segment LCD Clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   Segment LCD clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockEnable) (void)" id="lcdClockEnable"><description>
<![CDATA[<form><p>Enable the LCD clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lcdClockDisable) (void)" id="lcdClockDisable"><description>
<![CDATA[<form><p>Disables the LCD clock (S3A7 and S124 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_LCDClockDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockCfg) (cgc_clock_t clock)" id="sdadcClockCfg"><description>
<![CDATA[<form><p>Configure the 24-bit Sigma-Delta A/D Converter Clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">clock</span> :   SDADC clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockEnable) (void)" id="sdadcClockEnable"><description>
<![CDATA[<form><p>Enable the SDADC clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdadcClockDisable) (void)" id="sdadcClockDisable"><description>
<![CDATA[<form><p>Disables the SDADC clock (S1JA only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDADCClockDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdramClockOutEnable) (void)" id="sdramClockOutEnable"><description>
<![CDATA[<form><p>Enables the SDRAM clock output (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDRAMClockOutEnable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sdramClockOutDisable) (void)" id="sdramClockOutDisable"><description>
<![CDATA[<form><p>Disables the SDRAM clock (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SDRAMClockOutDisable()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*usbClockCfg) (cgc_usb_clock_div_t divider)" id="usbClockCfg"><description>
<![CDATA[<form><p>Configures the USB clock (S7G2 only). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_USBClockCfg()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">divider</span> :   The divider of 3, 4 or 5, of the clock source. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*systickUpdate) (uint32_t period_count, cgc_systick_period_units_t units)" id="systickUpdate"><description>
<![CDATA[<form><p>Update the Systick timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_SystickUpdate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">period_count</span> :   The duration for the systick period. </li><li bindent="0" vspace="false"><span font="code">units</span> :   The units for the provided period. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets the CGC driver version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CGC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.cgc_cfg.init" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clocksCfg()" id="module.driver.cgc_cfg.clocksCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clocksCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clocksCfg(${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockStart()" id="module.driver.cgc_cfg.clockStart" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockStart(${clock_source}, ${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockStop()" id="module.driver.cgc_cfg.clockStop" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockStop(${clock_source});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockSet()" id="module.driver.cgc_cfg.systemClockSet" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="systemClockSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;systemClockSet(${clock_source}, ${p_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockGet()" id="module.driver.cgc_cfg.systemClockGet" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="systemClockGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;systemClockGet(${p_clock_source}, ${p_set_clock_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systemClockFreqGet()" id="module.driver.cgc_cfg.systemClockFreqGet" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="systemClockFreqGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;systemClockFreqGet(${clock}, ${p_freq_hz});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockCheck()" id="module.driver.cgc_cfg.clockCheck" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockCheck(${clock_source});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call oscStopDetect()" id="module.driver.cgc_cfg.oscStopDetect" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="oscStopDetect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;oscStopDetect(${p_args}, ${enable});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call oscStopStatusClear()" id="module.driver.cgc_cfg.oscStopStatusClear" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="oscStopStatusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;oscStopStatusClear();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutCfg()" id="module.driver.cgc_cfg.busClockOutCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="busClockOutCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;busClockOutCfg(${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutEnable()" id="module.driver.cgc_cfg.busClockOutEnable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="busClockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;busClockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call busClockOutDisable()" id="module.driver.cgc_cfg.busClockOutDisable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="busClockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;busClockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutCfg()" id="module.driver.cgc_cfg.clockOutCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockOutCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockOutCfg(${clock}, ${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutEnable()" id="module.driver.cgc_cfg.clockOutEnable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clockOutDisable()" id="module.driver.cgc_cfg.clockOutDisable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="clockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;clockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockCfg()" id="module.driver.cgc_cfg.lcdClockCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="lcdClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;lcdClockCfg(${clock});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockEnable()" id="module.driver.cgc_cfg.lcdClockEnable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="lcdClockEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;lcdClockEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lcdClockDisable()" id="module.driver.cgc_cfg.lcdClockDisable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="lcdClockDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;lcdClockDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockCfg()" id="module.driver.cgc_cfg.sdadcClockCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="sdadcClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;sdadcClockCfg(${clock});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockEnable()" id="module.driver.cgc_cfg.sdadcClockEnable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="sdadcClockEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;sdadcClockEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdadcClockDisable()" id="module.driver.cgc_cfg.sdadcClockDisable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="sdadcClockDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;sdadcClockDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdramClockOutEnable()" id="module.driver.cgc_cfg.sdramClockOutEnable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="sdramClockOutEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;sdramClockOutEnable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sdramClockOutDisable()" id="module.driver.cgc_cfg.sdramClockOutDisable" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="sdramClockOutDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;sdramClockOutDisable();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call usbClockCfg()" id="module.driver.cgc_cfg.usbClockCfg" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="usbClockCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;usbClockCfg(${divider});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call systickUpdate()" id="module.driver.cgc_cfg.systickUpdate" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="systickUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;systickUpdate(${period_count}, ${units});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.cgc_cfg.versionGet" version="1"><moduleRef id="module.driver.cgc_cfg"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cgc_cfg.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.adc_on_adc" /><description>
<![CDATA[<form><p><span color="header" font="header">ADC HAL Module Introduction</span></p><p>The ADC HAL module implements an API for analog-to-digital conversion applications. It supports the ADC12, ADC14, and ADC16 (for supported MCUs) for the associated peripherals available on Synergy MCUs. A user-defined callback can be used to process the data each time a new sample is complete.</p><p><b>ADC HAL Module Features</b></p><li bindent="0" vspace="false">16-Bit A/D Converter (S1JA)</li><li bindent="0" vspace="false">14-Bit A/D Converter (S3A7, S3A3, S3A6, S3A1, S128, S124)</li><li bindent="0" vspace="false">12-Bit A/D Converter (S7G2, S5D9, S5D5)</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Single Scan</li><li bindent="20" vspace="false">Group Scan</li><li bindent="20" vspace="false">Continuous Scan</li><li bindent="0" vspace="false">Multiple Channels</li><li bindent="20" vspace="false">All analog channels on MCU</li><li bindent="40" vspace="false">13 channels (unit 0) or 12 channels (unit 1) for S7G2</li><li bindent="40" vspace="false">17 channels for S1JA</li><li bindent="40" vspace="false">18 channels for S124</li><li bindent="40" vspace="false">28 channels for S3A7</li><li bindent="20" vspace="false">Temperature sensor channel</li><li bindent="20" vspace="false">Voltage sensor channel</li><li bindent="0" vspace="false">Reference voltage selection on 16-Bit A/D Converter (S1JA).</li><li bindent="0" vspace="false">Programmable gain amplifier (PGA) (S7G2, S5D9, S5D3)</li><li bindent="20" vspace="false">Single ended input mode</li><li bindent="20" vspace="false">Differential input mode</li><p><b>ADC Hardware support details</b></p><p>The following hardware features are, or are not, supported by the SSP for the ADC:</p><p>Legend:</p><li bindent="0" vspace="false">Note: ELC is supported but only for Group mode. This must be set up manually by programming the Event Link Controller.</li><p><span color="header" font="header">ADC HAL Module Features</span></p><li bindent="0" vspace="false">16-Bit A/D Converter (S1JA)</li><li bindent="0" vspace="false">14-Bit A/D Converter (S3A7, S3A3, S3A6, S3A1, S128, S124)</li><li bindent="0" vspace="false">12-Bit A/D Converter (S7G2, S5D9, S5D5)</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Single Scan</li><li bindent="20" vspace="false">Group Scan</li><li bindent="20" vspace="false">Continuous Scan</li><li bindent="0" vspace="false">Multiple Channels</li><li bindent="20" vspace="false">All analog channels on MCU</li><li bindent="40" vspace="false">13 channels (unit 0) or 12 channels (unit 1) for S7G2</li><li bindent="40" vspace="false">17 channels for S1JA</li><li bindent="40" vspace="false">18 channels for S124</li><li bindent="40" vspace="false">28 channels for S3A7</li><li bindent="20" vspace="false">Temperature sensor channel</li><li bindent="20" vspace="false">Voltage sensor channel</li><li bindent="0" vspace="false">Reference voltage selection on 16-Bit A/D Converter (S1JA).</li><li bindent="0" vspace="false">Programmable gain amplifier (PGA) (S7G2, S5D9, S5D3)</li><li bindent="20" vspace="false">Single ended input mode</li><li bindent="20" vspace="false">Differential input mode</li></form>]]>
</description><function display="ssp_err_t (*open) (adc_ctrl_t *const p_ctrl, adc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize ADC Unit; apply power, set the operational mode, trigger sources, interrupt priority, and configurations common to all channels and sensors. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Open()</span></li><p><b>Precondition</b></p><p>Configure peripheral clocks, ADC pins and IRQs prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanCfg) (adc_ctrl_t *const p_ctrl, adc_channel_cfg_t const *const p_channel_cfg)" id="scanCfg"><description>
<![CDATA[<form><p>Configure the scan including the channels, groups and scan triggers to be used for the unit that was initialized in the open call. Some configurations are not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanConfigure()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_channel_cfg</span> :   Pointer to scan configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStart) (adc_ctrl_t *const p_ctrl)" id="scanStart"><description>
<![CDATA[<form><p>Start the scan (in case of a software trigger), or enable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStart()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStop) (adc_ctrl_t *const p_ctrl)" id="scanStop"><description>
<![CDATA[<form><p>Stop the ADC scan (in case of a software trigger), or disable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStop()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStatusGet) (adc_ctrl_t *const p_ctrl)" id="scanStatusGet"><description>
<![CDATA[<form><p>Check scan status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_CheckScanDone()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_CheckScanDone()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint16_t *const p_data)" id="read"><description>
<![CDATA[<form><p>Read ADC conversion result. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read32) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint32_t *const p_data)" id="read32"><description>
<![CDATA[<form><p>Read ADC conversion result into a 32-bit word. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Read32()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sampleStateCountSet) (adc_ctrl_t *const p_ctrl, adc_sample_state_t *p_sample)" id="sampleStateCountSet"><description>
<![CDATA[<form><p>Set the sample state count for the specified channel. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_SetSampleStateCount()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_sample</span> :   Pointer to the ADC channels and corresponding sample states to be set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calibrate) (adc_ctrl_t *const p_ctrl, void *const p_extend)" id="calibrate"><description>
<![CDATA[<form><p>Calibrate ADC or associated PGA (programmable gain amplifier). The driver may require implementation specific arguments to the p_extend input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Calibrate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_extend</span> :   Pointer to implementation specific arguments </li><p /></form>]]>
</description></function><function display="ssp_err_t (*offsetSet) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, int32_t const offset)" id="offsetSet"><description>
<![CDATA[<form><p>Set offset for input PGA configured for differential input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_OffsetSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">offset</span> :   See implementation for details. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (adc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the specified ADC unit by ending any scan in progress, disabling interrupts, and removing power to the specified A/D unit. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (adc_ctrl_t *const p_ctrl, adc_info_t *const p_adc_info)" id="infoGet"><description>
<![CDATA[<form><p>Return the ADC data register address of the first (lowest number) channel and the total number of bytes to be read in order for the DTC/DMAC to read the conversion results of all configured channels. Return the temperature sensor calibration and slope data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_adc_info</span> :   Pointer to ADC information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.adc_on_adc.open" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanCfg()" id="module.driver.adc_on_adc.scanCfg" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="scanCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanCfg(${instance}.p_ctrl, ${instance}.p_channel_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStart()" id="module.driver.adc_on_adc.scanStart" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="scanStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStop()" id="module.driver.adc_on_adc.scanStop" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="scanStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStatusGet()" id="module.driver.adc_on_adc.scanStatusGet" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="scanStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStatusGet(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.adc_on_adc.read" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;read(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read32()" id="module.driver.adc_on_adc.read32" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="read32" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;read32(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sampleStateCountSet()" id="module.driver.adc_on_adc.sampleStateCountSet" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="sampleStateCountSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;sampleStateCountSet(${instance}.p_ctrl, ${p_sample});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calibrate()" id="module.driver.adc_on_adc.calibrate" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="calibrate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;calibrate(${instance}.p_ctrl, ${p_extend});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call offsetSet()" id="module.driver.adc_on_adc.offsetSet" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="offsetSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;offsetSet(${instance}.p_ctrl, ${reg_id}, ${offset});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.adc_on_adc.close" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.adc_on_adc.infoGet" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_adc_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.adc_on_adc.versionGet" version="1"><moduleRef id="module.driver.adc_on_adc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.adc_on_adc.callback_def.0" version="1"><moduleRef id="module.driver.adc_on_adc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.adc.p_callback)}(adc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.sdadc_on_adc" /><description>
<![CDATA[<form><p><span color="header" font="header">SDADC HAL Module Introduction</span></p><p>The SDADC HAL module provides a high level API for analog-to-digital conversions and supports the SDADC24 24-bit analog-to-digital converter peripheral available on the Synergy microcontroller hardware. A user-defined callback can be created to process the data each time a new sample is available.</p><p><b>SDADC HAL Module Features</b></p><li bindent="0" vspace="false">24-bit sigma delta A/D Converter</li><li bindent="0" vspace="false">Single scan or continuous scan operation mode</li><li bindent="0" vspace="false">Single-ended or differential input</li><li bindent="0" vspace="false">Gain of up to 32 on differential inputs</li><li bindent="0" vspace="false">Oversampling ratio configurable on differential inputs</li><p><b>SDADC Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for SDADC:</p><p>Legend:</p><p><span color="header" font="header">SDADC HAL Module Features</span></p><li bindent="0" vspace="false">24-bit sigma delta A/D Converter</li><li bindent="0" vspace="false">Single scan or continuous scan operation mode</li><li bindent="0" vspace="false">Single-ended or differential input</li><li bindent="0" vspace="false">Gain of up to 32 on differential inputs</li><li bindent="0" vspace="false">Oversampling ratio configurable on differential inputs</li></form>]]>
</description><function display="ssp_err_t (*open) (adc_ctrl_t *const p_ctrl, adc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize ADC Unit; apply power, set the operational mode, trigger sources, interrupt priority, and configurations common to all channels and sensors. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Open()</span></li><p><b>Precondition</b></p><p>Configure peripheral clocks, ADC pins and IRQs prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanCfg) (adc_ctrl_t *const p_ctrl, adc_channel_cfg_t const *const p_channel_cfg)" id="scanCfg"><description>
<![CDATA[<form><p>Configure the scan including the channels, groups and scan triggers to be used for the unit that was initialized in the open call. Some configurations are not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanConfigure()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_channel_cfg</span> :   Pointer to scan configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStart) (adc_ctrl_t *const p_ctrl)" id="scanStart"><description>
<![CDATA[<form><p>Start the scan (in case of a software trigger), or enable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStart()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStop) (adc_ctrl_t *const p_ctrl)" id="scanStop"><description>
<![CDATA[<form><p>Stop the ADC scan (in case of a software trigger), or disable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStop()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStatusGet) (adc_ctrl_t *const p_ctrl)" id="scanStatusGet"><description>
<![CDATA[<form><p>Check scan status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_CheckScanDone()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_CheckScanDone()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint16_t *const p_data)" id="read"><description>
<![CDATA[<form><p>Read ADC conversion result. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read32) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint32_t *const p_data)" id="read32"><description>
<![CDATA[<form><p>Read ADC conversion result into a 32-bit word. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Read32()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sampleStateCountSet) (adc_ctrl_t *const p_ctrl, adc_sample_state_t *p_sample)" id="sampleStateCountSet"><description>
<![CDATA[<form><p>Set the sample state count for the specified channel. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_SetSampleStateCount()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_sample</span> :   Pointer to the ADC channels and corresponding sample states to be set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calibrate) (adc_ctrl_t *const p_ctrl, void *const p_extend)" id="calibrate"><description>
<![CDATA[<form><p>Calibrate ADC or associated PGA (programmable gain amplifier). The driver may require implementation specific arguments to the p_extend input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Calibrate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_extend</span> :   Pointer to implementation specific arguments </li><p /></form>]]>
</description></function><function display="ssp_err_t (*offsetSet) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, int32_t const offset)" id="offsetSet"><description>
<![CDATA[<form><p>Set offset for input PGA configured for differential input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_OffsetSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">offset</span> :   See implementation for details. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (adc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the specified ADC unit by ending any scan in progress, disabling interrupts, and removing power to the specified A/D unit. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (adc_ctrl_t *const p_ctrl, adc_info_t *const p_adc_info)" id="infoGet"><description>
<![CDATA[<form><p>Return the ADC data register address of the first (lowest number) channel and the total number of bytes to be read in order for the DTC/DMAC to read the conversion results of all configured channels. Return the temperature sensor calibration and slope data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_adc_info</span> :   Pointer to ADC information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.sdadc_on_adc.open" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanCfg()" id="module.driver.sdadc_on_adc.scanCfg" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="scanCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanCfg(${instance}.p_ctrl, ${instance}.p_channel_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStart()" id="module.driver.sdadc_on_adc.scanStart" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="scanStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStop()" id="module.driver.sdadc_on_adc.scanStop" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="scanStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStatusGet()" id="module.driver.sdadc_on_adc.scanStatusGet" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="scanStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;scanStatusGet(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.sdadc_on_adc.read" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;read(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read32()" id="module.driver.sdadc_on_adc.read32" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="read32" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;read32(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sampleStateCountSet()" id="module.driver.sdadc_on_adc.sampleStateCountSet" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="sampleStateCountSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;sampleStateCountSet(${instance}.p_ctrl, ${p_sample});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calibrate()" id="module.driver.sdadc_on_adc.calibrate" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="calibrate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;calibrate(${instance}.p_ctrl, ${p_extend});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call offsetSet()" id="module.driver.sdadc_on_adc.offsetSet" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="offsetSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;offsetSet(${instance}.p_ctrl, ${reg_id}, ${offset});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.sdadc_on_adc.close" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.sdadc_on_adc.infoGet" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_adc_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.sdadc_on_adc.versionGet" version="1"><moduleRef id="module.driver.sdadc_on_adc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.sdadc_on_adc.callback_def.0" version="1"><moduleRef id="module.driver.sdadc_on_adc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.adc.p_callback)}(adc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.sdadc_channel" /><description>
<![CDATA[<form><p><span color="header" font="header">SDADC HAL Module Introduction</span></p><p>The SDADC HAL module provides a high level API for analog-to-digital conversions and supports the SDADC24 24-bit analog-to-digital converter peripheral available on the Synergy microcontroller hardware. A user-defined callback can be created to process the data each time a new sample is available.</p><p><b>SDADC HAL Module Features</b></p><li bindent="0" vspace="false">24-bit sigma delta A/D Converter</li><li bindent="0" vspace="false">Single scan or continuous scan operation mode</li><li bindent="0" vspace="false">Single-ended or differential input</li><li bindent="0" vspace="false">Gain of up to 32 on differential inputs</li><li bindent="0" vspace="false">Oversampling ratio configurable on differential inputs</li><p><b>SDADC Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for SDADC:</p><p>Legend:</p><p><span color="header" font="header">SDADC HAL Module Features</span></p><li bindent="0" vspace="false">24-bit sigma delta A/D Converter</li><li bindent="0" vspace="false">Single scan or continuous scan operation mode</li><li bindent="0" vspace="false">Single-ended or differential input</li><li bindent="0" vspace="false">Gain of up to 32 on differential inputs</li><li bindent="0" vspace="false">Oversampling ratio configurable on differential inputs</li></form>]]>
</description><function display="ssp_err_t (*open) (adc_ctrl_t *const p_ctrl, adc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize ADC Unit; apply power, set the operational mode, trigger sources, interrupt priority, and configurations common to all channels and sensors. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Open()</span></li><p><b>Precondition</b></p><p>Configure peripheral clocks, ADC pins and IRQs prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanCfg) (adc_ctrl_t *const p_ctrl, adc_channel_cfg_t const *const p_channel_cfg)" id="scanCfg"><description>
<![CDATA[<form><p>Configure the scan including the channels, groups and scan triggers to be used for the unit that was initialized in the open call. Some configurations are not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanConfigure()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_channel_cfg</span> :   Pointer to scan configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStart) (adc_ctrl_t *const p_ctrl)" id="scanStart"><description>
<![CDATA[<form><p>Start the scan (in case of a software trigger), or enable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStart()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStop) (adc_ctrl_t *const p_ctrl)" id="scanStop"><description>
<![CDATA[<form><p>Stop the ADC scan (in case of a software trigger), or disable the hardware trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_ScanStop()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_ScanStop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStatusGet) (adc_ctrl_t *const p_ctrl)" id="scanStatusGet"><description>
<![CDATA[<form><p>Check scan status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_CheckScanDone()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_CheckScanDone()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint16_t *const p_data)" id="read"><description>
<![CDATA[<form><p>Read ADC conversion result. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read32) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, uint32_t *const p_data)" id="read32"><description>
<![CDATA[<form><p>Read ADC conversion result into a 32-bit word. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Read32()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to variable to load value into. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sampleStateCountSet) (adc_ctrl_t *const p_ctrl, adc_sample_state_t *p_sample)" id="sampleStateCountSet"><description>
<![CDATA[<form><p>Set the sample state count for the specified channel. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_SetSampleStateCount()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_sample</span> :   Pointer to the ADC channels and corresponding sample states to be set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calibrate) (adc_ctrl_t *const p_ctrl, void *const p_extend)" id="calibrate"><description>
<![CDATA[<form><p>Calibrate ADC or associated PGA (programmable gain amplifier). The driver may require implementation specific arguments to the p_extend input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_Calibrate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_extend</span> :   Pointer to implementation specific arguments </li><p /></form>]]>
</description></function><function display="ssp_err_t (*offsetSet) (adc_ctrl_t *const p_ctrl, adc_register_t const reg_id, int32_t const offset)" id="offsetSet"><description>
<![CDATA[<form><p>Set offset for input PGA configured for differential input. Not supported for all implementations. See implementation for details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SDADC_OffsetSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">reg_id</span> :   ADC channel to read (see enumeration adc_register_t) </li><li bindent="0" vspace="false"><span font="code">offset</span> :   See implementation for details. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (adc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the specified ADC unit by ending any scan in progress, disabling interrupts, and removing power to the specified A/D unit. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (adc_ctrl_t *const p_ctrl, adc_info_t *const p_adc_info)" id="infoGet"><description>
<![CDATA[<form><p>Return the ADC data register address of the first (lowest number) channel and the total number of bytes to be read in order for the DTC/DMAC to read the conversion results of all configured channels. Return the temperature sensor calibration and slope data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_adc_info</span> :   Pointer to ADC information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ADC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SDADC_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.sdadc_channel.open" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanCfg()" id="module.driver.sdadc_channel.scanCfg" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="scanCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;scanCfg(${instance}.p_ctrl, ${instance}.p_channel_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStart()" id="module.driver.sdadc_channel.scanStart" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="scanStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;scanStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStop()" id="module.driver.sdadc_channel.scanStop" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="scanStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;scanStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStatusGet()" id="module.driver.sdadc_channel.scanStatusGet" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="scanStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;scanStatusGet(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.sdadc_channel.read" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;read(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read32()" id="module.driver.sdadc_channel.read32" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="read32" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;read32(${instance}.p_ctrl, ${reg_id}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sampleStateCountSet()" id="module.driver.sdadc_channel.sampleStateCountSet" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="sampleStateCountSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;sampleStateCountSet(${instance}.p_ctrl, ${p_sample});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calibrate()" id="module.driver.sdadc_channel.calibrate" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="calibrate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;calibrate(${instance}.p_ctrl, ${p_extend});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call offsetSet()" id="module.driver.sdadc_channel.offsetSet" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="offsetSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;offsetSet(${instance}.p_ctrl, ${reg_id}, ${offset});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.sdadc_channel.close" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.sdadc_channel.infoGet" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_adc_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.sdadc_channel.versionGet" version="1"><moduleRef id="module.driver.sdadc_channel"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.adc.channel)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.sdadc_channel.callback_def.0" version="1"><moduleRef id="module.driver.sdadc_channel" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.adc.p_callback)}(adc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.comparator_on_acmphs" /><description>
<![CDATA[<form><p><span color="header" font="header">ACMPHS HAL Module Introduction</span></p><p>The ACMPHS HAL module implements the comparator API for signal processing applications and supports the ACMPHS peripheral available on the Synergy microcontroller hardware. A callback is available to signal the user application on transition events.</p><p><b>ACMPHS HAL Module Features</b></p><li bindent="0" vspace="false">Callback on rising edge, falling edge or both</li><li bindent="0" vspace="false">Configurable debounce filter</li><li bindent="0" vspace="false">Option to include comparator output on VCOUT pin</li><p><b>ACMPHS Hardware support details</b></p><p>The following hardware features are, or are not, supported by the SSP for the ACMPHS:</p><p>Legend:</p><p><span color="header" font="header">ACMPHS HAL Module Features</span></p><li bindent="0" vspace="false">Callback on rising edge, falling edge or both</li><li bindent="0" vspace="false">Configurable debounce filter</li><li bindent="0" vspace="false">Option to include comparator output on VCOUT pin</li></form>]]>
</description><function display="ssp_err_t (*open) (comparator_ctrl_t *const p_ctrl, comparator_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*outputEnable) (comparator_ctrl_t *const p_ctrl)" id="outputEnable"><description>
<![CDATA[<form><p>Start the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_OutputEnable()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_OutputEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (comparator_ctrl_t *const p_ctrl, comparator_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Provide information such as the recommended minimum stabilization wait time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Comparator information stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (comparator_ctrl_t *const p_ctrl, comparator_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Provide current comparator status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Status stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (comparator_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Stop the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.comparator_on_acmphs.open" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call outputEnable()" id="module.driver.comparator_on_acmphs.outputEnable" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="outputEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;outputEnable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.comparator_on_acmphs.infoGet" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.comparator_on_acmphs.statusGet" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.comparator_on_acmphs.close" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.comparator_on_acmphs.versionGet" version="1"><moduleRef id="module.driver.comparator_on_acmphs"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.comparator_on_acmphs.callback_def.0" version="1"><moduleRef id="module.driver.comparator_on_acmphs" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.comparator.p_callback)}(comparator_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.comparator_on_acmplp" /><description>
<![CDATA[<form><p><span color="header" font="header">ACMPLP HAL Module Introduction</span></p><p>The ACMPLP HAL module implements the comparator API for signal processing applications and supports the ACMPLP peripheral available on the Synergy microcontroller hardware. A callback is available to signal the user application on transition events.</p><p><b>ACMPLP HAL Module Features</b></p><li bindent="0" vspace="false">Normal mode or window mode</li><li bindent="0" vspace="false">Callback on rising edge, falling edge or both</li><li bindent="0" vspace="false">Configurable debounce filter</li><li bindent="0" vspace="false">Option to include comparator output on VCOUT pin</li><p><b>ACMPLP Hardware support details</b></p><p>The following hardware features are, or are not, supported by the SSP for the ACMPLP:</p><p>Legend:</p><p><span color="header" font="header">ACMPLP HAL Module Features</span></p><li bindent="0" vspace="false">Normal mode or window mode</li><li bindent="0" vspace="false">Callback on rising edge, falling edge or both</li><li bindent="0" vspace="false">Configurable debounce filter</li><li bindent="0" vspace="false">Option to include comparator output on VCOUT pin</li></form>]]>
</description><function display="ssp_err_t (*open) (comparator_ctrl_t *const p_ctrl, comparator_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*outputEnable) (comparator_ctrl_t *const p_ctrl)" id="outputEnable"><description>
<![CDATA[<form><p>Start the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_OutputEnable()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_OutputEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (comparator_ctrl_t *const p_ctrl, comparator_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Provide information such as the recommended minimum stabilization wait time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Comparator information stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (comparator_ctrl_t *const p_ctrl, comparator_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Provide current comparator status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Status stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (comparator_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Stop the comparator. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ACMPHS_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_ACMPLP_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.comparator_on_acmplp.open" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call outputEnable()" id="module.driver.comparator_on_acmplp.outputEnable" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="outputEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;outputEnable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.comparator_on_acmplp.infoGet" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.comparator_on_acmplp.statusGet" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.comparator_on_acmplp.close" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.comparator_on_acmplp.versionGet" version="1"><moduleRef id="module.driver.comparator_on_acmplp"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.comparator.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.comparator_on_acmplp.callback_def.0" version="1"><moduleRef id="module.driver.comparator_on_acmplp" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.comparator.p_callback)}(comparator_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.dac_on_dac" /><description>
<![CDATA[<form><p><span color="header" font="header">DAC HAL Module Introduction</span></p><p>The DAC HAL module provides a high-level API for digital-to-analog conversion applications and supports a dual-channel 12-bit D/A converter (DAC12) peripheral on Synergy MCUs.</p><p><b>DAC HAL Module Features</b></p><p>This module configures the dual-channel 12-bit D/A Converter (DAC12) to output one of 4096 voltage levels between the positive and negative reference voltages. The module includes configuration settings to:</p><li bindent="0" vspace="false">Set either a left-justified or right-justified 12-bit value format for the 16-bit input data registers</li><li bindent="0" vspace="false">Enable or disable output amplifiers</li><li bindent="0" vspace="false">Enable or disable charge pump</li><li bindent="0" vspace="false">Operate in synchronous anti-interference mode with the Analog-to-Digital Converter (ADC) module.</li><p><b>DAC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the DAC.</p><p>Legend:</p><li bindent="0" vspace="false">Note: The ELC event could be used instead of calling the DAC start() interface. This would have to be programmed by the user by setting up the link rather than using the ELC API. </li><p><span color="header" font="header">DAC HAL Module Features</span></p><p>This module configures the dual-channel 12-bit D/A Converter (DAC12) to output one of 4096 voltage levels between the positive and negative reference voltages. The module includes configuration settings to:</p><li bindent="0" vspace="false">Set either a left-justified or right-justified 12-bit value format for the 16-bit input data registers</li><li bindent="0" vspace="false">Enable or disable output amplifiers</li><li bindent="0" vspace="false">Enable or disable charge pump</li><li bindent="0" vspace="false">Operate in synchronous anti-interference mode with the Analog-to-Digital Converter (ADC) module.</li></form>]]>
</description><function display="ssp_err_t (*open) (dac_ctrl_t *p_ctrl, dac_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (dac_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the D/A Converter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (dac_ctrl_t *p_ctrl, dac_size_t value)" id="write"><description>
<![CDATA[<form><p>Write sample value to the D/A Converter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">value</span> :   Sample value to be written to the D/A Converter. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (dac_ctrl_t *p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start the D/A Converter if it has not been started yet. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (dac_ctrl_t *p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop the D/A Converter if the converter is running. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Stop()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (dac_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get information about DAC Resolution and store it in provided pointer p_info. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this DAC. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.dac_on_dac.open" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.dac_on_dac.close" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.dac_on_dac.write" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;write(${instance}.p_ctrl, ${value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.dac_on_dac.start" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.dac_on_dac.stop" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.dac_on_dac.versionGet" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.dac_on_dac.infoGet" version="1"><moduleRef id="module.driver.dac_on_dac"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac.name)}.p_api-&gt;infoGet(${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.dac_on_dac8" /><description>
<![CDATA[<form><p><span color="header" font="header">DAC8 HAL Module Introduction</span></p><p>The DAC8 HAL module provides a high-level API for digital-to-analog conversion applications and supports an 8-bit D/A converter (DAC8) peripheral on Synergy MCUs.</p><p><b>DAC8 HAL Module Features</b></p><li bindent="0" vspace="false">8-Bit D/A Converter</li><li bindent="0" vspace="false">Left-Justified or Right-Justified Input Data Format</li><li bindent="0" vspace="false">Synchronization with the Analog-to-Digital Converter (ADC) module</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Normal</li><li bindent="20" vspace="false">Real-Time (Event Link)</li><li bindent="20" vspace="false">Charge Pump Control</li><p><b>DAC8 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the DAC8.</p><p>Legend:</p><li bindent="0" vspace="false">Note: The ELC event could be used instead of calling the DAC start() interface. This would have to be programmed by the user by setting up the link rather than using the ELC API. </li><p><span color="header" font="header">DAC8 HAL Module Introduction</span></p><p>The DAC8 HAL module provides a high-level API for digital-to-analog conversion applications and supports an 8-bit D/A converter (DAC8) peripheral on Synergy MCUs.</p><p><b>DAC8 HAL Module Features</b></p><li bindent="0" vspace="false">8-Bit D/A Converter</li><li bindent="0" vspace="false">Left-Justified or Right-Justified Input Data Format</li><li bindent="0" vspace="false">Synchronization with the Analog-to-Digital Converter (ADC) module</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Normal</li><li bindent="20" vspace="false">Real-Time (Event Link)</li><li bindent="20" vspace="false">Charge Pump Control</li><p><b>DAC8 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the DAC8.</p><p>Legend:</p><li bindent="0" vspace="false">Note: The ELC event could be used instead of calling the DAC start() interface. This would have to be programmed by the user by setting up the link rather than using the ELC API. </li></form>]]>
</description><function display="ssp_err_t (*open) (dac_ctrl_t *p_ctrl, dac_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (dac_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the D/A Converter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (dac_ctrl_t *p_ctrl, dac_size_t value)" id="write"><description>
<![CDATA[<form><p>Write sample value to the D/A Converter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">value</span> :   Sample value to be written to the D/A Converter. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (dac_ctrl_t *p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start the D/A Converter if it has not been started yet. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (dac_ctrl_t *p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop the D/A Converter if the converter is running. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_Stop()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">dac_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (dac_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get information about DAC Resolution and store it in provided pointer p_info. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DAC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DAC8_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this DAC. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.dac_on_dac8.open" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.dac_on_dac8.close" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.dac_on_dac8.write" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;write(${instance}.p_ctrl, ${value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.dac_on_dac8.start" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.dac_on_dac8.stop" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.dac_on_dac8.versionGet" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.dac_on_dac8.infoGet" version="1"><moduleRef id="module.driver.dac_on_dac8"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.dac8.name)}.p_api-&gt;infoGet(${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.opamp_on_opamp" /><description>
<![CDATA[<form><p><span color="header" font="header">DAC HAL Module Introduction</span></p><p>The DAC HAL module provides a high-level API for digital-to-analog conversion applications and supports a dual-channel 12-bit D/A converter (DAC12) peripheral on Synergy MCUs.</p><p><b>DAC HAL Module Features</b></p><p>This module configures the dual-channel 12-bit D/A Converter (DAC12) to output one of 4096 voltage levels between the positive and negative reference voltages. The module includes configuration settings to:</p><li bindent="0" vspace="false">Set either a left-justified or right-justified 12-bit value format for the 16-bit input data registers</li><li bindent="0" vspace="false">Enable or disable output amplifiers</li><li bindent="0" vspace="false">Enable or disable charge pump</li><li bindent="0" vspace="false">Operate in synchronous anti-interference mode with the Analog-to-Digital Converter (ADC) module.</li><p><b>DAC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the DAC.</p><p>Legend:</p><li bindent="0" vspace="false">Note: The ELC event could be used instead of calling the DAC start() interface. This would have to be programmed by the user by setting up the link rather than using the ELC API. </li><p><span color="header" font="header">DAC HAL Module Features</span></p><p>This module configures the dual-channel 12-bit D/A Converter (DAC12) to output one of 4096 voltage levels between the positive and negative reference voltages. The module includes configuration settings to:</p><li bindent="0" vspace="false">Set either a left-justified or right-justified 12-bit value format for the 16-bit input data registers</li><li bindent="0" vspace="false">Enable or disable output amplifiers</li><li bindent="0" vspace="false">Enable or disable charge pump</li><li bindent="0" vspace="false">Operate in synchronous anti-interference mode with the Analog-to-Digital Converter (ADC) module.</li></form>]]>
</description><function display="ssp_err_t (*open) (opamp_ctrl_t *const p_ctrl, opamp_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize the operational amplifier. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (opamp_ctrl_t *const p_ctrl, uint32_t const channel_mask)" id="start"><description>
<![CDATA[<form><p>Start the op-amp(s). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">channel_mask</span> :   Bitmask of channels to start </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (opamp_ctrl_t *const p_ctrl, uint32_t const channel_mask)" id="stop"><description>
<![CDATA[<form><p>Stop the op-amp(s). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">channel_mask</span> :   Bitmask of channels to stop </li><p /></form>]]>
</description></function><function display="ssp_err_t (*trim) (opamp_ctrl_t *const p_ctrl, opamp_trim_cmd_t const cmd, opamp_trim_args_t const *const p_args)" id="trim"><description>
<![CDATA[<form><p>Trim the op-amp(s). Not supported on all MCUs. See implementation for procedure details. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_Trim()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">cmd</span> :   Trim command </li><li bindent="0" vspace="false"><span font="code">p_args</span> :   Pointer to arguments for the command </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (opamp_ctrl_t *const p_ctrl, opamp_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Provide information such as the recommended minimum stabilization wait time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   OPAMP information stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (opamp_ctrl_t *const p_ctrl, opamp_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Provide status of each op-amp channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Status stored here </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (opamp_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the specified OPAMP unit by ending any scan in progress, disabling interrupts, and removing power to the specified A/D unit. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to instance control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Retrieve the API version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_OPAMP_VersionGet()</span></li><p><b>Precondition</b></p><p>This function retrieves the API version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.opamp_on_opamp.open" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.opamp_on_opamp.start" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;start(${instance}.p_ctrl, ${channel_mask});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.opamp_on_opamp.stop" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;stop(${instance}.p_ctrl, ${channel_mask});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call trim()" id="module.driver.opamp_on_opamp.trim" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="trim" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;trim(${instance}.p_ctrl, ${cmd}, ${p_args});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.opamp_on_opamp.infoGet" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.opamp_on_opamp.statusGet" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.opamp_on_opamp.close" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.opamp_on_opamp.versionGet" version="1"><moduleRef id="module.driver.opamp_on_opamp"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.opamp.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.can_on_can" /><description>
<![CDATA[<form><p><span color="header" font="header">CAN HAL Module Introduction</span></p><p>The CAN HAL module provides a high-level API for CAN network applications and supports the CAN peripherals available on the Synergy microcontroller hardware. A user-callback function must be defined, which the driver will invoke when transmit, receive or error interrupts are received. The callback returns with a parameter which indicates the channel, mailbox and event.</p><p><b>CAN HAL Module Features</b></p><li bindent="0" vspace="false">Supports both standard (11-bit) and extended (29-bit) messaging formats</li><li bindent="0" vspace="false">Support for bit timing configuration as defined in the CAN specification</li><li bindent="0" vspace="false">Supports up to 32 transmit or receive mailboxes with standard or extended ID frames</li><li bindent="0" vspace="false">Receive mailboxes can be configured to capture either data or remote CAN Frames</li><li bindent="0" vspace="false">Receive mailboxes can be configured to receive a range of IDs using mailbox masks</li><li bindent="0" vspace="false">Supports a user-callback function when transmit, receive, or error interrupts are received</li><p><b>CAN Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for CAN:</p><p>Legend:</p><p><span color="header" font="header">CAN HAL Module Features</span></p><li bindent="0" vspace="false">Supports both standard (11-bit) and extended (29-bit) messaging formats</li><li bindent="0" vspace="false">Support for bit timing configuration as defined in the CAN specification</li><li bindent="0" vspace="false">Supports up to 32 transmit or receive mailboxes with standard or extended ID frames</li><li bindent="0" vspace="false">Receive mailboxes can be configured to capture either data or remote CAN Frames</li><li bindent="0" vspace="false">Receive mailboxes can be configured to receive a range of IDs using mailbox masks</li><li bindent="0" vspace="false">Supports a user-callback function when transmit, receive, or error interrupts are received</li></form>]]>
</description><function display="ssp_err_t (*open) (can_ctrl_t *const p_ctrl, can_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open function for CAN device </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CAN control block Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">can_cfg_t</span> :   Pointer to CAN configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (can_ctrl_t *const p_ctrl, uint32_t mailbox, can_frame_t *const p_frame)" id="read"><description>
<![CDATA[<form><p>Read function for CAN device, non-Blocking. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_Read()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CAN control block for the channel. </li><li bindent="0" vspace="false"><span font="code">mailbox</span> :   Mailbox to read from. </li><li bindent="0" vspace="false"><span font="code">p_frame</span> :   Pointer for frame of CAN ID, DLC, data and frame type. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (can_ctrl_t *const p_ctrl, uint32_t mailbox, can_frame_t *const p_frame)" id="write"><description>
<![CDATA[<form><p>Write function for CAN device </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_Write()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CAN control block. </li><li bindent="0" vspace="false"><span font="code">mailbox</span> :   Mailbox to write to. </li><li bindent="0" vspace="false"><span font="code">p_frame</span> :   Pointer for frame of CAN ID, DLC, data and frame type to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (can_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close function for CAN device </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CAN control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*control) (can_ctrl_t *const p_ctrl, can_command_t const command, void *p_data)" id="control"><description>
<![CDATA[<form><p>Control function for CAN device </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_Control()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CAN control block. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command type. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Command data. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (can_ctrl_t *const p_ctrl, can_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get CAN channel info. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle for channel (pointer to channel control block) </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Memory address to return channel specific data to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Version get function for CAN device </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CAN_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.can_on_can.open" version="1"><moduleRef id="module.driver.can_on_can"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.can_on_can.read" version="1"><moduleRef id="module.driver.can_on_can"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;read(${instance}.p_ctrl, ${mailbox}, ${p_frame});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.can_on_can.write" version="1"><moduleRef id="module.driver.can_on_can"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;write(${instance}.p_ctrl, ${mailbox}, ${p_frame});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.can_on_can.close" version="1"><moduleRef id="module.driver.can_on_can"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call control()" id="module.driver.can_on_can.control" version="1"><moduleRef id="module.driver.can_on_can"><function id="control" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;control(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.can_on_can.infoGet" version="1"><moduleRef id="module.driver.can_on_can"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.can_on_can.versionGet" version="1"><moduleRef id="module.driver.can_on_can"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.can.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.can_on_can.callback_def.0" version="1"><moduleRef id="module.driver.can_on_can" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.can.p_callback)}(can_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.i2c_on_riic" /><description>
<![CDATA[<form><p><span color="header" font="header">I2C Master HAL Module Introduction</span></p><p>The I2C Master on RIIC HAL module provides a high-level API for industry standard I2C serial communications applications and uses the IIC peripheral on a Synergy MCU. Callbacks are provided for transmit complete and receive complete events notification.</p><p><b>I2C Master HAL Module Features</b></p><li bindent="0" vspace="false">Support for I2C RIIC operations</li><li bindent="20" vspace="false">Standard (up to 100 kHz)</li><li bindent="20" vspace="false">I2C fast-mode (up to 400 kHz)</li><li bindent="20" vspace="false">I2C fast-mode plus (up to 1 MHz on channel 0 (SCL0-A, SDA0-A) of S7G2 and S5D9 MCU families)</li><li bindent="0" vspace="false">Initialization of the RIIC module</li><li bindent="0" vspace="false">Read from a slave device</li><li bindent="0" vspace="false">Write to a slave device</li><li bindent="0" vspace="false">Reset the MCUs I2C peripheral</li><li bindent="0" vspace="false">Set the address of the slave device</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transfer aborted (along with exact IIC hardware-generated error event)</li><li bindent="20" vspace="false">Transmit complete (number of bytes transmitted provided)</li><li bindent="20" vspace="false">Receive complete (number of bytes received provided)</li><p><b>RIIC Master Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the RIIC Master Driver:</p><p>Legend:</p><p><span color="header" font="header">I2C Master HAL Module Features</span></p><li bindent="0" vspace="false">Support for I2C RIIC operations</li><li bindent="20" vspace="false">Standard (up to 100 kHz)</li><li bindent="20" vspace="false">I2C fast-mode (up to 400 kHz)</li><li bindent="20" vspace="false">I2C fast-mode plus (up to 1 MHz on channel 0 (SCL0-A, SDA0-A) of S7G2 and S5D9 MCU families)</li><li bindent="0" vspace="false">Initialization of the RIIC module</li><li bindent="0" vspace="false">Read from a slave device</li><li bindent="0" vspace="false">Write to a slave device</li><li bindent="0" vspace="false">Reset the MCUs I2C peripheral</li><li bindent="0" vspace="false">Set the address of the slave device</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transfer aborted (along with exact IIC hardware-generated error event)</li><li bindent="20" vspace="false">Transmit complete (number of bytes transmitted provided)</li><li bindent="20" vspace="false">Receive complete (number of bytes received provided)</li></form>]]>
</description><function display="ssp_err_t (*open) (i2c_ctrl_t *const p_ctrl, i2c_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Opens the I2C driver and initializes the hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements are set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (i2c_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the driver and releases the I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterClose()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, bool const restart)" id="read"><description>
<![CDATA[<form><p>Performs a read operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterRead()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to the location to store read data. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to read. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Specify if the restart condition should be issued after reading. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_src, uint32_t const bytes, bool const restart)" id="write"><description>
<![CDATA[<form><p>Performs a write operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterWrite()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterWrite()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to the location to get write data from. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to write. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Specify if the restart condition should be issued after writing. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (i2c_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Performs a reset of the peripheral. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterReset()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterReset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*slaveAddressSet) (i2c_ctrl_t *const p_ctrl, uint16_t const slave, i2c_addr_mode_t const addr_mode)" id="slaveAddressSet"><description>
<![CDATA[<form><p>Sets address of the slave device without reconfiguring the bus. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterSlaveAddressSet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterSlaveAddressSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">slave_address</span> :   Address of the slave device. </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Addressing mode. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version information and stores it in the provided version struct. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterVersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.i2c_on_riic.open" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.i2c_on_riic.close" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.i2c_on_riic.read" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${restart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.i2c_on_riic.write" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${restart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.i2c_on_riic.reset" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call slaveAddressSet()" id="module.driver.i2c_on_riic.slaveAddressSet" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="slaveAddressSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;slaveAddressSet(${instance}.p_ctrl, ${slave}, ${addr_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.i2c_on_riic.versionGet" version="1"><moduleRef id="module.driver.i2c_on_riic"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.i2c_on_riic.callback_def.0" version="1"><moduleRef id="module.driver.i2c_on_riic" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.i2c.p_callback)}(i2c_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.i2c_on_sci_i2c" /><description>
<![CDATA[<form><p><span color="header" font="header">I2C SCI HAL Module Introduction</span></p><p>The I2C SCI Master HAL module provides a high-level API for I2C industry standard serial device communication applications and uses the SCI peripheral on the Synergy MCU device. Callbacks are provided for transmit complete and receive complete.</p><p><b>I2C SCI HAL Module Features</b></p><li bindent="0" vspace="false">Support for I2C SCI operations</li><li bindent="0" vspace="false">Supports following operations with a slave I2C SCI device</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="20" vspace="false">Reset</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete (number of bytes transmitted provided)</li><li bindent="20" vspace="false">Receive complete (number of bytes received provided)</li><p><b>I2C SCI Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the I2C over SPI.</p><p>Legend:</p><p><span color="header" font="header">I2C SCI HAL Module Features</span></p><li bindent="0" vspace="false">Support for I2C SCI operations</li><li bindent="0" vspace="false">Supports following operations with a slave I2C SCI device</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="20" vspace="false">Reset</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete (number of bytes transmitted provided)</li><li bindent="20" vspace="false">Receive complete (number of bytes received provided)</li></form>]]>
</description><function display="ssp_err_t (*open) (i2c_ctrl_t *const p_ctrl, i2c_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Opens the I2C driver and initializes the hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements are set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (i2c_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the driver and releases the I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterClose()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, bool const restart)" id="read"><description>
<![CDATA[<form><p>Performs a read operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterRead()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to the location to store read data. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to read. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Specify if the restart condition should be issued after reading. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_src, uint32_t const bytes, bool const restart)" id="write"><description>
<![CDATA[<form><p>Performs a write operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterWrite()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterWrite()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to the location to get write data from. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to write. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Specify if the restart condition should be issued after writing. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (i2c_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Performs a reset of the peripheral. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterReset()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterReset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*slaveAddressSet) (i2c_ctrl_t *const p_ctrl, uint16_t const slave, i2c_addr_mode_t const addr_mode)" id="slaveAddressSet"><description>
<![CDATA[<form><p>Sets address of the slave device without reconfiguring the bus. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterSlaveAddressSet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterSlaveAddressSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_master_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">slave_address</span> :   Address of the slave device. </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Addressing mode. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version information and stores it in the provided version struct. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterVersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SIIC_MasterVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.i2c_on_sci_i2c.open" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.i2c_on_sci_i2c.close" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.i2c_on_sci_i2c.read" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${restart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.i2c_on_sci_i2c.write" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${restart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.i2c_on_sci_i2c.reset" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call slaveAddressSet()" id="module.driver.i2c_on_sci_i2c.slaveAddressSet" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="slaveAddressSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;slaveAddressSet(${instance}.p_ctrl, ${slave}, ${addr_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.i2c_on_sci_i2c.versionGet" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.i2c_on_sci_i2c.callback_def.0" version="1"><moduleRef id="module.driver.i2c_on_sci_i2c" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.i2c.p_callback)}(i2c_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.i2c_on_riic_slave" /><description>
<![CDATA[<form><p><span color="header" font="header">I2C Slave HAL Module Introduction</span></p><p>The I2C Slave HAL Module provides a high-level API for I2C slave applications and uses the RIIC peripheral on the Synergy MCU. Callbacks are provided to signal read/write request received from master and transfer completion events.</p><p><b>I2C Slave HAL Module Features</b></p><li bindent="0" vspace="false">Support for I2C Slave operations</li><li bindent="0" vspace="false">Support transactions with a I2C master device</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transmit Request (notifies when a write operation is expected from slave)</li><li bindent="20" vspace="false">Receive Request (notifies when a read operation is expected from slave)</li><li bindent="20" vspace="false">Transmit more request (notifies when master requests more data than configured in slave write operation. Also provides number of bytes transmitted)</li><li bindent="20" vspace="false">Receive more request (notifies when master tries to write more data than configured in slave read operation. Also provides number of bytes received)</li><li bindent="20" vspace="false">Transmit complete (provides number of bytes transmitted)</li><li bindent="20" vspace="false">Receive complete (provides number of bytes received)</li><p><b>RIIC Slave Hardware support details</b></p><p>RIIC Slave driver supported features:</p><p>Legend:</p><p><span color="header" font="header">I2C Slave HAL Module Features</span></p><li bindent="0" vspace="false">Support for I2C Slave operations</li><li bindent="0" vspace="false">Support transactions with a I2C master device</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="0" vspace="false">Callback support</li><li bindent="20" vspace="false">Transmit Request (notifies when a write operation is expected from slave)</li><li bindent="20" vspace="false">Receive Request (notifies when a read operation is expected from slave)</li><li bindent="20" vspace="false">Transmit more request (notifies when master requests more data than configured in slave write operation. Also provides number of bytes transmitted)</li><li bindent="20" vspace="false">Receive more request (notifies when master tries to write more data than configured in slave read operation. Also provides number of bytes received)</li><li bindent="20" vspace="false">Transmit complete (provides number of bytes transmitted)</li><li bindent="20" vspace="false">Receive complete (provides number of bytes received)</li></form>]]>
</description><function display="ssp_err_t (*open) (i2c_ctrl_t *const p_ctrl, i2c_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Opens the I2C driver and initializes the hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_SlaveOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements are set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (i2c_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the driver and releases the I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_SlaveClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_slave_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*masterWriteSlaveRead) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes)" id="masterWriteSlaveRead"><description>
<![CDATA[<form><p>Performs a read operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterWriteSlaveRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_slave_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to the location to store read data. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*masterReadSlaveWrite) (i2c_ctrl_t *const p_ctrl, uint8_t *const p_src, uint32_t const bytes)" id="masterReadSlaveWrite"><description>
<![CDATA[<form><p>Performs a write operation on an I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_MasterReadSlaveWrite()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">i2c_api_slave_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to the location to get write data from. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version information and stores it in the provided version struct. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RIIC_SlaveVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.i2c_on_riic_slave.open" version="1"><moduleRef id="module.driver.i2c_on_riic_slave"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.i2c_on_riic_slave.close" version="1"><moduleRef id="module.driver.i2c_on_riic_slave"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call masterWriteSlaveRead()" id="module.driver.i2c_on_riic_slave.masterWriteSlaveRead" version="1"><moduleRef id="module.driver.i2c_on_riic_slave"><function id="masterWriteSlaveRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;masterWriteSlaveRead(${instance}.p_ctrl, ${p_dest}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call masterReadSlaveWrite()" id="module.driver.i2c_on_riic_slave.masterReadSlaveWrite" version="1"><moduleRef id="module.driver.i2c_on_riic_slave"><function id="masterReadSlaveWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;masterReadSlaveWrite(${instance}.p_ctrl, ${p_src}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.i2c_on_riic_slave.versionGet" version="1"><moduleRef id="module.driver.i2c_on_riic_slave"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2c.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.i2c_on_riic_slave.callback_def.0" version="1"><moduleRef id="module.driver.i2c_on_riic_slave" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.i2c.p_callback)}(i2c_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.i2s_on_ssi" /><description>
<![CDATA[<form><p><span color="header" font="header">I2S HAL Module Introduction</span></p><p>The I2S HAL module provides a high-level API for the standard I2S audio serial communication protocol used to send or receive uncompressed audio data in master/slave mode.</p><p><b>I2S HAL Module Features</b></p><p>The I2S HAL module used with the SSI peripheral in I2S master/slave mode supports the following features (in addition to the standard I2S protocol):</p><li bindent="0" vspace="false">Full-duplex I2S communication (SSI channel 0 only)</li><li bindent="0" vspace="false">Interrupt driven data transmission and reception</li><li bindent="0" vspace="false">Integration with the DTC transfer module</li><li bindent="0" vspace="false">A user-defined callback created to respond to the need for additional data</li><p><b>I2S Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for I2S:</p><p>Legend:</p><p><span color="header" font="header">I2S HAL Module Features</span></p><p>The I2S HAL module used with the SSI peripheral in I2S master/slave mode supports the following features (in addition to the standard I2S protocol):</p><li bindent="0" vspace="false">Full-duplex I2S communication (SSI channel 0 only)</li><li bindent="0" vspace="false">Interrupt driven data transmission and reception</li><li bindent="0" vspace="false">Integration with the DTC transfer module</li><li bindent="0" vspace="false">A user-defined callback created to respond to the need for additional data</li></form>]]>
</description><function display="ssp_err_t (*open) (i2s_ctrl_t *const p_ctrl, i2s_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Open()</span></li><p><b>Precondition</b></p><p>Peripheral clocks and any required output pins should be configured prior to calling this function. </p><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">i2s_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (i2s_ctrl_t *const p_ctrl, i2s_dir_t const dir)" id="stop"><description>
<![CDATA[<form><p>Stop communication. Transmission is stopped when callback is called with I2S_EVENT_IDLE. Reception is stopped when callback is called with I2S_EVENT_RX_EMPTY. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">dir</span> :   Direction of communication to stop. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*mute) (i2s_ctrl_t *const p_ctrl, i2s_mute_t const mute_enable)" id="mute"><description>
<![CDATA[<form><p>Enable or disable mute. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Mute()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">mute_enable</span> :   Whether to enable or disable mute. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (i2s_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint16_t const bytes)" id="write"><description>
<![CDATA[<form><p>Write I2S data. All transmit data is queued when callback is called with I2S_EVENT_TX_EMPTY. Transmission is complete when callback is called with I2S_EVENT_IDLE. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Buffer of PCM samples. Must be 4 byte aligned. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes in the buffer. Recommended requesting a multiple of 8 bytes. If not a multiple of 8, padding 0s will be added to transmission to make it a multiple of 8. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (i2s_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint16_t const bytes)" id="read"><description>
<![CDATA[<form><p>Read I2S data. Reception is complete when callback is called with I2S_EVENT_RX_EMPTY. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Buffer to store PCM samples. Must be 4 byte aligned. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes in the buffer. Recommended requesting a multiple of 8 bytes. If not a multiple of 8, receive will stop at the multiple of 8 below requested bytes. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeRead) (i2s_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint8_t *const p_dest, uint16_t const bytes)" id="writeRead"><description>
<![CDATA[<form><p>Simultaneously write and read I2S data. Transmission and reception are complete when callback is called with I2S_EVENT_IDLE. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_WriteRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Buffer of PCM samples. Must be 4 byte aligned. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Buffer to store PCM samples. Must be 4 byte aligned. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes in the buffers. Recommended requesting a multiple of 8 bytes. If not a multiple of 8, padding 0s will be added to transmission to make it a multiple of 8, and receive will stop at the multiple of 8 below requested bytes. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (i2s_ctrl_t *const p_ctrl, i2s_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get instance specific information and store it in provided pointer p_info. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this instance. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (i2s_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allows driver to be reconfigured and may reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">i2s_api_t::open</span> call for this instance. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SSI_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.i2s_on_ssi.open" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.i2s_on_ssi.stop" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;stop(${instance}.p_ctrl, ${dir});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call mute()" id="module.driver.i2s_on_ssi.mute" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="mute" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;mute(${instance}.p_ctrl, ${mute_enable});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.i2s_on_ssi.write" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.i2s_on_ssi.read" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeRead()" id="module.driver.i2s_on_ssi.writeRead" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="writeRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;writeRead(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.i2s_on_ssi.infoGet" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.i2s_on_ssi.close" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.i2s_on_ssi.versionGet" version="1"><moduleRef id="module.driver.i2s_on_ssi"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.i2s.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.i2s_on_ssi.callback_def.0" version="1"><moduleRef id="module.driver.i2s_on_ssi" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.sdmmc.p_callback)}(i2s_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.spi_on_rspi" /><description>
<![CDATA[<form><p><span color="header" font="header">RSPI HAL Module Introduction</span></p><p>The RSPI HAL module provides a high-level API for serial communication using the SPI protocol. The module supports the SPI (formerly known as RSPI) peripheral available on the Synergy microcontroller hardware. The RSPI HAL module supports standard SPI master and Slave mode communications functions. Callbacks are provided for transfer events. The RSPI HAL module is enabled with data transfer support by incorporating the data transfer controller module of the MCU; this performs SPI transfers through the DTC without requiring interrupt processing for each frame.</p><p><b>RSPI HAL Module Features</b></p><li bindent="0" vspace="false">Initialization of the driver</li><li bindent="0" vspace="false">SPI transfer functions:</li><li bindent="20" vspace="false"> Allows serial communication through the SPI operation using the four-wire method</li><li bindent="20" vspace="false">Capable of serial communication in master and slave modes</li><li bindent="20" vspace="false">Switching the polarity of the serial transfer clock</li><li bindent="20" vspace="false">Switching the phase of the serial transfer clock</li><li bindent="0" vspace="false">Data Format</li><li bindent="20" vspace="false">MSB-first/LSB-first selectable</li><li bindent="20" vspace="false">Transfer bit length is selectable as 8, 16 and 32 bits</li><li bindent="20" vspace="false">16-bit and 32-bit byte swapping for both received and transmitted data register</li><li bindent="0" vspace="false">Error Detection</li><li bindent="20" vspace="false">Mode fault detection</li><li bindent="20" vspace="false">Overrun error detection</li><li bindent="20" vspace="false">Parity error detection</li><li bindent="0" vspace="false">SSL control functions</li><li bindent="20" vspace="false">External hardware slave select can be used in master mode</li><li bindent="0" vspace="false">Interrupts</li><li bindent="20" vspace="false">RSPI receive interrupt (receive buffer full)</li><li bindent="20" vspace="false">RSPI transmit interrupt (transmit buffer empty)</li><li bindent="20" vspace="false">RSPI error interrupt (mode fault, overrun and parity error)</li><li bindent="0" vspace="false">Delays</li><li bindent="20" vspace="false">Add SPI clock delay</li><li bindent="20" vspace="false">Add slave select negation delay</li><li bindent="20" vspace="false">Add next-access delay</li><p><b>RSPI Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the RSPI.</p><p>Legend:</p><p><span color="header" font="header">RSPI HAL Module Features</span></p><li bindent="0" vspace="false">Initialization of the driver</li><li bindent="0" vspace="false">SPI transfer functions:</li><li bindent="20" vspace="false"> Allows serial communication through the SPI operation using the four-wire method</li><li bindent="20" vspace="false">Capable of serial communication in master and slave modes</li><li bindent="20" vspace="false">Switching the polarity of the serial transfer clock</li><li bindent="20" vspace="false">Switching the phase of the serial transfer clock</li><li bindent="0" vspace="false">Data Format</li><li bindent="20" vspace="false">MSB-first/LSB-first selectable</li><li bindent="20" vspace="false">Transfer bit length is selectable as 8, 16 and 32 bits</li><li bindent="20" vspace="false">16-bit and 32-bit byte swapping for both received and transmitted data register</li><li bindent="0" vspace="false">Error Detection</li><li bindent="20" vspace="false">Mode fault detection</li><li bindent="20" vspace="false">Overrun error detection</li><li bindent="20" vspace="false">Parity error detection</li><li bindent="0" vspace="false">SSL control functions</li><li bindent="20" vspace="false">External hardware slave select can be used in master mode</li><li bindent="0" vspace="false">Interrupts</li><li bindent="20" vspace="false">RSPI receive interrupt (receive buffer full)</li><li bindent="20" vspace="false">RSPI transmit interrupt (transmit buffer empty)</li><li bindent="20" vspace="false">RSPI error interrupt (mode fault, overrun and parity error)</li><li bindent="0" vspace="false">Delays</li><li bindent="20" vspace="false">Add SPI clock delay</li><li bindent="20" vspace="false">Add slave select negation delay</li><li bindent="20" vspace="false">Add next-access delay</li></form>]]>
</description><function display="ssp_err_t (*open) (spi_ctrl_t *p_ctrl, spi_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize a channel for SPI communication mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SPI configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (spi_ctrl_t *const p_ctrl, void const *p_dest, uint32_t const length, spi_bit_width_t const bit_width)" id="read"><description>
<![CDATA[<form><p>Receive data from an SPI device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (spi_ctrl_t *const p_ctrl, void const *p_src, uint32_t const length, spi_bit_width_t const bit_width)" id="write"><description>
<![CDATA[<form><p>Transmit data to an SPI device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeRead) (spi_ctrl_t *const p_ctrl, void const *p_src, void const *p_dest, uint32_t const length, spi_bit_width_t const bit_width)" id="writeRead"><description>
<![CDATA[<form><p>Simultaneously transmit data to an SPI device while receiving data from a SPI device (full duplex). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_WriteRead()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_WriteRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (spi_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Remove power to the SPI channel designated by the handle and disable the associated interrupts. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the version information of the underlying driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.spi_on_rspi.open" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.spi_on_rspi.read" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.spi_on_rspi.write" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeRead()" id="module.driver.spi_on_rspi.writeRead" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="writeRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;writeRead(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.spi_on_rspi.close" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.spi_on_rspi.versionGet" version="1"><moduleRef id="module.driver.spi_on_rspi"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.spi_on_rspi.callback_def.0" version="1"><moduleRef id="module.driver.spi_on_rspi" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.spi.p_callback)}(spi_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.spi_on_sci_spi" /><description>
<![CDATA[<form><p><span color="header" font="header">SCI SPI HAL Module Introduction</span></p><p>The SCI SPI HAL module provides a high-level API for master/slave-based industry standard SPI serial communications and configures and uses the SCI (Serial Communications Interface) peripheral on a Synergy MCU. A user-defined callback can be created to signal when the SPI has transmitted data, aborted a data transfer or detected an error condition.</p><p>The SCI SPI HAL module is enabled with a data transfer function support by incorporating the Data Transfer Controller module of the MCU. This performs SPI transfers through the DTC without intervention of the CPU.</p><p><b>SCI SPI HAL Module Features</b></p><p>The SCI SPI HAL module supports the configuration and control of the SPI functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Driver initialization</li><li bindent="0" vspace="false">Serial communication through SPI operation using 8-bit data transfers</li><li bindent="0" vspace="false">Configurable among four clock phase and clock polarity settings</li><li bindent="0" vspace="false">Support for callbacks. The callback functions are called with the following events:</li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transfer complete</li><li bindent="20" vspace="false">Over run error</li><li bindent="20" vspace="false">SPI communication in master and slave mode.</li><p><b>SCI SPI Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the SCI_SPI:</p><p>Legend:</p><p><span color="header" font="header">SCI SPI HAL Module Features</span></p><p>The SCI SPI HAL module supports the configuration and control of the SPI functions on the Synergy MCU. Key features include the following:</p><li bindent="0" vspace="false">Driver initialization</li><li bindent="0" vspace="false">Serial communication through SPI operation using 8-bit data transfers</li><li bindent="0" vspace="false">Configurable among four clock phase and clock polarity settings</li><li bindent="0" vspace="false">Support for callbacks. The callback functions are called with the following events:</li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transfer complete</li><li bindent="20" vspace="false">Over run error</li><li bindent="20" vspace="false">SPI communication in master and slave mode.</li></form>]]>
</description><function display="ssp_err_t (*open) (spi_ctrl_t *p_ctrl, spi_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize a channel for SPI communication mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SPI configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (spi_ctrl_t *const p_ctrl, void const *p_dest, uint32_t const length, spi_bit_width_t const bit_width)" id="read"><description>
<![CDATA[<form><p>Receive data from an SPI device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (spi_ctrl_t *const p_ctrl, void const *p_src, uint32_t const length, spi_bit_width_t const bit_width)" id="write"><description>
<![CDATA[<form><p>Transmit data to an SPI device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeRead) (spi_ctrl_t *const p_ctrl, void const *p_src, void const *p_dest, uint32_t const length, spi_bit_width_t const bit_width)" id="writeRead"><description>
<![CDATA[<form><p>Simultaneously transmit data to an SPI device while receiving data from a SPI device (full duplex). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_WriteRead()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_WriteRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Data bit width to be transferred. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (spi_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Remove power to the SPI channel designated by the handle and disable the associated interrupts. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the version information of the underlying driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_SCI_SPI_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.spi_on_sci_spi.open" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.spi_on_sci_spi.read" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.spi_on_sci_spi.write" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeRead()" id="module.driver.spi_on_sci_spi.writeRead" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="writeRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;writeRead(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${length}, ${bit_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.spi_on_sci_spi.close" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.spi_on_sci_spi.versionGet" version="1"><moduleRef id="module.driver.spi_on_sci_spi"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.spi.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.spi_on_sci_spi.callback_def.0" version="1"><moduleRef id="module.driver.spi_on_sci_spi" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.spi.p_callback)}(spi_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.uart_on_sci_uart" /><description>
<![CDATA[<form><p><span color="header" font="header">UART HAL Module Introduction</span></p><p>The UART HAL Module provides a high-level API for industry standard UART serial communications applications and uses the SCI peripherals on the Synergy MCU. A user-defined callback can be created to manage hardware-handshake and data operation, if needed.</p><p><b>UART HAL Module Features</b></p><p>The UART HAL module supports the standard UART protocol. The UART HAL module used in concert with the SCI peripheral in UART mode (UART on SCI) supports the following features (in addition to the standard UART protocol):</p><li bindent="0" vspace="false">Full-duplex UART communication</li><li bindent="0" vspace="false">Simultaneous communication with multiple channels</li><li bindent="0" vspace="false">Interrupt-driven data transmission and reception</li><li bindent="0" vspace="false">Invoking the user-callback function with an event code in the argument</li><li bindent="0" vspace="false">Baud-rate change at run-time</li><li bindent="0" vspace="false">Hardware resource locking during UART transaction</li><li bindent="0" vspace="false">CTS/RTS hardware flow control (with an associated IOPORT pin and supported by user-defined callback function)</li><li bindent="0" vspace="false">Integration with the DTC transfer module</li><li bindent="0" vspace="false">Abort in-progress read/write operations</li><p><b>UART Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the UART (SCI).</p><p>Legend:</p><p><span color="header" font="header">UART HAL Module Features</span></p><p>The UART HAL module supports the standard UART protocol. The UART HAL module used in concert with the SCI peripheral in UART mode (UART on SCI) supports the following features (in addition to the standard UART protocol):</p><li bindent="0" vspace="false">Full-duplex UART communication</li><li bindent="0" vspace="false">Simultaneous communication with multiple channels</li><li bindent="0" vspace="false">Interrupt-driven data transmission and reception</li><li bindent="0" vspace="false">Invoking the user-callback function with an event code in the argument</li><li bindent="0" vspace="false">Baud-rate change at run-time</li><li bindent="0" vspace="false">Hardware resource locking during UART transaction</li><li bindent="0" vspace="false">CTS/RTS hardware flow control (with an associated IOPORT pin and supported by user-defined callback function)</li><li bindent="0" vspace="false">Integration with the DTC transfer module</li><li bindent="0" vspace="false">Abort in-progress read/write operations</li></form>]]>
</description><function display="ssp_err_t (*open) (uart_ctrl_t *const p_ctrl, uart_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open UART device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">uart_cfg_t</span> :   Pointer to UART configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (uart_ctrl_t *const p_ctrl, uint8_t const *const p_dest, uint32_t const bytes)" id="read"><description>
<![CDATA[<form><p>Read from UART device. If a transfer instance is used for reception, the received bytes are stored directly in the read input buffer. When a transfer is complete, the callback is called with event UART_EVENT_RX_COMPLETE. Bytes received outside an active transfer are received in the callback function with event UART_EVENT_RX_CHAR. The maximum transfer size is reported by <span font="code">infoGet()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data from. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length. Only applicable if <span font="code">uart_cfg_t::p_transfer_rx</span> is not NULL. Otherwise all read bytes will be provided through the callback set in <span font="code">uart_cfg_t::p_callback</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (uart_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const bytes)" id="write"><description>
<![CDATA[<form><p>Write to UART device. The write buffer is used until write is complete. Do not overwrite write buffer contents until the write is finished. When the write is complete (all bytes are fully transmitted on the wire), the callback called with event UART_EVENT_TX_COMPLETE. The maximum transfer size is reported by <span font="code">infoGet()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartWrite()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address to write data to. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Write data length. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*baudSet) (uart_ctrl_t *const p_ctrl, uint32_t const baudrate)" id="baudSet"><description>
<![CDATA[<form><p>Change baud rate. </p><p><b>Warning</b></p><p>Calling this API aborts any in-progress transmission and disables reception until the new baud settings have been applied.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartBaudSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">baudrate</span> :   Baud rate in bps. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (uart_ctrl_t *const p_ctrl, uart_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get the driver specific information. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartInfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">baudrate</span> :   Baud rate in bps. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (uart_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close UART device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*communicationAbort) (uart_ctrl_t *const p_ctrl, uart_dir_t communication_to_abort)" id="communicationAbort"><description>
<![CDATA[<form><p>Abort ongoing transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartAbort()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">communication_to_abort</span> :   Type of abort request. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.uart_on_sci_uart.open" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.uart_on_sci_uart.read" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.uart_on_sci_uart.write" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call baudSet()" id="module.driver.uart_on_sci_uart.baudSet" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="baudSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;baudSet(${instance}.p_ctrl, ${baudrate});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.uart_on_sci_uart.infoGet" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.uart_on_sci_uart.close" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.uart_on_sci_uart.versionGet" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call communicationAbort()" id="module.driver.uart_on_sci_uart.communicationAbort" version="1"><moduleRef id="module.driver.uart_on_sci_uart"><function id="communicationAbort" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.uart.name)}.p_api-&gt;communicationAbort(${instance}.p_ctrl, ${communication_to_abort});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.uart_on_sci_uart.callback_def.0" version="1"><moduleRef id="module.driver.uart_on_sci_uart" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.uart.p_callback)}(uart_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.display_on_glcd" /><description>
<![CDATA[<form><p><span color="header" font="header">GLCDC HAL Module Introduction</span></p><p>The Graphics LCD Controller (GLCDC) HAL module provides a high-level API for graphics display applications and uses the Graphics LCD Driver peripheral on the Synergy MCU. A user-defined callback can be created to handle frame buffer switching and underflow detection.</p><p><b>GLCDC HAL Module Features</b></p><p>The GLCDC HAL supports the following features:</p><li bindent="0" vspace="false">Supports LCD panels with RGB interface (up to 24 bits) and sync signals (HSYNC, VSYNC, and Data Enable (optional))</li><li bindent="0" vspace="false">Supports various color formats for input graphics planes (RGB888, ARGB888, RGB565, ARGB1555, ARGB4444, CLUT8, CLUT4, CLUT1)</li><li bindent="0" vspace="false">Supports the Color Look-Up Table (CLUT) usage for input graphics planes with 512 words (32 bits/word)</li><li bindent="0" vspace="false">Supports various color formats for output (RGB888, RGB666, RGB565, Serial RGB)</li><li bindent="0" vspace="false">Can input two graphics planes on top of the background plane and blend them on the screen</li><li bindent="0" vspace="false">Generates a dot clock to the panel. The clock source is selectable from internal or external (LCD_EXTCLK)</li><li bindent="0" vspace="false">Supports brightness adjustment, contrast adjustment, and gamma correction</li><li bindent="0" vspace="false">Supports GLCDC interrupts to handle frame buffer switching or underflow detection</li><p><b>GLCDC Hardware support details</b></p><p>The following hardware features are, or are not, supported by the SSP for the GLCDC:</p><p>Legend:</p><p><span color="header" font="header">GLCDC HAL Module Features</span></p><p>The GLCDC HAL supports the following features:</p><li bindent="0" vspace="false">Supports LCD panels with RGB interface (up to 24 bits) and sync signals (HSYNC, VSYNC, and Data Enable (optional))</li><li bindent="0" vspace="false">Supports various color formats for input graphics planes (RGB888, ARGB888, RGB565, ARGB1555, ARGB4444, CLUT8, CLUT4, CLUT1)</li><li bindent="0" vspace="false">Supports the Color Look-Up Table (CLUT) usage for input graphics planes with 512 words (32 bits/word)</li><li bindent="0" vspace="false">Supports various color formats for output (RGB888, RGB666, RGB565, Serial RGB)</li><li bindent="0" vspace="false">Can input two graphics planes on top of the background plane and blend them on the screen</li><li bindent="0" vspace="false">Generates a dot clock to the panel. The clock source is selectable from internal or external (LCD_EXTCLK)</li><li bindent="0" vspace="false">Supports brightness adjustment, contrast adjustment, and gamma correction</li><li bindent="0" vspace="false">Supports GLCDC interrupts to handle frame buffer switching or underflow detection</li></form>]]>
</description><function display="ssp_err_t (*open) (display_ctrl_t *const p_ctrl, display_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open display device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to display configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (display_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close display device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (display_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Display start. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_Start()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (display_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Display stop. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_Stop()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*layerChange) (display_ctrl_t const *const p_ctrl, display_runtime_cfg_t const *const p_cfg, display_frame_layer_t frame)" id="layerChange"><description>
<![CDATA[<form><p>Change layer parameters at runtime. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_LayerChange()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to run-time layer configuration structure. </li><li bindent="0" vspace="false"><span font="code">frame</span> :   Number of graphic frames. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*correction) (display_ctrl_t const *const p_ctrl, display_correction_t const *const p_param)" id="correction"><description>
<![CDATA[<form><p>Color correction. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_ColorCorrection()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">param</span> :   Pointer to color correction configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clut) (display_ctrl_t const *const p_ctrl, display_clut_cfg_t const *const p_clut_cfg, display_frame_layer_t frame)" id="clut"><description>
<![CDATA[<form><p>Set CLUT for display device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_ClutUpdate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">p_clut_cfg</span> :   Pointer to CLUT configuration structure. </li><li bindent="0" vspace="false"><span font="code">frame</span> :   Number of frame buffer corresponding to the CLUT. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (display_ctrl_t const *const p_ctrl, display_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Get status for display device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_StatusGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">status</span> :   Pointer to display interface status structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GLCD_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.display_on_glcd.open" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.display_on_glcd.close" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.display_on_glcd.start" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.display_on_glcd.stop" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call layerChange()" id="module.driver.display_on_glcd.layerChange" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="layerChange" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;layerChange(${instance}.p_ctrl, ${instance}.p_cfg, ${frame});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call correction()" id="module.driver.display_on_glcd.correction" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="correction" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;correction(${instance}.p_ctrl, ${p_param});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clut()" id="module.driver.display_on_glcd.clut" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="clut" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;clut(${instance}.p_ctrl, ${p_clut_cfg}, ${frame});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.display_on_glcd.statusGet" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.display_on_glcd.versionGet" version="1"><moduleRef id="module.driver.display_on_glcd"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.display.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.display_on_glcd.callback_def.0" version="1"><moduleRef id="module.driver.display_on_glcd" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.display.p_callback)}(display_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.jpeg_decode" /><description>
<![CDATA[<form><p><span color="header" font="header">JPEG Decode HAL Module Introduction</span></p><p>The JPEG Decode HAL module provides high-level APIs for JPEG Decode image processing. The JPEG Decode HAL module uses the Synergy MCU JPEG Codec peripheral. A user callback function is available to inform the application program of key processing events.</p><p><b>JPEG Decode HAL Module Features</b></p><li bindent="0" vspace="false">Supports JPEG decompression.</li><li bindent="0" vspace="false">Supports polling mode that allows an application to wait for JPEG Decoder to complete.</li><li bindent="0" vspace="false">Supports interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical subsample values, horizontal stride, decoded pixel format, input and output data format, and color space.</li><li bindent="0" vspace="false">Obtains the size of the image prior to decoding it.</li><li bindent="0" vspace="false">Supports putting coded data in an input buffer and an output buffer to store the decoded image frame.</li><li bindent="0" vspace="false">Supports streaming coded data into JPEG Decoder module. This feature allows an application to read coded JPEG image from a file or from network without buffering the entire image.</li><li bindent="0" vspace="false">Configures the number of image lines to decode. This feature enables the application to process the decoded image on the fly without buffering the entire frame.</li><li bindent="0" vspace="false">Supports the input decoded format YCbCr444, YCbCr422, YCbCr420, YCbCr411.</li><li bindent="0" vspace="false">Supports the output format ARGB8888, RGB565.</li><li bindent="0" vspace="false">Returns error when the JPEG image's size, height and width do not meet the requirements.</li><p><b>JPEG Decode Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for JPEG.</p><p>Legend:</p><p><span color="header" font="header">JPEG Decode HAL Module Features</span></p><li bindent="0" vspace="false">Supports JPEG decompression.</li><li bindent="0" vspace="false">Supports polling mode that allows an application to wait for JPEG Decoder to complete.</li><li bindent="0" vspace="false">Supports interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical subsample values, horizontal stride, decoded pixel format, input and output data format, and color space.</li><li bindent="0" vspace="false">Obtains the size of the image prior to decoding it.</li><li bindent="0" vspace="false">Supports putting coded data in an input buffer and an output buffer to store the decoded image frame.</li><li bindent="0" vspace="false">Supports streaming coded data into JPEG Decoder module. This feature allows an application to read coded JPEG image from a file or from network without buffering the entire image.</li><li bindent="0" vspace="false">Configures the number of image lines to decode. This feature enables the application to process the decoded image on the fly without buffering the entire frame.</li><li bindent="0" vspace="false">Supports the input decoded format YCbCr444, YCbCr422, YCbCr420, YCbCr411.</li><li bindent="0" vspace="false">Supports the output format ARGB8888, RGB565.</li><li bindent="0" vspace="false">Returns error when the JPEG image's size, height and width do not meet the requirements.</li></form>]]>
</description><function display="ssp_err_t (*open) (jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_Open()</span></li><p><b>Precondition</b></p><p>none</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*outputBufferSet) (jpeg_decode_ctrl_t *const p_ctrl, void *p_buffer, uint32_t buffer_size)" id="outputBufferSet"><description>
<![CDATA[<form><p>Assign output buffer to JPEG codec for storing output data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_OutputBufferSet()</span></li><p><b>Precondition</b></p><p>The JPEG codec module must have been opened properly. </p><p><b>Note</b></p><p>The buffer starting address must be 8-byte aligned. For the decoding process, the HLD driver automatically computes the number of lines of the image to decoded so the output data fits into the given space. If the supplied output buffer is not able to hold the entire frame, the application should call the Output Full Callback function so it can be notified when additional buffer space is needed. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the output buffer space </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the output buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*horizontalStrideSet) (jpeg_decode_ctrl_t *const p_ctrl, uint32_t horizontal_stride)" id="horizontalStrideSet"><description>
<![CDATA[<form><p>Configure the horizontal stride value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_HorizontalStrideSet()</span></li><p><b>Precondition</b></p><p>The JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">horizontal_stride</span> :   Horizontal stride value to be used for the decoded image data. </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the output buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*imageSubsampleSet) (jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_subsample_t horizontal_subsample, jpeg_decode_subsample_t vertical_subsample)" id="imageSubsampleSet"><description>
<![CDATA[<form><p>Configure the horizontal and vertical subsample settings. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_ImageSubsampleSet()</span></li><p><b>Precondition</b></p><p>The JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">horizontal_subsample</span> :   Horizontal subsample value </li><li bindent="0" vspace="false"><span font="code">vertical_subsample</span> :   Vertical subsample value </li><p /></form>]]>
</description></function><function display="ssp_err_t (*inputBufferSet) (jpeg_decode_ctrl_t *const p_ctrl, void *p_buffer, uint32_t buffer_size)" id="inputBufferSet"><description>
<![CDATA[<form><p>Assign input data buffer to JPEG codec. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_InputBufferSet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Note</b></p><p>The buffer starting address must be 8-byte aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the input buffer space </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the input buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linesDecodedGet) (jpeg_decode_ctrl_t *const p_ctrl, uint32_t *const p_lines)" id="linesDecodedGet"><description>
<![CDATA[<form><p>Return the number of lines decoded into the output buffer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_LinesDecodedGet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_lines</span> :   Number of lines decoded </li><p /></form>]]>
</description></function><function display="ssp_err_t (*imageSizeGet) (jpeg_decode_ctrl_t *const p_ctrl, uint16_t *p_horizontal_size, uint16_t *p_vertical_size)" id="imageSizeGet"><description>
<![CDATA[<form><p>Retrieve image size during decoding operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_ImageSizeGet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Note</b></p><p>If the encoding or the decoding operation is finished without errors, the HLD driver automatically closes the device. In this case, application does not need to explicitly close the JPEG device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_horizontal_size</span> :   Image horizontal size, in number of pixels. </li><li bindent="0" vspace="false"><span font="code">p_vertical_size</span> :   Image vertical size, in number of pixels. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Retrieve current status of the JPEG codec module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_StatusGet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   JPEG module status </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (jpeg_decode_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Cancel an outstanding operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_Close()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Note</b></p><p>If the encoding or the decoding operation is finished without errors, the HLD driver automatically closes the device. In this case, application does not need to explicitly close the JPEG device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in jpeg_decode_api_t::Open call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pixelFormatGet) (jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_color_space_t *const p_color_space)" id="pixelFormatGet"><description>
<![CDATA[<form><p>Get the input pixel format. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Decode_PixelFormatGet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_decode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_color_space</span> :   JPEG input format. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.jpeg_decode.open" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call outputBufferSet()" id="module.driver.jpeg_decode.outputBufferSet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="outputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;outputBufferSet(${instance}.p_ctrl, ${p_buffer}, ${buffer_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call horizontalStrideSet()" id="module.driver.jpeg_decode.horizontalStrideSet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="horizontalStrideSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;horizontalStrideSet(${instance}.p_ctrl, ${horizontal_stride});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call imageSubsampleSet()" id="module.driver.jpeg_decode.imageSubsampleSet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="imageSubsampleSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;imageSubsampleSet(${instance}.p_ctrl, ${horizontal_subsample}, ${vertical_subsample});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call inputBufferSet()" id="module.driver.jpeg_decode.inputBufferSet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="inputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;inputBufferSet(${instance}.p_ctrl, ${p_buffer}, ${buffer_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linesDecodedGet()" id="module.driver.jpeg_decode.linesDecodedGet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="linesDecodedGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;linesDecodedGet(${instance}.p_ctrl, ${p_lines});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call imageSizeGet()" id="module.driver.jpeg_decode.imageSizeGet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="imageSizeGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;imageSizeGet(${instance}.p_ctrl, ${p_horizontal_size}, ${p_vertical_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.jpeg_decode.statusGet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.jpeg_decode.close" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.jpeg_decode.versionGet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pixelFormatGet()" id="module.driver.jpeg_decode.pixelFormatGet" version="1"><moduleRef id="module.driver.jpeg_decode"><function id="pixelFormatGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_decode.name)}.p_api-&gt;pixelFormatGet(${instance}.p_ctrl, ${p_color_space});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.jpeg_decode.callback_def.0" version="1"><moduleRef id="module.driver.jpeg_decode" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.jpeg_decode.p_callback)}(jpeg_decode_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.pdc_on_pdc" /><description>
<![CDATA[<form><p><span color="header" font="header">PDC HAL Module Introduction</span></p><p>The Parallel Data Capture Unit (PDC) HAL module provides a high-level API to capture images from a camera application and uses the PDC peripheral on the Synergy MCU. A user-defined callback can be created to inform the CPU when a capture has been completed.</p><p><b>PDC HAL Module Features</b></p><li bindent="0" vspace="false">Supports capture from a connected and configured camera.</li><li bindent="0" vspace="false">Supports a callback that informs the CPU when a capture is complete.</li><li bindent="0" vspace="false">Provides a pointer to the capture buffer.</li><li bindent="0" vspace="false">Provides an indication of the event triggering the callback.</li><p><b>PDC Hardware Support dDetails</b></p><p>The following hardware features are, or are not, supported by SSP for PDC:</p><p>Legend:</p><p><span color="header" font="header">PDC HAL Module Features</span></p><li bindent="0" vspace="false">Supports capture from a connected and configured camera.</li><li bindent="0" vspace="false">Supports a callback that informs the CPU when a capture is complete.</li><li bindent="0" vspace="false">Provides a pointer to the capture buffer.</li><li bindent="0" vspace="false">Provides an indication of the event triggering the callback.</li></form>]]>
</description><function display="ssp_err_t (*open) (pdc_ctrl_t *const p_ctrl, pdc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PDC_Open()</span></li><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">pdc_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (pdc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the driver and allows reconfiguration. May reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PDC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*captureStart) (pdc_ctrl_t *const p_ctrl, uint8_t *const p_buffer)" id="captureStart"><description>
<![CDATA[<form><p>Start a capture. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PDC_CaptureStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to store captured image data. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stateGet) (pdc_ctrl_t *const p_ctrl, pdc_state_t *p_state)" id="stateGet"><description>
<![CDATA[<form><p>Get the state of the VSYNC and HSYNC pins. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PDC_StateGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_state</span> :   Pointer to store state data. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PDC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.pdc_on_pdc.open" version="1"><moduleRef id="module.driver.pdc_on_pdc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.pdc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.pdc_on_pdc.close" version="1"><moduleRef id="module.driver.pdc_on_pdc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.pdc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call captureStart()" id="module.driver.pdc_on_pdc.captureStart" version="1"><moduleRef id="module.driver.pdc_on_pdc"><function id="captureStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.pdc.name)}.p_api-&gt;captureStart(${instance}.p_ctrl, ${p_buffer});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stateGet()" id="module.driver.pdc_on_pdc.stateGet" version="1"><moduleRef id="module.driver.pdc_on_pdc"><function id="stateGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.pdc.name)}.p_api-&gt;stateGet(${instance}.p_ctrl, ${p_state});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.pdc_on_pdc.versionGet" version="1"><moduleRef id="module.driver.pdc_on_pdc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.pdc.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.pdc_on_pdc.callback_def.0" version="1"><moduleRef id="module.driver.pdc_on_pdc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.pdc.p_callback)}(pdc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.slcdc_on_slcdc" /><description>
<![CDATA[<form><p><span color="header" font="header">SLCDC HAL Module Introduction</span></p><p>The Segment LCD HAL module provides a high-level API for Segment LCD applications and displays and modifies data on a Segment LCD. The Segment LCD HAL module uses the Segment LCD Controller module on a Synergy MCU.</p><p><b>SLCDC HAL Module Features</b></p><li bindent="0" vspace="false">Internal voltage-boosting for the LCD driver voltage generator: select the capacitor split method or the external resistance division.</li><li bindent="0" vspace="false">Display bias: select the 1/2 bias method, 1/3 bias method, or 1/4 bias method.</li><li bindent="0" vspace="false">Time slice of the display: select static, 2-time slice, 3-time slice, 4-time slice, or 8-time slice.</li><li bindent="0" vspace="false">Display waveform: select waveform A or waveform B.</li><li bindent="0" vspace="false">Display data area: select A-pattern, B-pattern, or blinking. You can switch the display data area.</li><li bindent="0" vspace="false">Use the RTC periodic interrupt (PRD) to generate a blinking display with A-pattern and B-pattern.</li><li bindent="0" vspace="false">Adjust the reference voltage which is generated when operating the voltage boost circuit in 16 steps (contrast adjustment.)</li><p><b>SLCDC Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the SLCD.</p><p>Legend:</p><p><span color="header" font="header">SLCDC HAL Module Features</span></p><li bindent="0" vspace="false">Internal voltage-boosting for the LCD driver voltage generator: select the capacitor split method or the external resistance division.</li><li bindent="0" vspace="false">Display bias: select the 1/2 bias method, 1/3 bias method, or 1/4 bias method.</li><li bindent="0" vspace="false">Time slice of the display: select static, 2-time slice, 3-time slice, 4-time slice, or 8-time slice.</li><li bindent="0" vspace="false">Display waveform: select waveform A or waveform B.</li><li bindent="0" vspace="false">Display data area: select A-pattern, B-pattern, or blinking. You can switch the display data area.</li><li bindent="0" vspace="false">Use the RTC periodic interrupt (PRD) to generate a blinking display with A-pattern and B-pattern.</li><li bindent="0" vspace="false">Adjust the reference voltage which is generated when operating the voltage boost circuit in 16 steps (contrast adjustment.)</li></form>]]>
</description><function display="ssp_err_t (*open) (slcdc_ctrl_t *const p_ctrl, slcdc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SLCD device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to display configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (slcdc_ctrl_t *const p_ctrl, slcdc_size_t const start_segment, slcdc_size_t const *const p_data, slcdc_size_t const segment_count)" id="write"><description>
<![CDATA[<form><p>Write data to SLCD segment. Specifies the initial display data. Except for 8-time slice, store values in the lower 4 bits when writing to the A-pattern area, and in the upper 4 bits when writing to the B-pattern area. The display data is stored in the display data register. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Write()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">start_segment</span> :   Specify the start segment number to be written. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   pointer to the display data to be written to the specified segments </li><li bindent="0" vspace="false"><span font="code">segment_count</span> :   Number of segments to be written </li><p /></form>]]>
</description></function><function display="ssp_err_t (*modify) (slcdc_ctrl_t *const p_ctrl, slcdc_size_t const segment, slcdc_size_t const data_mask, slcdc_size_t const data)" id="modify"><description>
<![CDATA[<form><p>Rewrite data in the SLCD segment. Rewrites the LCD display data in 1-bit units. If a bit is not specified for rewriting, the value stored in the bit is held as it is. Specifies the data to rewrite </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Modify()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">seg</span> :   Specify the segment to be written. </li><li bindent="0" vspace="false"><span font="code">data_mask</span> :   Mask the data being displayed. Set 0 to the bit to be rewritten and set 1 to the other bits. Multiple bits can be rewritten. Setting value of data_mask, Bit 3 - 0xf7 Bit 2 - 0xfb Bit 1 - 0xfd Bit 0 - 0xfe </li><li bindent="0" vspace="false"><span font="code">data</span> :   Specify display data to rewrite to the specified segment. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (slcdc_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Enable display on the SLCD. Displays the specified data on the LCD. Before that data should be written to the segments. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Start()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (slcdc_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Disable display on the SLCD. Stops displaying data on the SLCD. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Stop()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*contrastIncrease) (slcdc_ctrl_t *const p_ctrl)" id="contrastIncrease"><description>
<![CDATA[<form><p>Increase the display contrast. Increase by 1 unit. This function can be selected when the internal voltage boosting method is used for the drive voltage generator </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_ContrastIncrease()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*contrastDecrease) (slcdc_ctrl_t *const p_ctrl)" id="contrastDecrease"><description>
<![CDATA[<form><p>Decrease the display contrast. Decrease by 1 unit. This function can be selected when the internal voltage boosting method is used for the drive voltage generator </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_ContrastDecrease()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setdisplayArea) (slcdc_ctrl_t *const p_ctrl, slcdc_display_area_t const display_area)" id="setdisplayArea"><description>
<![CDATA[<form><p>Set LCD display area. This function sets a specified display area, A-pattern or B-pattern. This function can be used to set blink on where A-pattern and B-pattern area data will be alternately displayed.</p><p>When using blinking, the RTC is required to operate before this function is executed. To configure the RTC, follow the steps below. 1) Open RTC 2) Set Periodic interrupt request, 1/2 second 3) Start RTC counter 4) Enable IRQ, RTC_EVENT_PERIODIC_IRQ Refer to the User’s Manual: Hardware for the detailed procedure.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false">R_SLCDC_SetdisplayArea() </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><li bindent="0" vspace="false"><span font="code">display_area</span> :   Display area to be used, A-pattern or B-pattern area. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (slcdc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close display device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to display interface control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SLCDC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.slcdc_on_slcdc.open" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.slcdc_on_slcdc.write" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;write(${instance}.p_ctrl, ${start_segment}, ${p_data}, ${segment_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call modify()" id="module.driver.slcdc_on_slcdc.modify" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="modify" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;modify(${instance}.p_ctrl, ${segment}, ${data_mask}, ${data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.slcdc_on_slcdc.start" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.slcdc_on_slcdc.stop" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call contrastIncrease()" id="module.driver.slcdc_on_slcdc.contrastIncrease" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="contrastIncrease" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;contrastIncrease(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call contrastDecrease()" id="module.driver.slcdc_on_slcdc.contrastDecrease" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="contrastDecrease" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;contrastDecrease(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setdisplayArea()" id="module.driver.slcdc_on_slcdc.setdisplayArea" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="setdisplayArea" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;setdisplayArea(${instance}.p_ctrl, ${display_area});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.slcdc_on_slcdc.close" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.slcdc_on_slcdc.versionGet" version="1"><moduleRef id="module.driver.slcdc_on_slcdc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.slcdc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.jpeg_encode" /><description>
<![CDATA[<form><p><span color="header" font="header">JPEG Encode HAL Module Introduction</span></p><p>The JPEG Encode HAL module provides a high-level API for industry standard JPEG image encode processing (compression) and uses the Synergy MCU JPEG Codec peripheral. A user callback function is available to inform the application program of key processing events.</p><p><b>JPEG Encode HAL Module Features</b></p><li bindent="0" vspace="false">Supports JPEG Compression.</li><li bindent="0" vspace="false">Supports polling mode that allows an application to wait for JPEG Encoder to complete.</li><li bindent="0" vspace="false">Supports interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical resolution, horizontal stride, and Quality factor. </li><li bindent="0" vspace="false">Supports putting raw image data in an input buffer and an output buffer to store the encoded/compressed jpeg image.</li><li bindent="0" vspace="false">Supports streaming raw image data into JPEG Encoder module. This feature allows an application to read coded raw image from a capture device or camera or from network without buffering the entire image.</li><li bindent="0" vspace="false">Only supports the YCbCr422 color space to input.</li><li bindent="0" vspace="false">Supports DRI Maker for RTP streaming application.</li><li bindent="0" vspace="false">Supports quality factor configuration: The quality factor value determines the quality of output image.</li><p><b>JPEG Encode Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for JPEG.</p><p>Legend:</p><p><span color="header" font="header">JPEG Encode HAL Module Features</span></p><li bindent="0" vspace="false">Supports JPEG Compression.</li><li bindent="0" vspace="false">Supports polling mode that allows an application to wait for JPEG Encoder to complete.</li><li bindent="0" vspace="false">Supports interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical resolution, horizontal stride, and Quality factor. </li><li bindent="0" vspace="false">Supports putting raw image data in an input buffer and an output buffer to store the encoded/compressed jpeg image.</li><li bindent="0" vspace="false">Supports streaming raw image data into JPEG Encoder module. This feature allows an application to read coded raw image from a capture device or camera or from network without buffering the entire image.</li><li bindent="0" vspace="false">Only supports the YCbCr422 color space to input.</li><li bindent="0" vspace="false">Supports DRI Maker for RTP streaming application.</li><li bindent="0" vspace="false">Supports quality factor configuration: The quality factor value determines the quality of output image.</li></form>]]>
</description><function display="ssp_err_t (*open) (jpeg_encode_ctrl_t *const p_ctrl, jpeg_encode_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_Open()</span></li><p><b>Precondition</b></p><p>none</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*imageParameterSet) (jpeg_encode_ctrl_t *const p_ctrl, jpeg_encode_raw_image_parameters *p_raw_image_parameters)" id="imageParameterSet"><description>
<![CDATA[<form><p>Set image parameters to JPEG Codec </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_ImageParameterSet()</span></li><p><b>Precondition</b></p><p>The JPEG codec module must have been opened properly.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_raw_image_parameters</span> :   Pointer to the RAW image parameters </li><p /></form>]]>
</description></function><function display="ssp_err_t (*outputBufferSet) (jpeg_encode_ctrl_t *const p_ctrl, void *p_buffer)" id="outputBufferSet"><description>
<![CDATA[<form><p>Assign output buffer to JPEG codec for storing output data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_OutputBufferSet()</span></li><p><b>Precondition</b></p><p>The JPEG codec module must have been opened properly. </p><p><b>Note</b></p><p>The buffer starting address must be 8-byte aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_encode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the output buffer space </li><p /></form>]]>
</description></function><function display="ssp_err_t (*inputBufferSet) (jpeg_encode_ctrl_t *const p_ctrl, void *p_buffer, uint32_t buffer_size)" id="inputBufferSet"><description>
<![CDATA[<form><p>Assign input data buffer to JPEG codec. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_InputBufferSet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly, output buffer and image parameter must be set prior to call this function. </p><p><b>Note</b></p><p>The buffer starting address must be 8-byte aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_encode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the input buffer space </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the input buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (jpeg_encode_ctrl_t *const p_ctrl, volatile jpeg_encode_status_t *p_status)" id="statusGet"><description>
<![CDATA[<form><p>Retrieve current status of the JPEG codec module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_StatusGet()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">jpeg_encode_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   JPEG module status </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (jpeg_encode_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Cancel an outstanding operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_Close()</span></li><p><b>Precondition</b></p><p>the JPEG codec module must have been opened properly. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in jpeg_encode_api_t::Open call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_JPEG_Encode_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.jpeg_encode.open" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call imageParameterSet()" id="module.driver.jpeg_encode.imageParameterSet" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="imageParameterSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;imageParameterSet(${instance}.p_ctrl, ${p_raw_image_parameters});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call outputBufferSet()" id="module.driver.jpeg_encode.outputBufferSet" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="outputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;outputBufferSet(${instance}.p_ctrl, ${p_buffer});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call inputBufferSet()" id="module.driver.jpeg_encode.inputBufferSet" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="inputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;inputBufferSet(${instance}.p_ctrl, ${p_buffer}, ${buffer_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.jpeg_encode.statusGet" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.jpeg_encode.close" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.jpeg_encode.versionGet" version="1"><moduleRef id="module.driver.jpeg_encode"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.jpeg_encode.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.jpeg_encode.callback_def.0" version="1"><moduleRef id="module.driver.jpeg_encode" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.jpeg_encode.p_callback)}(jpeg_encode_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.touch_on_ctsu" /><description>
<![CDATA[<form />]]>
</description><function display="ssp_err_t (*open) (ctsu_ctrl_t *const p_ctrl, ctsu_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStart) (ctsu_ctrl_t *const p_ctrl)" id="scanStart"><description>
<![CDATA[<form><p>Scan start. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_ScanStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dataGet) (ctsu_ctrl_t *const p_ctrl, uint16_t *p_data)" id="dataGet"><description>
<![CDATA[<form><p>Data get. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_DataGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to get data array. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*diagnosis) (ctsu_ctrl_t *const p_ctrl)" id="diagnosis"><description>
<![CDATA[<form><p>Diagnosis. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_Diagnosis()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*callbackSet) (ctsu_ctrl_t *const p_api_ctrl, void(*p_callback)(ctsu_callback_args_t *), void const *const p_context, ctsu_callback_args_t *const p_callback_memory)" id="callbackSet"><description>
<![CDATA[<form><p>Specify callback function and optional context pointer and working memory pointer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_CallbackSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CTSU control block. </li><li bindent="0" vspace="false"><span font="code">p_callback</span> :   Callback function </li><li bindent="0" vspace="false"><span font="code">p_context</span> :   Pointer to send to callback function </li><li bindent="0" vspace="false"><span font="code">p_working_memory</span> :   Pointer to volatile memory where callback structure can be allocated. Callback arguments allocated here are only valid during the callback. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (ctsu_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CTSU_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.touch_on_ctsu.open" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStart()" id="module.driver.touch_on_ctsu.scanStart" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="scanStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;scanStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dataGet()" id="module.driver.touch_on_ctsu.dataGet" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="dataGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;dataGet(${instance}.p_ctrl, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call diagnosis()" id="module.driver.touch_on_ctsu.diagnosis" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="diagnosis" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;diagnosis(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call callbackSet()" id="module.driver.touch_on_ctsu.callbackSet" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="callbackSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;callbackSet(${instance}.p_ctrl, ${ctsu_callback_args_t}, ${p_context}, ${p_callback_memory});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.touch_on_ctsu.close" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.touch_on_ctsu.versionGet" version="1"><moduleRef id="module.driver.touch_on_ctsu"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ctsu.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.touch_on_ctsu.callback_def.0" version="1"><moduleRef id="module.driver.touch_on_ctsu" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.ctsu.p_callback)}(ctsu_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.ctsu_on_ctsuv2" /><description>
<![CDATA[<form><p><span color="header" font="header">CTSU v2 HAL Module Introduction</span></p><p>The capacitive touch sensing unit version 2 HAL driver (r_ctsu v2) provides an API to control the CTSU peripheral. This module performs capacitance measurement based on various settings defined by the configuration. This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>.</p><p><b>CTSU v2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports both Self-capacitance multi scan mode and Mutual-capacitance full scan mode</li><li bindent="0" vspace="false">Scans may be started by software or an external trigger</li><li bindent="0" vspace="false">Returns measured capacitance data on scan completion</li><li bindent="0" vspace="false">Optional DTC support</li><li bindent="0" vspace="false">Built-in function that diagnoses its own circuit.</li><p><span color="header" font="header">CTSU v2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports both Self-capacitance multi scan mode and Mutual-capacitance full scan mode</li><li bindent="0" vspace="false">Scans may be started by software or an external trigger</li><li bindent="0" vspace="false">Returns measured capacitance data on scan completion</li><li bindent="0" vspace="false">Optional DTC support</li><li bindent="0" vspace="false">Built-in function that diagnoses its own circuit.</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.external_irq_on_icu" /><description>
<![CDATA[<form><p><span color="header" font="header">External IRQ HAL Module Introduction</span></p><p>The External IRQ HAL module provides an API for configuring and using external IRQ pins on Synergy MCUs. The External IRQ HAL module uses the Interrupt Controller Unit (ICU) of the Synergy MCU.</p><p><b>External IRQ HAL Module Features</b></p><li bindent="0" vspace="false">Supports the external interrupt pins available on the target Synergy MCU</li><li bindent="0" vspace="false">Supports multiple function options:</li><li bindent="20" vspace="false">Enabling and disabling generation of an interrupt</li><li bindent="20" vspace="false">Enabling and disabling the IRQ noise filter</li><li bindent="20" vspace="false">Setting external pin IRQ trigger (Rising edge, falling edge or low level on the IRQ pin)</li><li bindent="0" vspace="false">Supports configuring a user callback function, which will be invoked by the HAL module when an external pin interrupt is generated.</li><p><b /></p><p>The following hardware features are, or are not, supported by SSP for ICU.</p><p>Legend:</p><p>
Notes: ⎯ The ICU module in SSP (r_icu) handles only external pin interrupts and not the other features above. ⎯ Peripheral function interrupts are controlled by BSPs for each MCU and each peripheral driver modules in SSP. ⎯ DTC or DMA control is handled by DTC or DMAC module in SSP (r_dtc or r_dmac). ⎯ Non-maskable interrupts supported in SSP are IWDT Underflow, WDT Underflow and Voltage Monitor Interrupts. Those NMIs are controlled by IWDT, WDT or LVD modules (r_iwdt, r_wdt, or r_lvd), respectively. ⎯ LVD module (r_lvd) supports the Wake Up Interrupt Enable setting. For low power mode details, see the LPM section.</p><p><span color="header" font="header">External IRQ HAL Module Features</span></p><li bindent="0" vspace="false">Supports the external interrupt pins available on the target Synergy MCU</li><li bindent="0" vspace="false">Supports multiple function options:</li><li bindent="20" vspace="false">Enabling and disabling generation of an interrupt</li><li bindent="20" vspace="false">Enabling and disabling the IRQ noise filter</li><li bindent="20" vspace="false">Setting external pin IRQ trigger (Rising edge, falling edge or low level on the IRQ pin)</li><li bindent="0" vspace="false">Supports configuring a user callback function, which will be invoked by the HAL module when an external pin interrupt is generated.</li></form>]]>
</description><function display="ssp_err_t (*open) (external_irq_ctrl_t *const p_ctrl, external_irq_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (external_irq_ctrl_t *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enable callback when external IRQ occurs. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (external_irq_ctrl_t *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disable callback when external IRQ occurs. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*triggerSet) (external_irq_ctrl_t *const p_ctrl, external_irq_trigger_t const trigger)" id="triggerSet"><description>
<![CDATA[<form><p>Set trigger. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqTriggerSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><li bindent="0" vspace="false"><span font="code">trigger</span> :   Trigger type </li><p /></form>]]>
</description></function><function display="ssp_err_t (*filterEnable) (external_irq_ctrl_t *const p_ctrl)" id="filterEnable"><description>
<![CDATA[<form><p>Enables noise filter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqFilterEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*filterDisable) (external_irq_ctrl_t *const p_ctrl)" id="filterDisable"><description>
<![CDATA[<form><p>Disable noise filter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqFilterDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (external_irq_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allow driver to be reconfigured. May reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in Open call for this external interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_ICU_ExternalIrqVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.external_irq_on_icu.open" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.external_irq_on_icu.enable" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.external_irq_on_icu.disable" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call triggerSet()" id="module.driver.external_irq_on_icu.triggerSet" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="triggerSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;triggerSet(${instance}.p_ctrl, ${trigger});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call filterEnable()" id="module.driver.external_irq_on_icu.filterEnable" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="filterEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;filterEnable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call filterDisable()" id="module.driver.external_irq_on_icu.filterDisable" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="filterDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;filterDisable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.external_irq_on_icu.close" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.external_irq_on_icu.versionGet" version="1"><moduleRef id="module.driver.external_irq_on_icu"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.external_irq.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.external_irq_on_icu.callback_def.0" version="1"><moduleRef id="module.driver.external_irq_on_icu" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.external_irq.p_callback)}(external_irq_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.keymatrix_on_kint" /><description>
<![CDATA[<form><p><span color="header" font="header">Key Matrix HAL Module Introduction</span></p><p>The Key Matrix HAL module provides a high-level API for key input applications and uses the key-interrupt function peripheral on the Synergy MCU. A user-defined callback can be created to inform the CPU of a key press event.</p><p><b>Key Matrix HAL Module Features</b></p><p>This Key Matrix HAL module configures and controls the Key Interrupt (KINT) peripheral. It implements the following key functions:</p><li bindent="0" vspace="false">Supports both rising and falling edges on KINT channels</li><li bindent="0" vspace="false">Supports interrupt-based event notification</li><li bindent="0" vspace="false">Supports a bit-masking function to capture multiple events efficiently</li><li bindent="0" vspace="false">Supports a matrix keypad with edges on any two channels</li><p><b>KINT Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for KINT.</p><p>Legend:</p><p><span color="header" font="header">Key Matrix HAL Module Features</span></p><p>This Key Matrix HAL module configures and controls the Key Interrupt (KINT) peripheral. It implements the following key functions:</p><li bindent="0" vspace="false">Supports both rising and falling edges on KINT channels</li><li bindent="0" vspace="false">Supports interrupt-based event notification</li><li bindent="0" vspace="false">Supports a bit-masking function to capture multiple events efficiently</li><li bindent="0" vspace="false">Supports a matrix keypad with edges on any two channels</li></form>]]>
</description><function display="ssp_err_t (*open) (keymatrix_ctrl_t *const p_ctrl, keymatrix_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_KEYMATRIX_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Value set in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (keymatrix_ctrl_t *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enable Key interrupt </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_KEYMATRIX_Enable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block pointer set in Open call for this Key interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (keymatrix_ctrl_t *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disable Key interrupt. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_KEYMATRIX_Disable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block pointer set in Open call for this Key interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*triggerSet) (keymatrix_ctrl_t *const p_ctrl, keymatrix_trigger_t const trigger)" id="triggerSet"><description>
<![CDATA[<form><p>Set trigger for Key interrupt. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_KEYMATRIX_TriggerSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block pointer set in Open call for this Key interrupt. </li><li bindent="0" vspace="false"><span font="code">trigger</span> :   Trigger source for key interrupt; defined in enumeration of <span font="code">keymatrix_trigger_t</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (keymatrix_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allow driver to be reconfigured. May reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_KEYMATRIX_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block pointer set in Open call for this Key interrupt. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_KINT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.keymatrix_on_kint.open" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.keymatrix_on_kint.enable" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.keymatrix_on_kint.disable" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call triggerSet()" id="module.driver.keymatrix_on_kint.triggerSet" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="triggerSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;triggerSet(${instance}.p_ctrl, ${trigger});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.keymatrix_on_kint.close" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.keymatrix_on_kint.versionGet" version="1"><moduleRef id="module.driver.keymatrix_on_kint"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.keymatrix.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.keymatrix_on_kint.callback_def.0" version="1"><moduleRef id="module.driver.keymatrix_on_kint" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.keymatrix.p_callback)}(keymatrix_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.crc_on_crc" /><description>
<![CDATA[<form><p><span color="header" font="header">CRC HAL Module Introduction</span></p><p>The CRC HAL module provides a high-level API to calculate 8, 16 and 32-bit CRC values on a block of data in memory or a stream of data over a Serial Communication Interface (SCI) channel using industry standard polynomials.</p><p><b>CRC HAL Module Features</b></p><li bindent="0" vspace="false">CRC HAL module can calculate CRC on a block of data in memory.</li><li bindent="0" vspace="false">CRC HAL module can calculate CRC on a stream of data being transmitted or received over a serial communication Interface (SCI) channel (snoop mode).</li><li bindent="0" vspace="false">CRC HAL module supports the following 8-and 16-bit CRC polynomials which operates on 8-bit data in parallel</li><li bindent="20" vspace="false"><b>X</b>8  + <b>X</b>2  + <b>X</b> + 1 (CRC-8)</li><li bindent="20" vspace="false"><b>X</b>16  + <b>X</b>15  + <b>X</b>2  + 1 (CRC-16)</li><li bindent="20" vspace="false"><b>X</b>16  + <b>X</b>12  + <b>X</b>5  + 1 (CRC-CCITT)</li><li bindent="0" vspace="false">CRC HAL module supports the following 32 bit CRC polynomials which operates on 32-bit data in parallel</li><li bindent="20" vspace="false"><b>X</b>32  + <b>X</b>26  + <b>X</b>23  + <b>X</b>22  + <b>X</b>16  + <b>X</b>12  + <b>X</b>11  + <b>X</b>10  + <b>X</b>8  + <b>X</b>7  + <b>X</b>5  + <b>X</b>4  + <b>X</b>2  + X + 1 (CRC-32)</li><li bindent="20" vspace="false"><b>X</b>32  + <b>X</b>28  + <b>X</b>27  + <b>X</b>26  + <b>X</b>25  + <b>X</b>23  + <b>X</b>22  + <b>X</b>20  + <b>X</b>19  + <b>X</b>18  + <b>X</b>14  + <b>X</b>13  + <b>X</b>11  + <b>X</b>10  + <b>X</b>9  + <b>X</b>8  + <b>X</b>6  + 1 (CRC-32C)</li><li bindent="0" vspace="false">CRC HAL module can calculate CRC with LSB first or MSB first bit order.</li><p><b>CRC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the CRC.</p><p>Legend:</p><p><span color="header" font="header">CRC HAL Module Features</span></p><li bindent="0" vspace="false">CRC HAL module can calculate CRC on a block of data in memory.</li><li bindent="0" vspace="false">CRC HAL module can calculate CRC on a stream of data being transmitted or received over a serial communication Interface (SCI) channel (snoop mode).</li><li bindent="0" vspace="false">CRC HAL module supports the following 8-and 16-bit CRC polynomials which operates on 8-bit data in parallel</li><li bindent="20" vspace="false"><b>X</b>8  + <b>X</b>2  + <b>X</b> + 1 (CRC-8)</li><li bindent="20" vspace="false"><b>X</b>16  + <b>X</b>15  + <b>X</b>2  + 1 (CRC-16)</li><li bindent="20" vspace="false"><b>X</b>16  + <b>X</b>12  + <b>X</b>5  + 1 (CRC-CCITT)</li><li bindent="0" vspace="false">CRC HAL module supports the following 32 bit CRC polynomials which operates on 32-bit data in parallel</li><li bindent="20" vspace="false"><b>X</b>32  + <b>X</b>26  + <b>X</b>23  + <b>X</b>22  + <b>X</b>16  + <b>X</b>12  + <b>X</b>11  + <b>X</b>10  + <b>X</b>8  + <b>X</b>7  + <b>X</b>5  + <b>X</b>4  + <b>X</b>2  + X + 1 (CRC-32)</li><li bindent="20" vspace="false"><b>X</b>32  + <b>X</b>28  + <b>X</b>27  + <b>X</b>26  + <b>X</b>25  + <b>X</b>23  + <b>X</b>22  + <b>X</b>20  + <b>X</b>19  + <b>X</b>18  + <b>X</b>14  + <b>X</b>13  + <b>X</b>11  + <b>X</b>10  + <b>X</b>9  + <b>X</b>8  + <b>X</b>6  + 1 (CRC-32C)</li><li bindent="0" vspace="false">CRC HAL module can calculate CRC with LSB first or MSB first bit order.</li></form>]]>
</description><function display="ssp_err_t (*open) (crc_ctrl_t *const p_ctrl, crc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open the CRC driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CRC device handle. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to a configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (crc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the CRC module driver </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to crc device handle </li><p><b>Return Value</b></p><li bindent="0" vspace="false"><span font="code">SSP_SUCCESS</span> :   Configuration was successful. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*crcResultGet) (crc_ctrl_t *const p_ctrl, uint32_t *crc_result)" id="crcResultGet"><description>
<![CDATA[<form><p>Return the current calculated value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_CalculatedValueGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CRC device handle. </li><li bindent="0" vspace="false"><span font="code">crc_result</span> :   The calculated value from the last CRC calculation. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*snoopEnable) (crc_ctrl_t *const p_ctrl, uint32_t crc_seed)" id="snoopEnable"><description>
<![CDATA[<form><p>Enable snooping. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_SnoopEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CRC device handle. </li><li bindent="0" vspace="false"><span font="code">crc_seed</span> :   CRC seed. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*snoopDisable) (crc_ctrl_t *const p_ctrl)" id="snoopDisable"><description>
<![CDATA[<form><p>Disable snooping. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_SnoopDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to crc device handle. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*snoopCfg) (crc_ctrl_t *const p_ctrl, crc_snoop_cfg_t *const p_snoop_cfg)" id="snoopCfg"><description>
<![CDATA[<form><p>Configure the snoop channel and direction. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_SnoopCfg()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to crc device handle. </li><li bindent="0" vspace="false"><span font="code">p_snoopCfg</span> :   Snoop configuration. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calculate) (crc_ctrl_t *const p_ctrl, void *p_input_buffer, uint32_t num_bytes, uint32_t crc_seed, uint32_t *p_crc_result)" id="calculate"><description>
<![CDATA[<form><p>Perform a CRC calculation on a block of data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_Calculate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to crc device handle. </li><li bindent="0" vspace="false"><span font="code">input_buffer</span> :   A pointer to an array of data values. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   The number of bytes (not elements) in the array. </li><li bindent="0" vspace="false"><span font="code">crc_seed</span> :   The seeded value for crc calculations. </li><li bindent="0" vspace="false"><span font="code">crc_result</span> :   The calculated value of the CRC calculation. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_CRC_VersionGet()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.crc_on_crc.open" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.crc_on_crc.close" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call crcResultGet()" id="module.driver.crc_on_crc.crcResultGet" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="crcResultGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;crcResultGet(${instance}.p_ctrl, ${crc_result});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call snoopEnable()" id="module.driver.crc_on_crc.snoopEnable" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="snoopEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;snoopEnable(${instance}.p_ctrl, ${crc_seed});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call snoopDisable()" id="module.driver.crc_on_crc.snoopDisable" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="snoopDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;snoopDisable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call snoopCfg()" id="module.driver.crc_on_crc.snoopCfg" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="snoopCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;snoopCfg(${instance}.p_ctrl, ${p_snoop_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calculate()" id="module.driver.crc_on_crc.calculate" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="calculate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;calculate(${instance}.p_ctrl, ${p_input_buffer}, ${num_bytes}, ${crc_seed}, ${p_crc_result});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.crc_on_crc.versionGet" version="1"><moduleRef id="module.driver.crc_on_crc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.crc.name)}.p_api-&gt;versionGet(${version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.cac_on_cac" /><description>
<![CDATA[<form><p><span color="header" font="header">CAC HAL Module Introduction</span></p><p>The CAC HAL module provides a high-level API for clock accuracy control applications and uses the Clock Frequency Accuracy Measurement Circuit (CAC) peripheral on a Synergy MCU. This is particularly useful function when implementing a fail-safe mechanism for reliability-oriented applications. A user-defined callback can be created to respond to various error indications.</p><p><b>CAC HAL Module Features</b></p><li bindent="0" vspace="false">Supports clock frequency-measurement and monitoring based on a reference signal input.</li><li bindent="0" vspace="false">Reference can be either an externally supplied clock source or an internal clock sources.</li><li bindent="0" vspace="false">An interrupt request may optionally be generated by a completed measurement, a detected frequency error, or a counter overflow.</li><li bindent="0" vspace="false">A digital filter is available for an externally supplied reference clock, and dividers are available for both internally supplied measurement and reference clocks.</li><li bindent="0" vspace="false">Edge-detection options for the reference clock are configurable as rising, falling, or both.</li><p><b>CAC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the CAC.</p><p>Legend:</p><p><span color="header" font="header">CAC HAL Module Features</span></p><li bindent="0" vspace="false">Supports clock frequency-measurement and monitoring based on a reference signal input.</li><li bindent="0" vspace="false">Reference can be either an externally supplied clock source or an internal clock sources.</li><li bindent="0" vspace="false">An interrupt request may optionally be generated by a completed measurement, a detected frequency error, or a counter overflow.</li><li bindent="0" vspace="false">A digital filter is available for an externally supplied reference clock, and dividers are available for both internally supplied measurement and reference clocks.</li><li bindent="0" vspace="false">Edge-detection options for the reference clock are configurable as rising, falling, or both.</li></form>]]>
</description><function display="ssp_err_t (*open) (cac_ctrl_t *const p_ctrl, cac_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open function for CAC device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CAC device control. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">cac_cfg_t</span> :   Pointer to CAC configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (cac_ctrl_t *const p_ctrl, uint8_t *const p_status, uint16_t *const p_counter)" id="read"><description>
<![CDATA[<form><p>Read function for CAC peripheral. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the CAC device context. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Pointer to variable in which to store the current CASTR register contents. </li><li bindent="0" vspace="false"><span font="code">p_counter</span> :   Pointer to variable in which to store the current CACNTBR register contents. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (cac_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close function for CAC device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CAC device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stopMeasurement) (cac_ctrl_t *const p_ctrl)" id="stopMeasurement"><description>
<![CDATA[<form><p>End a measurement for the CAC peripheral. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CAC device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*startMeasurement) (cac_ctrl_t *const p_ctrl)" id="startMeasurement"><description>
<![CDATA[<form><p>Begin a measurement for the CAC peripheral. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CAC device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (cac_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset function for CAC device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to CAC device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the CAC API and code version information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   is value returned. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.cac_on_cac.open" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.cac_on_cac.read" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_status}, ${p_counter});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.cac_on_cac.close" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stopMeasurement()" id="module.driver.cac_on_cac.stopMeasurement" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="stopMeasurement" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;stopMeasurement(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call startMeasurement()" id="module.driver.cac_on_cac.startMeasurement" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="startMeasurement" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;startMeasurement(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.cac_on_cac.reset" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.cac_on_cac.versionGet" version="1"><moduleRef id="module.driver.cac_on_cac"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.cac.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.cac_on_cac.callback_def.0" version="1"><moduleRef id="module.driver.cac_on_cac" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.cac.p_callback)}(cac_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.doc_on_doc" /><description>
<![CDATA[<form><p><span color="header" font="header">DOC HAL Module Introduction</span></p><p>The Data Operation Circuit (DOC) HAL module provides a high-level API for DOC applications and uses the DOC peripherals on the Synergy MCU. A user-defined callback can be created to inform the CPU when an event occurs.</p><p><b>DOC HAL Module Features</b></p><p>The DOC HAL module peripheral is used to compare 16-bit data and can detect the following events:</p><li bindent="0" vspace="false">A mismatch or match between data values</li><li bindent="0" vspace="false">Overflow of an addition operation</li><li bindent="0" vspace="false">Underflow of a subtraction operation</li><p><b>DOC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for DOC.</p><p>Legend:</p><p><span color="header" font="header">DOC HAL Module Features</span></p><p>The DOC HAL module peripheral is used to compare 16-bit data and can detect the following events:</p><li bindent="0" vspace="false">A mismatch or match between data values</li><li bindent="0" vspace="false">Overflow of an addition operation</li><li bindent="0" vspace="false">Underflow of a subtraction operation</li></form>]]>
</description><function display="ssp_err_t (*open) (doc_ctrl_t *const p_ctrl, doc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_Open()</span> </li><p><b>Precondition</b></p><p>Peripheral clocks should be configured prior to calling this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (doc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allow the driver to be reconfigured. Will reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">doc_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (doc_ctrl_t *const p_ctrl, doc_status_t *p_status)" id="statusGet"><description>
<![CDATA[<form><p>Get the DOC status and stores it in the provided pointer p_status. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_StatusGet()</span> </li><p><b>Precondition</b></p><p>Call <span font="code">doc_api_t::open</span> to configure the DOC before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">doc_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Indicates the status of the comparison/addition/subtraction operation. Result will be one of <span font="code">doc_status_t</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusClear) (doc_ctrl_t *const p_ctrl)" id="statusClear"><description>
<![CDATA[<form><p>Clear DOPCF status flag. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_StatusClear()</span> </li><p><b>Precondition</b></p><p>Call <span font="code">doc_api_t::open</span> to configure the DOC before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">doc_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (doc_ctrl_t *const p_ctrl, doc_data_t *const p_data)" id="write"><description>
<![CDATA[<form><p>Write to the DODIR and DODSR registers. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_Write()</span></li><p><b>Precondition</b></p><p>Call <span font="code">doc_api_t::open</span> to configure the DOC before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">doc_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data to be written to DOC DODIR and DODSR registers. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*inputRegisterWrite) (doc_ctrl_t *const p_ctrl, doc_size_t data)" id="inputRegisterWrite"><description>
<![CDATA[<form><p>Write to the DODIR register. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_InputRegisterWrite()</span> </li><p><b>Precondition</b></p><p>Call <span font="code">doc_api_t::open</span> to configure the DOC before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">doc_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">data</span> :   Data to be written to DOC DODIR register. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DOC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.doc_on_doc.open" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.doc_on_doc.close" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.doc_on_doc.statusGet" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusClear()" id="module.driver.doc_on_doc.statusClear" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="statusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;statusClear(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.doc_on_doc.write" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call inputRegisterWrite()" id="module.driver.doc_on_doc.inputRegisterWrite" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="inputRegisterWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;inputRegisterWrite(${instance}.p_ctrl, ${data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.doc_on_doc.versionGet" version="1"><moduleRef id="module.driver.doc_on_doc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.doc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.doc_on_doc.callback_def.0" version="1"><moduleRef id="module.driver.doc_on_doc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.doc.p_callback)}(doc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.watchdog_on_wdt" /><description>
<![CDATA[<form><p><span color="header" font="header">Watchdog Timer HAL Module Introduction</span></p><p>The WDT (Watchdog Timer) HAL module provides a high-level API for critical timing applications and uses the WDT peripheral on the Synergy MCU. A user-defined callback can be created to respond to event notifications.</p><p><b>Watchdog Timer HAL Module Features</b></p><p>The WDT HAL module has the following key features:</p><li bindent="0" vspace="false">When the WDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:</li><li bindent="20" vspace="false">Resetting of the device</li><li bindent="20" vspace="false">Generation of an NMI</li><li bindent="0" vspace="false">Supports the Watchdog Timer (WDT) peripheral, which uses an external clock.</li><li bindent="0" vspace="false">The WDT can be configured in register start mode through the WDT registers.</li><li bindent="0" vspace="false">Supports automatic hardware configuration after reset.</li><li bindent="0" vspace="false">The WDT can be started from the application.</li><p><b>Watchdog Timer Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for WDT:</p><p>Legend:</p><p><span color="header" font="header">Watchdog Timer HAL Module Features</span></p><p>The WDT HAL module has the following key features:</p><li bindent="0" vspace="false">When the WDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:</li><li bindent="20" vspace="false">Resetting of the device</li><li bindent="20" vspace="false">Generation of an NMI</li><li bindent="0" vspace="false">Supports the Watchdog Timer (WDT) peripheral, which uses an external clock.</li><li bindent="0" vspace="false">The WDT can be configured in register start mode through the WDT registers.</li><li bindent="0" vspace="false">Supports automatic hardware configuration after reset.</li><li bindent="0" vspace="false">The WDT can be started from the application.</li></form>]]>
</description><function display="ssp_err_t (*cfgGet) (wdt_ctrl_t *const p_ctrl, wdt_cfg_t *const p_cfg)" id="cfgGet"><description>
<![CDATA[<form><p>Initialize the WDT in register start mode. In auto-start mode with NMI output it registers the NMI callback. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_CfgGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_CfgGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure for reading WDT configuration. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*open) (wdt_ctrl_t *const p_ctrl, wdt_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize the WDT in register start mode. In auto-start mode with NMI output it registers the NMI callback. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*refresh) (wdt_ctrl_t *const p_ctrl)" id="refresh"><description>
<![CDATA[<form><p>Refresh the watchdog timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_Refresh()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_Refresh()</span></li><p><b>Precondition</b></p><p>If the WDT is in auto-start mode ensure the OFS0 register is configured before using this function. </p><p><b>Warning</b></p><p>Calling this function in register-start mode before calling <span font="code">R_WDT_Open</span> will start the WDT in it's default state and further changes to the configuration will not be possible. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (wdt_ctrl_t *const p_ctrl, wdt_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Read the status of the WDT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Pointer to variable to return status information through. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusClear) (wdt_ctrl_t *const p_ctrl, const wdt_status_t status)" id="statusClear"><description>
<![CDATA[<form><p>Clear the status flags of the WDT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_StatusClear()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_StatusClear()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">status</span> :   Status condition(s) to clear. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*counterGet) (wdt_ctrl_t *const p_ctrl, uint32_t *const p_count)" id="counterGet"><description>
<![CDATA[<form><p>Read the current WDT counter value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_CounterGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_CounterGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_count</span> :   Pointer to variable to return current WDT counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*timeoutGet) (wdt_ctrl_t *const p_ctrl, wdt_timeout_values_t *const p_timeout)" id="timeoutGet"><description>
<![CDATA[<form><p>Read the watchdog timeout values. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_TimeoutGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_TimeoutGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_timeout</span> :   Pointer to structure to return timeout values. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the IOPort driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call cfgGet()" id="module.driver.watchdog_on_wdt.cfgGet" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="cfgGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;cfgGet(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call open()" id="module.driver.watchdog_on_wdt.open" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call refresh()" id="module.driver.watchdog_on_wdt.refresh" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="refresh" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;refresh(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.watchdog_on_wdt.statusGet" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusClear()" id="module.driver.watchdog_on_wdt.statusClear" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="statusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;statusClear(${instance}.p_ctrl, ${status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call counterGet()" id="module.driver.watchdog_on_wdt.counterGet" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="counterGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;counterGet(${instance}.p_ctrl, ${p_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call timeoutGet()" id="module.driver.watchdog_on_wdt.timeoutGet" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="timeoutGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;timeoutGet(${instance}.p_ctrl, ${p_timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.watchdog_on_wdt.versionGet" version="1"><moduleRef id="module.driver.watchdog_on_wdt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.watchdog.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.watchdog_on_wdt.callback_def.0" version="1"><moduleRef id="module.driver.watchdog_on_wdt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.watchdog.nmi_callback)}(wdt_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.watchdog_on_iwdt" /><description>
<![CDATA[<form><p><span color="header" font="header">Independent Watchdog Timer HAL Module Introduction</span></p><p>The Independent Watchdog Timer (IWDT) HAL module provides a high-level API for watchdog timer applications and uses the IWDT peripheral on the Synergy MCU. A user-defined callback can be created to respond to event notifications.</p><p><b>Independent Watchdog Timer HAL Module Features</b></p><p>The IWDT HAL module supports the following key features:</p><li bindent="0" vspace="false">When the WDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:</li><li bindent="20" vspace="false">Resetting of the device</li><li bindent="20" vspace="false">Generation of an NMI</li><li bindent="0" vspace="false">Supports the internal Watchdog timer peripheral (IWDT), which has its own clock source which improves safety.</li><li bindent="0" vspace="false">Supports automatic hardware configuration after reset.</li><p><b>Independent Watchdog Timer Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for IWDT:</p><p>Legend:</p><p><span color="header" font="header">Independent Watchdog Timer HAL Module Features</span></p><p>The IWDT HAL module supports the following key features:</p><li bindent="0" vspace="false">When the WDT underflows or is refreshed outside of the permitted refresh window, one of the following events can occur:</li><li bindent="20" vspace="false">Resetting of the device</li><li bindent="20" vspace="false">Generation of an NMI</li><li bindent="0" vspace="false">Supports the internal Watchdog timer peripheral (IWDT), which has its own clock source which improves safety.</li><li bindent="0" vspace="false">Supports automatic hardware configuration after reset.</li></form>]]>
</description><function display="ssp_err_t (*cfgGet) (wdt_ctrl_t *const p_ctrl, wdt_cfg_t *const p_cfg)" id="cfgGet"><description>
<![CDATA[<form><p>Initialize the WDT in register start mode. In auto-start mode with NMI output it registers the NMI callback. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_CfgGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_CfgGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure for reading WDT configuration. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*open) (wdt_ctrl_t *const p_ctrl, wdt_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize the WDT in register start mode. In auto-start mode with NMI output it registers the NMI callback. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*refresh) (wdt_ctrl_t *const p_ctrl)" id="refresh"><description>
<![CDATA[<form><p>Refresh the watchdog timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_Refresh()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_Refresh()</span></li><p><b>Precondition</b></p><p>If the WDT is in auto-start mode ensure the OFS0 register is configured before using this function. </p><p><b>Warning</b></p><p>Calling this function in register-start mode before calling <span font="code">R_WDT_Open</span> will start the WDT in it's default state and further changes to the configuration will not be possible. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (wdt_ctrl_t *const p_ctrl, wdt_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Read the status of the WDT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Pointer to variable to return status information through. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusClear) (wdt_ctrl_t *const p_ctrl, const wdt_status_t status)" id="statusClear"><description>
<![CDATA[<form><p>Clear the status flags of the WDT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_StatusClear()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_StatusClear()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">status</span> :   Status condition(s) to clear. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*counterGet) (wdt_ctrl_t *const p_ctrl, uint32_t *const p_count)" id="counterGet"><description>
<![CDATA[<form><p>Read the current WDT counter value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_CounterGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_CounterGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_count</span> :   Pointer to variable to return current WDT counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*timeoutGet) (wdt_ctrl_t *const p_ctrl, wdt_timeout_values_t *const p_timeout)" id="timeoutGet"><description>
<![CDATA[<form><p>Read the watchdog timeout values. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_TimeoutGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_TimeoutGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_timeout</span> :   Pointer to structure to return timeout values. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the IOPort driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_WDT_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_IWDT_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call cfgGet()" id="module.driver.watchdog_on_iwdt.cfgGet" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="cfgGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;cfgGet(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call open()" id="module.driver.watchdog_on_iwdt.open" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call refresh()" id="module.driver.watchdog_on_iwdt.refresh" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="refresh" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;refresh(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.watchdog_on_iwdt.statusGet" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusClear()" id="module.driver.watchdog_on_iwdt.statusClear" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="statusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;statusClear(${instance}.p_ctrl, ${status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call counterGet()" id="module.driver.watchdog_on_iwdt.counterGet" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="counterGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;counterGet(${instance}.p_ctrl, ${p_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call timeoutGet()" id="module.driver.watchdog_on_iwdt.timeoutGet" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="timeoutGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;timeoutGet(${instance}.p_ctrl, ${p_timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.watchdog_on_iwdt.versionGet" version="1"><moduleRef id="module.driver.watchdog_on_iwdt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpm.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.watchdog_on_iwdt.callback_def.0" version="1"><moduleRef id="module.driver.watchdog_on_iwdt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.watchdog.nmi_callback)}(wdt_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s1ja.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s1ja.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s1ja.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s1ja.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s1ja.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s1ja"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s1ja_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s1ja_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s1ja_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s1ja_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s1ja_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s1ja_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s1ja_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s1ja_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s1ja_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s1ja_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s1ja_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s1ja_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s1ja_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s1ja_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s1ja_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s1ja_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s1ja_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s1ja_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s1ja_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s1ja_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s1ja_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s1ja_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s3a1.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s3a1.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s3a1.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s3a1.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s3a1.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a1"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a1_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a1_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s3a1_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a1_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a1_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a1_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a1_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a1_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a1_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a1_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a1_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a1_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a1_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s3a1_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a1_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a1_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a1_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a1_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a1_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a1_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a1_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a1_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s3a3.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s3a3.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s3a3.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s3a3.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s3a3.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a3"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a3_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a3_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s3a3_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a3_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a3_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a3_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a3_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a3_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a3_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a3_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a3_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a3_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a3_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s3a3_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a3_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a3_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a3_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a3_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a3_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a3_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a3_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a3_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s3a6.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s3a6.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s3a6.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s3a6.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s3a6.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a6"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a6_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a6_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s3a6_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a6_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a6_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a6_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a6_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a6_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a6_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a6_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a6_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a6_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a6_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s3a6_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a6_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a6_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a6_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a6_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a6_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a6_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a6_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a6_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s3a7.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s3a7.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s3a7.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s3a7.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s3a7.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s3a7"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a7_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a7_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s3a7_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a7_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a7_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a7_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a7_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a7_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a7_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a7_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a7_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s3a7_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s3a7_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s3a7_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s3a7_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s3a7_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s3a7_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s3a7_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s3a7_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s3a7_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s3a7_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s3a7_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s5d3.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s5d3.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s5d3.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s5d3.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s5d3.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d3"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d3_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d3_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s5d3_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d3_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d3_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d3_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d3_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d3_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d3_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d3_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d3_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d3_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d3_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s5d3_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d3_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d3_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d3_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d3_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d3_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d3_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d3_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d3_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s5d5.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s5d5.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s5d5.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s5d5.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s5d5.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d5"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d5_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d5_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s5d5_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d5_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d5_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d5_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d5_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d5_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d5_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d5_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d5_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d5_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d5_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s5d5_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d5_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d5_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d5_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d5_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d5_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d5_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d5_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d5_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s5d9.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s5d9.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s5d9.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s5d9.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s5d9.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s5d9"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d9_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d9_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s5d9_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d9_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d9_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d9_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d9_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d9_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d9_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d9_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d9_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s5d9_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s5d9_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s5d9_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s5d9_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s5d9_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s5d9_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s5d9_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s5d9_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s5d9_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s5d9_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s5d9_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s7g2.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s7g2.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s7g2.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s7g2.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s7g2.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s7g2"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s7g2_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s7g2_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s7g2_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s7g2_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s7g2_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s7g2_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s7g2_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s7g2_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s7g2_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s7g2_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s7g2_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s7g2_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s7g2_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s7g2_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s7g2_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s7g2_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s7g2_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s7g2_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s7g2_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s7g2_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s7g2_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s7g2_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s124.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s124.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s124.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s124.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s124.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s124"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s124_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s124_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s124_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s124_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s124_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s124_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s124_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s124_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s124_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s124_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s124_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s124_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s124_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s124_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s124_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s124_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s124_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s124_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s124_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s124_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s124_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s124_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_common_on_lpmv2_s128.init" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_common_on_lpmv2_s128.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_common_on_lpmv2_s128.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_common_on_lpmv2_s128.versionGet" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_common_on_lpmv2_s128.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_common_on_lpmv2_s128"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2_common.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s128_sleep" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s128_sleep.init" version="1"><moduleRef id="module.driver.lpmv2_s128_sleep"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s128_sleep.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s128_sleep"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s128_sleep.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s128_sleep"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s128_sleep.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s128_sleep"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s128_sleep.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s128_sleep"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lpmv2_s128_standby" /><description>
<![CDATA[<form><p><span color="header" font="header">LPM V2 HAL Module Introduction</span></p><p>The Low Power Modes V2 HAL module provides a high-level API for low-power mode applications and uses the low-power mode hardware peripheral on the Synergy MCU.</p><p><b>LPM V2 HAL Module Features</b></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p><p><b>LPMV2 Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LPM V2:</p><p>Legend:</p><p><span color="header" font="header">LPM V2 HAL Module Features</span></p><li bindent="0" vspace="false">Supports configuration of MCU operating power-control modes and MCU low-power modes</li><li bindent="0" vspace="false">Supports the following low power modes:</li><li bindent="20" vspace="false">Deep Software Standby mode</li><li bindent="20" vspace="false">Software Standby mode</li><li bindent="20" vspace="false">Sleep mode</li><li bindent="20" vspace="false">Snooze mode</li><li bindent="0" vspace="false">​​​​​​​Supports reducing power consumption when in deep stand-by mode through internal power‑supply control and by resetting the states of I/O ports.</li><li bindent="0" vspace="false">Supports disabling and enabling of the MCU's other hardware peripherals.</li><p><b>Note</b></p><p>  Not all low-power V2 modes are available on all MCU Groups.</p></form>]]>
</description><function display="ssp_err_t (*init) (void)" id="init"><description>
<![CDATA[<form><p>Initialization function </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_Init()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerCfg) (lpmv2_cfg_t const *const p_cfg)" id="lowPowerCfg"><description>
<![CDATA[<form><p>Configure a low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerConfigure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerModeEnter) (void)" id="lowPowerModeEnter"><description>
<![CDATA[<form><p>Enter low power mode (sleep/standby/deep standby) using WFI macro. Function will return after waking from low power mode. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_LowPowerModeEnter()</span> </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearIOKeep) (void)" id="clearIOKeep"><description>
<![CDATA[<form><p>Clear the IOKEEP bit after deep software standby.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LPMV2_ClearIOKeep()</span> </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call init()" id="module.driver.lpmv2_s128_standby.init" version="1"><moduleRef id="module.driver.lpmv2_s128_standby"><function id="init" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;init();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerCfg()" id="module.driver.lpmv2_s128_standby.lowPowerCfg" version="1"><moduleRef id="module.driver.lpmv2_s128_standby"><function id="lowPowerCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerCfg(${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerModeEnter()" id="module.driver.lpmv2_s128_standby.lowPowerModeEnter" version="1"><moduleRef id="module.driver.lpmv2_s128_standby"><function id="lowPowerModeEnter" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;lowPowerModeEnter();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lpmv2_s128_standby.versionGet" version="1"><moduleRef id="module.driver.lpmv2_s128_standby"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearIOKeep()" id="module.driver.lpmv2_s128_standby.clearIOKeep" version="1"><moduleRef id="module.driver.lpmv2_s128_standby"><function id="clearIOKeep" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lpmv2.name)}.p_api-&gt;clearIOKeep();
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.lvd" /><description>
<![CDATA[<form><p><span color="header" font="header">LVD HAL Module Introduction</span></p><p>The Low Voltage Detection (LVD) HAL module provides a high-level API for voltage-detection applications and uses the LVD peripheral on the Synergy MCU. A user-defined callback can be created to notify the CPU when a voltage-detection event is triggered. The VCC is the source for all voltage-detection functions.</p><p><b>LVD HAL Module Features</b></p><p>The LVD HAL module supports the following functions:</p><li bindent="0" vspace="false">V CC  as the voltage-detection input</li><li bindent="0" vspace="false">One build-time configurable low-voltage detector (via OFS1 register)</li><li bindent="0" vspace="false">Two run-time configurable low-voltage detectors</li><li bindent="0" vspace="false">Two result flags; one for a threshold check and one for the current state</li><li bindent="0" vspace="false">Support for both interrupt or polling-event checking</li><p><b>LVD Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for LVD:</p><p>Legend:</p><p><span color="header" font="header">LVD HAL Module Features</span></p><p>The LVD HAL module supports the following functions:</p><li bindent="0" vspace="false">V CC  as the voltage-detection input</li><li bindent="0" vspace="false">One build-time configurable low-voltage detector (via OFS1 register)</li><li bindent="0" vspace="false">Two run-time configurable low-voltage detectors</li><li bindent="0" vspace="false">Two result flags; one for a threshold check and one for the current state</li><li bindent="0" vspace="false">Support for both interrupt or polling-event checking</li></form>]]>
</description><function display="ssp_err_t (*open) (lvd_ctrl_t *const p_ctrl, lvd_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes a low voltage detection driver according to the passed in configuration structure. Enables an LVD peripheral based on configuration structure. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LVD_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to monitor control structure for the driver instance </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the configuration structure for the driver instance </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (lvd_ctrl_t *const p_ctrl, lvd_status_t *p_lvd_status)" id="statusGet"><description>
<![CDATA[<form><p>Get the current state of the monitor, (threshold crossing detected, voltage currently within range) Can be used to poll the state of the LVD monitor at any time. Must be used if the peripheral was initialized with lvd_response_t set to LVD_RESPONSE_NONE. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LVD_StatusGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure for the driver instance </li><li bindent="0" vspace="false"><span font="code">p_lvd_status</span> :   Pointer to an <span font="code">lvd_status_t</span> instance </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusClear) (lvd_ctrl_t *const p_ctrl)" id="statusClear"><description>
<![CDATA[<form><p>Clears the latched status of the monitor. Must be used if the peripheral was initialized with lvd_response_t set to LVD_RESPONSE_NONE. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LVD_StatusClear()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure for the driver instance </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (lvd_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disables the LVD peripheral. Closes the driver instance. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LVD_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure for the driver instance </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Returns the LVD driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_LVD_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to version structure </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.lvd.open" version="1"><moduleRef id="module.driver.lvd"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lvd.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.lvd.statusGet" version="1"><moduleRef id="module.driver.lvd"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lvd.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_lvd_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusClear()" id="module.driver.lvd.statusClear" version="1"><moduleRef id="module.driver.lvd"><function id="statusClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lvd.name)}.p_api-&gt;statusClear(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.lvd.close" version="1"><moduleRef id="module.driver.lvd"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lvd.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.lvd.versionGet" version="1"><moduleRef id="module.driver.lvd"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.lvd.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.lvd.callback_def.0" version="1"><moduleRef id="module.driver.lvd" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.lvd.lvd_monitor_callback)}(lvd_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.flash_on_flash_hp" /><description>
<![CDATA[<form><p><span color="header" font="header">Flash HAL Module Introduction</span></p><p>There are two separate Flash modules: the r_flash_lp and the r_flash_hp. These modules implement a high-level API for flash memory programming applications. The High-Performance Flash module (Flash_HP) is used for programming the S7 and S5 family of MCUs. The Low-Power Flash module (Flash_LP) is used for programming the S3 and S1 family of MCUs. The two are not interchangeable, although the APIs and other features of the modules are very similar.</p><p><b>Flash HAL Module Features</b></p><p>The Flash HAL modules APIs allow an application to read, write and erase both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts, but the API functions apply to all devices. Key features of the Flash HAL modules include:</p><li bindent="0" vspace="false">Support for both blocking and non-blocking erasing, reading, writing and blank-checking of data flash.</li><li bindent="0" vspace="false">Support for blocking erasing, reading, writing and blank checking of code flash.</li><li bindent="0" vspace="false">Support for callback functions for completion of non-blocking data-flash operations.</li><li bindent="0" vspace="false">Support for access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li><li bindent="0" vspace="false">Support for boot block-swapping which allows safe rewriting of the startup program without first erasing it.</li><p><b>Flash HAL HP Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Flash_HP.</p><p>Legend:</p><p><b>Flash HAL LP Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Flash_LP.</p><p>Legend:</p><p><span color="header" font="header">Flash HAL Module Features</span></p><p>The Flash HAL modules APIs allow an application to read, write and erase both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts, but the API functions apply to all devices. Key features of the Flash HAL modules include:</p><li bindent="0" vspace="false">Support for both blocking and non-blocking erasing, reading, writing and blank-checking of data flash.</li><li bindent="0" vspace="false">Support for blocking erasing, reading, writing and blank checking of code flash.</li><li bindent="0" vspace="false">Support for callback functions for completion of non-blocking data-flash operations.</li><li bindent="0" vspace="false">Support for access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li><li bindent="0" vspace="false">Support for boot block-swapping which allows safe rewriting of the startup program without first erasing it.</li></form>]]>
</description><function display="ssp_err_t (*open) (flash_ctrl_t *const p_ctrl, flash_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">flash_cfg_t</span> :   Pointer to FLASH configuration structure. All elements of this structure must be set by the user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (flash_ctrl_t *const p_ctrl, uint32_t const src_address, uint32_t const flash_address, uint32_t const num_bytes)" id="write"><description>
<![CDATA[<form><p>Write FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Write()</span></li><p><b>Warning</b></p><p>Specifying a number that is not a multiple of the programming size will result in SF_FLASH_ERR_BYTES being returned and no data written. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">src_address</span> :   Address of the buffer containing the data to write to Flash. </li><li bindent="0" vspace="false"><span font="code">flash_address</span> :   Code Flash or Data Flash address to write. The address must be on a programming line boundary. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   The number of bytes to write. This number must be a multiple of the programming size. For Code Flash this is FLASH_MIN_PGM_SIZE_CF. For Data Flash this is FLASH_MIN_PGM_SIZE_DF. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (flash_ctrl_t *const p_ctrl, uint8_t *const p_dest_address, uint32_t const flash_address, uint32_t const num_bytes)" id="read"><description>
<![CDATA[<form><p>Read FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">p_dest_address</span> :   Pointer to caller's destination buffer used to hold the data read from Flash. </li><li bindent="0" vspace="false"><span font="code">flash_address</span> :   Code Flash or Data Flash starting address to read from. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   The number of bytes to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (flash_ctrl_t *const p_ctrl, uint32_t const address, uint32_t const num_blocks)" id="erase"><description>
<![CDATA[<form><p>Erase FLASH device. </p><p><b>Implemented as</b></p><p><span font="code">R_FLASH_LP_Erase()</span> <span font="code">R_FLASH_HP_Erase()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device. </li><li bindent="0" vspace="false"><span font="code">address</span> :   The block containing this address is the first block erased. </li><li bindent="0" vspace="false"><span font="code">num_blocks</span> :   Specifies the number of blocks to be erased, the starting block determined by the block_erase_address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*blankCheck) (flash_ctrl_t *const p_ctrl, uint32_t const address, uint32_t const num_bytes, flash_result_t *const p_blank_check_result)" id="blankCheck"><description>
<![CDATA[<form><p>Blank check FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_BlankCheck()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_BlankCheck()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">address</span> :   The starting address of the Flash area to blank check. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   Specifies the number of bytes that need to be checked. See the specific handler for details. </li><li bindent="0" vspace="false"><span font="code">p_blank_check_result</span> :   Pointer that will be populated by the API with the results of the blank check operation in non-BGO (blocking) mode. In this case the blank check operation completes here and the result is returned. In Data Flash BGO mode the blank check operation is only started here and the result obtained later when the supplied callback routine is called. In this case FLASH_RESULT_BGO_ACTIVE will be returned in p_blank_check_result. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (flash_ctrl_t *const p_ctrl, flash_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Close FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to FLASH info structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (flash_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (flash_ctrl_t *const p_ctrl)" id="statusGet"><description>
<![CDATA[<form><p>Get Status for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*accessWindowSet) (flash_ctrl_t *const p_ctrl, uint32_t const start_addr, uint32_t const end_addr)" id="accessWindowSet"><description>
<![CDATA[<form><p>Set Access Window for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_AccessWindowSet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_AccessWindowSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">start_addr</span> :   Determines the Starting block for the Code Flash access window. </li><li bindent="0" vspace="false"><span font="code">end_addr</span> :   Determines the Ending block for the Code Flash access window. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*accessWindowClear) (flash_ctrl_t *const p_ctrl)" id="accessWindowClear"><description>
<![CDATA[<form><p>Clear any existing Code Flash access window for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_AccessWindowClear()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_AccessWindowClear()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">start_addr</span> :   Determines the Starting block for the Code Flash access window. </li><li bindent="0" vspace="false"><span font="code">end_addr</span> :   Determines the Ending block for the Code Flash access window. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*idCodeSet) (flash_ctrl_t *const p_ctrl, uint8_t const *const p_id_bytes, flash_id_code_mode_t mode)" id="idCodeSet"><description>
<![CDATA[<form><p>Set ID Code for FLASH device. Setting the ID code can restrict access to the device. The ID code will be required to connect to the device. Bits 126 and 127 are set based on the mode. e.g. uint8_t id_bytes[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0x00}; with mode FLASH_ID_CODE_MODE_LOCKED_WITH_ALL_ERASE_SUPPORT will result in an ID code of 00112233445566778899aabbccddeec0 and with mode FLASH_ID_CODE_MODE_LOCKED will result in an ID code of 00112233445566778899aabbccddee80</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_IdCodeSet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_IdCodeSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">p_id_bytes</span> :   Ponter to the ID Code to be written. </li><li bindent="0" vspace="false"><span font="code">mode</span> :   Mode used for checking the ID code. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (flash_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset function for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateFlashClockFreq) (flash_ctrl_t *const p_ctrl)" id="updateFlashClockFreq"><description>
<![CDATA[<form><p>Update Flash clock frequency (FCLK) and recalculate timeout values </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_UpdateFlashClockFreq()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_UpdateFlashClockFreq()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*startupAreaSelect) (flash_ctrl_t *const p_ctrl, flash_startup_area_swap_t swap_type, bool is_temporary)" id="startupAreaSelect"><description>
<![CDATA[<form><p>Select which block - Default (Block 0) or Alternate (Block 1) is used as the start-up area block.  
swap_type | is_temporary | Operation FLASH_STARTUP_AREA_BLOCK0: false On next reset Startup area will be Block 0. 
FLASH_STARTUP_AREA_BLOCK0 | false | On next reset Startup area will be Block 0. Block 0. 
FLASH_STARTUP_AREA_BLOCK1: false On next reset Startup area will be Block 1. 
FLASH_STARTUP_AREA_BLOCK1 | true | Startup area is immediately, but temporarily switched to Block 1. Block 1. 
FLASH_STARTUP_AREA_BTFLG | true | Startup area is immediately, but temporarily switched to... taken. 
 the Block determined by the Configuration BTFLG.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_StartUpAreaSelect()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_StartUpAreaSelect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">swap_type</span> :   FLASH_STARTUP_AREA_BLOCK0, FLASH_STARTUP_AREA_BLOCK1 or FLASH_STARTUP_AREA_BTFLG. </li><li bindent="0" vspace="false"><span font="code">is_temporary</span> :   True or false. See table below.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get Flash driver version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Returns version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.flash_on_flash_hp.open" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.flash_on_flash_hp.write" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;write(${instance}.p_ctrl, ${src_address}, ${flash_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.flash_on_flash_hp.read" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest_address}, ${flash_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.driver.flash_on_flash_hp.erase" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${address}, ${num_blocks});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call blankCheck()" id="module.driver.flash_on_flash_hp.blankCheck" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="blankCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;blankCheck(${instance}.p_ctrl, ${address}, ${num_bytes}, ${p_blank_check_result});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.flash_on_flash_hp.infoGet" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.flash_on_flash_hp.close" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.flash_on_flash_hp.statusGet" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;statusGet(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call accessWindowSet()" id="module.driver.flash_on_flash_hp.accessWindowSet" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="accessWindowSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;accessWindowSet(${instance}.p_ctrl, ${start_addr}, ${end_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call accessWindowClear()" id="module.driver.flash_on_flash_hp.accessWindowClear" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="accessWindowClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;accessWindowClear(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call idCodeSet()" id="module.driver.flash_on_flash_hp.idCodeSet" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="idCodeSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;idCodeSet(${instance}.p_ctrl, ${p_id_bytes}, ${mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.flash_on_flash_hp.reset" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateFlashClockFreq()" id="module.driver.flash_on_flash_hp.updateFlashClockFreq" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="updateFlashClockFreq" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;updateFlashClockFreq(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call startupAreaSelect()" id="module.driver.flash_on_flash_hp.startupAreaSelect" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="startupAreaSelect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;startupAreaSelect(${instance}.p_ctrl, ${swap_type}, ${is_temporary});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.flash_on_flash_hp.versionGet" version="1"><moduleRef id="module.driver.flash_on_flash_hp"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.flash_on_flash_hp.callback_def.0" version="1"><moduleRef id="module.driver.flash_on_flash_hp" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.flash.p_callback)}(flash_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.flash_on_flash_lp" /><description>
<![CDATA[<form><p><span color="header" font="header">Flash HAL Module Introduction</span></p><p>There are two separate Flash modules: the r_flash_lp and the r_flash_hp. These modules implement a high-level API for flash memory programming applications. The High-Performance Flash module (Flash_HP) is used for programming the S7 and S5 family of MCUs. The Low-Power Flash module (Flash_LP) is used for programming the S3 and S1 family of MCUs. The two are not interchangeable, although the APIs and other features of the modules are very similar.</p><p><b>Flash HAL Module Features</b></p><p>The Flash HAL modules APIs allow an application to read, write and erase both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts, but the API functions apply to all devices. Key features of the Flash HAL modules include:</p><li bindent="0" vspace="false">Support for both blocking and non-blocking erasing, reading, writing and blank-checking of data flash.</li><li bindent="0" vspace="false">Support for blocking erasing, reading, writing and blank checking of code flash.</li><li bindent="0" vspace="false">Support for callback functions for completion of non-blocking data-flash operations.</li><li bindent="0" vspace="false">Support for access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li><li bindent="0" vspace="false">Support for boot block-swapping which allows safe rewriting of the startup program without first erasing it.</li><p><b>Flash HAL HP Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Flash_HP.</p><p>Legend:</p><p><b>Flash HAL LP Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for the Flash_LP.</p><p>Legend:</p><p><span color="header" font="header">Flash HAL Module Features</span></p><p>The Flash HAL modules APIs allow an application to read, write and erase both the data and ROM flash areas that reside within the MCU. The amount of flash memory available varies across MCU parts, but the API functions apply to all devices. Key features of the Flash HAL modules include:</p><li bindent="0" vspace="false">Support for both blocking and non-blocking erasing, reading, writing and blank-checking of data flash.</li><li bindent="0" vspace="false">Support for blocking erasing, reading, writing and blank checking of code flash.</li><li bindent="0" vspace="false">Support for callback functions for completion of non-blocking data-flash operations.</li><li bindent="0" vspace="false">Support for access window (write protection) for ROM Flash, allowing only specified areas of code flash to be erased or written.</li><li bindent="0" vspace="false">Support for boot block-swapping which allows safe rewriting of the startup program without first erasing it.</li></form>]]>
</description><function display="ssp_err_t (*open) (flash_ctrl_t *const p_ctrl, flash_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">flash_cfg_t</span> :   Pointer to FLASH configuration structure. All elements of this structure must be set by the user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (flash_ctrl_t *const p_ctrl, uint32_t const src_address, uint32_t const flash_address, uint32_t const num_bytes)" id="write"><description>
<![CDATA[<form><p>Write FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Write()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Write()</span></li><p><b>Warning</b></p><p>Specifying a number that is not a multiple of the programming size will result in SF_FLASH_ERR_BYTES being returned and no data written. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">src_address</span> :   Address of the buffer containing the data to write to Flash. </li><li bindent="0" vspace="false"><span font="code">flash_address</span> :   Code Flash or Data Flash address to write. The address must be on a programming line boundary. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   The number of bytes to write. This number must be a multiple of the programming size. For Code Flash this is FLASH_MIN_PGM_SIZE_CF. For Data Flash this is FLASH_MIN_PGM_SIZE_DF. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (flash_ctrl_t *const p_ctrl, uint8_t *const p_dest_address, uint32_t const flash_address, uint32_t const num_bytes)" id="read"><description>
<![CDATA[<form><p>Read FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Read()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">p_dest_address</span> :   Pointer to caller's destination buffer used to hold the data read from Flash. </li><li bindent="0" vspace="false"><span font="code">flash_address</span> :   Code Flash or Data Flash starting address to read from. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   The number of bytes to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (flash_ctrl_t *const p_ctrl, uint32_t const address, uint32_t const num_blocks)" id="erase"><description>
<![CDATA[<form><p>Erase FLASH device. </p><p><b>Implemented as</b></p><p><span font="code">R_FLASH_LP_Erase()</span> <span font="code">R_FLASH_HP_Erase()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device. </li><li bindent="0" vspace="false"><span font="code">address</span> :   The block containing this address is the first block erased. </li><li bindent="0" vspace="false"><span font="code">num_blocks</span> :   Specifies the number of blocks to be erased, the starting block determined by the block_erase_address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*blankCheck) (flash_ctrl_t *const p_ctrl, uint32_t const address, uint32_t const num_bytes, flash_result_t *const p_blank_check_result)" id="blankCheck"><description>
<![CDATA[<form><p>Blank check FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_BlankCheck()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_BlankCheck()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control for the FLASH device context. </li><li bindent="0" vspace="false"><span font="code">address</span> :   The starting address of the Flash area to blank check. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   Specifies the number of bytes that need to be checked. See the specific handler for details. </li><li bindent="0" vspace="false"><span font="code">p_blank_check_result</span> :   Pointer that will be populated by the API with the results of the blank check operation in non-BGO (blocking) mode. In this case the blank check operation completes here and the result is returned. In Data Flash BGO mode the blank check operation is only started here and the result obtained later when the supplied callback routine is called. In this case FLASH_RESULT_BGO_ACTIVE will be returned in p_blank_check_result. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (flash_ctrl_t *const p_ctrl, flash_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Close FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to FLASH info structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (flash_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (flash_ctrl_t *const p_ctrl)" id="statusGet"><description>
<![CDATA[<form><p>Get Status for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_StatusGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_StatusGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*accessWindowSet) (flash_ctrl_t *const p_ctrl, uint32_t const start_addr, uint32_t const end_addr)" id="accessWindowSet"><description>
<![CDATA[<form><p>Set Access Window for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_AccessWindowSet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_AccessWindowSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">start_addr</span> :   Determines the Starting block for the Code Flash access window. </li><li bindent="0" vspace="false"><span font="code">end_addr</span> :   Determines the Ending block for the Code Flash access window. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*accessWindowClear) (flash_ctrl_t *const p_ctrl)" id="accessWindowClear"><description>
<![CDATA[<form><p>Clear any existing Code Flash access window for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_AccessWindowClear()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_AccessWindowClear()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">start_addr</span> :   Determines the Starting block for the Code Flash access window. </li><li bindent="0" vspace="false"><span font="code">end_addr</span> :   Determines the Ending block for the Code Flash access window. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*idCodeSet) (flash_ctrl_t *const p_ctrl, uint8_t const *const p_id_bytes, flash_id_code_mode_t mode)" id="idCodeSet"><description>
<![CDATA[<form><p>Set ID Code for FLASH device. Setting the ID code can restrict access to the device. The ID code will be required to connect to the device. Bits 126 and 127 are set based on the mode. e.g. uint8_t id_bytes[] = {0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0x00}; with mode FLASH_ID_CODE_MODE_LOCKED_WITH_ALL_ERASE_SUPPORT will result in an ID code of 00112233445566778899aabbccddeec0 and with mode FLASH_ID_CODE_MODE_LOCKED will result in an ID code of 00112233445566778899aabbccddee80</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_IdCodeSet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_IdCodeSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">p_id_bytes</span> :   Ponter to the ID Code to be written. </li><li bindent="0" vspace="false"><span font="code">mode</span> :   Mode used for checking the ID code. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (flash_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset function for FLASH device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateFlashClockFreq) (flash_ctrl_t *const p_ctrl)" id="updateFlashClockFreq"><description>
<![CDATA[<form><p>Update Flash clock frequency (FCLK) and recalculate timeout values </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_UpdateFlashClockFreq()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_UpdateFlashClockFreq()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*startupAreaSelect) (flash_ctrl_t *const p_ctrl, flash_startup_area_swap_t swap_type, bool is_temporary)" id="startupAreaSelect"><description>
<![CDATA[<form><p>Select which block - Default (Block 0) or Alternate (Block 1) is used as the start-up area block.  
swap_type | is_temporary | Operation FLASH_STARTUP_AREA_BLOCK0: false On next reset Startup area will be Block 0. 
FLASH_STARTUP_AREA_BLOCK0 | false | On next reset Startup area will be Block 0. Block 0. 
FLASH_STARTUP_AREA_BLOCK1: false On next reset Startup area will be Block 1. 
FLASH_STARTUP_AREA_BLOCK1 | true | Startup area is immediately, but temporarily switched to Block 1. Block 1. 
FLASH_STARTUP_AREA_BTFLG | true | Startup area is immediately, but temporarily switched to... taken. 
 the Block determined by the Configuration BTFLG.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_StartUpAreaSelect()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_StartUpAreaSelect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to FLASH device control. </li><li bindent="0" vspace="false"><span font="code">swap_type</span> :   FLASH_STARTUP_AREA_BLOCK0, FLASH_STARTUP_AREA_BLOCK1 or FLASH_STARTUP_AREA_BTFLG. </li><li bindent="0" vspace="false"><span font="code">is_temporary</span> :   True or false. See table below.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get Flash driver version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_FLASH_LP_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_FLASH_HP_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Returns version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.flash_on_flash_lp.open" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.flash_on_flash_lp.write" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;write(${instance}.p_ctrl, ${src_address}, ${flash_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.flash_on_flash_lp.read" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest_address}, ${flash_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.driver.flash_on_flash_lp.erase" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${address}, ${num_blocks});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call blankCheck()" id="module.driver.flash_on_flash_lp.blankCheck" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="blankCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;blankCheck(${instance}.p_ctrl, ${address}, ${num_bytes}, ${p_blank_check_result});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.flash_on_flash_lp.infoGet" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.flash_on_flash_lp.close" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.flash_on_flash_lp.statusGet" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;statusGet(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call accessWindowSet()" id="module.driver.flash_on_flash_lp.accessWindowSet" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="accessWindowSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;accessWindowSet(${instance}.p_ctrl, ${start_addr}, ${end_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call accessWindowClear()" id="module.driver.flash_on_flash_lp.accessWindowClear" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="accessWindowClear" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;accessWindowClear(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call idCodeSet()" id="module.driver.flash_on_flash_lp.idCodeSet" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="idCodeSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;idCodeSet(${instance}.p_ctrl, ${p_id_bytes}, ${mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.flash_on_flash_lp.reset" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateFlashClockFreq()" id="module.driver.flash_on_flash_lp.updateFlashClockFreq" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="updateFlashClockFreq" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;updateFlashClockFreq(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call startupAreaSelect()" id="module.driver.flash_on_flash_lp.startupAreaSelect" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="startupAreaSelect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;startupAreaSelect(${instance}.p_ctrl, ${swap_type}, ${is_temporary});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.flash_on_flash_lp.versionGet" version="1"><moduleRef id="module.driver.flash_on_flash_lp"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.flash.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.flash_on_flash_lp.callback_def.0" version="1"><moduleRef id="module.driver.flash_on_flash_lp" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.flash.p_callback)}(flash_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.qspi_on_qspi" /><description>
<![CDATA[<form><p><span color="header" font="header">QSPI HAL Module Introduction</span></p><p>The Quad SPI (QSPI) HAL module provides a high-level API for erasing and programming the contents of a QSPI flash device connected to the microcontroller. Unlike many other modules, there is no callback function for the QSPI.</p><p><b>QSPI HAL Module Features</b></p><p>The QSPI HAL Module is used to initialize the QSPI peripheral that allows erasing and programming the contents of a QSPI flash device connected to the microcontroller over the Quad SPI interface. Key features include:</p><li bindent="0" vspace="false">Accessing Quad SPI flash devices using Direct Communication Mode</li><li bindent="0" vspace="false">Reading data from a QSPI flash device</li><li bindent="0" vspace="false">Programming the page of a QSPI flash device</li><li bindent="0" vspace="false">Erasing sectors of a QSPI flash device</li><li bindent="0" vspace="false">Selecting a bank to control access to a QSPI flash device</li><li bindent="0" vspace="false">Accessing Quad SPI flash devices using 3-byte/4-byte Addressing Mode</li><p><b>QSPI Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the QSPI.</p><p>Legend:</p><p><span color="header" font="header">QSPI HAL Module Features</span></p><p>The QSPI HAL Module is used to initialize the QSPI peripheral that allows erasing and programming the contents of a QSPI flash device connected to the microcontroller over the Quad SPI interface. Key features include:</p><li bindent="0" vspace="false">Accessing Quad SPI flash devices using Direct Communication Mode</li><li bindent="0" vspace="false">Reading data from a QSPI flash device</li><li bindent="0" vspace="false">Programming the page of a QSPI flash device</li><li bindent="0" vspace="false">Erasing sectors of a QSPI flash device</li><li bindent="0" vspace="false">Selecting a bank to control access to a QSPI flash device</li><li bindent="0" vspace="false">Accessing Quad SPI flash devices using 3-byte/4-byte Addressing Mode</li></form>]]>
</description><function display="ssp_err_t (*open) (qspi_ctrl_t *p_ctrl, qspi_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open the QSPI driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to a configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (qspi_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the QSPI driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (qspi_ctrl_t *p_ctrl, uint8_t *p_device_address, uint8_t *p_memory_address, uint32_t byte_count)" id="read"><description>
<![CDATA[<form><p>Read a block of data from the flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_device_address</span> :   The location in the flash device address space to read </li><li bindent="0" vspace="false"><span font="code">p_memory_address</span> :   The memory address of a buffer to place the read data in </li><li bindent="0" vspace="false"><span font="code">byte_count</span> :   The number of bytes to read </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pageProgram) (qspi_ctrl_t *p_ctrl, uint8_t *p_device_address, uint8_t *p_memory_address, uint32_t byte_count)" id="pageProgram"><description>
<![CDATA[<form><p>Program a page of data to the flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_PageProgram()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_device_address</span> :   The location in the flash device address space to write the data to </li><li bindent="0" vspace="false"><span font="code">p_memory_address</span> :   The memory address of the data to write to the flash device </li><li bindent="0" vspace="false"><span font="code">byte_count</span> :   The number of bytes to write </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (qspi_ctrl_t *p_ctrl, uint8_t *p_device_address, uint32_t byte_count)" id="erase"><description>
<![CDATA[<form><p>Erase a certain number of bytes of the flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_Erase()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_device_address</span> :   The location in the flash device address space to start the erase from </li><li bindent="0" vspace="false"><span font="code">byte_count</span> :   The number of bytes to erase </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (qspi_ctrl_t *const p_ctrl, qspi_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get information about this specific QSPI flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">qspi_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this QSPI. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*sectorErase) (qspi_ctrl_t *p_ctrl, uint8_t *p_device_address)" id="sectorErase"><description>
<![CDATA[<form><p>Erase a sector of the flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_SectorErase()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_device_address</span> :   The location in the flash device address space to start the erase from </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (qspi_ctrl_t *p_ctrl, bool *p_write_in_progress)" id="statusGet"><description>
<![CDATA[<form><p>Get the write or erase status of the flash. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_StatusGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a driver handle </li><li bindent="0" vspace="false"><span font="code">p_write_in_progress</span> :   The write or erase status - TRUE = write/erase in progress </li><p /></form>]]>
</description></function><function display="ssp_err_t (*bankSelect) (uint32_t bank)" id="bankSelect"><description>
<![CDATA[<form><p>Select the bank to access. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_BankSelect()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">bank</span> :   The bank number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_QSPI_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.qspi_on_qspi.open" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.qspi_on_qspi.close" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.qspi_on_qspi.read" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_device_address}, ${p_memory_address}, ${byte_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pageProgram()" id="module.driver.qspi_on_qspi.pageProgram" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="pageProgram" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;pageProgram(${instance}.p_ctrl, ${p_device_address}, ${p_memory_address}, ${byte_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.driver.qspi_on_qspi.erase" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${p_device_address}, ${byte_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.qspi_on_qspi.infoGet" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call sectorErase()" id="module.driver.qspi_on_qspi.sectorErase" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="sectorErase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;sectorErase(${instance}.p_ctrl, ${p_device_address});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.driver.qspi_on_qspi.statusGet" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_write_in_progress});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call bankSelect()" id="module.driver.qspi_on_qspi.bankSelect" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="bankSelect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;bankSelect(${bank});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.qspi_on_qspi.versionGet" version="1"><moduleRef id="module.driver.qspi_on_qspi"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.qspi.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.sdmmc_on_sdmmc" /><description>
<![CDATA[<form><p><span color="header" font="header">SDMMC HAL Module Introduction</span></p><p>The SDMMC (SD/MMC and SDIO) HAL module is used to read/write and control SDMMC media devices and SDIO cards. The SDMMC module can be used as a standalone SD card, eMMC or media driver, or it can be used with FileX and other compatible file systems. The SDMMC HAL module uses the SDMMC peripheral on the Synergy MCU.</p><p><b>SDMMC HAL Module Features</b></p><li bindent="0" vspace="false">Supports the following memory devices: SDSC (SD Standard Capacity), SDHC (SD High Capacity), SDXC (SD Extended Capacity) and eMMC (embedded Multi Media Card)</li><li bindent="20" vspace="false">Supports reading, writing and erasing SD and eMMC memory devices</li><li bindent="20" vspace="false">Supports 1, 4 or 8-bit data busses (8-bit bus is supported for eMMC only)</li><li bindent="20" vspace="false">Supports detection of hardware write protection (SD cards only)</li><li bindent="20" vspace="false">Automatically selects between backwards compatible mode and high speed SRD mode (eMMC)</li><li bindent="0" vspace="false">Supports SDIO</li><li bindent="20" vspace="false">Supports SDIO single register access (CMD52)</li><li bindent="20" vspace="false">Supports SDIO multiple register access (CMD53)</li><li bindent="20" vspace="false">Supports SDIO interrupts</li><li bindent="20" vspace="false">Automatically configures the clock to the maximum clock rate supported by both host (MCU) and device</li><p><b>SDMMC Hardware Support Details</b></p><p>Legend:</p><p>
 Note: Available on some of the MCUs (for the group indicated in the table) based on the pin map.</p><p><span color="header" font="header">SDMMC HAL Module Features</span></p><li bindent="0" vspace="false">Supports the following memory devices: SDSC (SD Standard Capacity), SDHC (SD High Capacity), SDXC (SD Extended Capacity) and eMMC (embedded Multi Media Card)</li><li bindent="20" vspace="false">Supports reading, writing and erasing SD and eMMC memory devices</li><li bindent="20" vspace="false">Supports 1, 4 or 8-bit data busses (8-bit bus is supported for eMMC only)</li><li bindent="20" vspace="false">Supports detection of hardware write protection (SD cards only)</li><li bindent="20" vspace="false">Automatically selects between backwards compatible mode and high speed SRD mode (eMMC)</li><li bindent="0" vspace="false">Supports SDIO</li><li bindent="20" vspace="false">Supports SDIO single register access (CMD52)</li><li bindent="20" vspace="false">Supports SDIO multiple register access (CMD53)</li><li bindent="20" vspace="false">Supports SDIO interrupts</li><li bindent="20" vspace="false">Automatically configures the clock to the maximum clock rate supported by both host (MCU) and device</li></form>]]>
</description><function display="ssp_err_t (*open) (sdmmc_ctrl_t *const p_ctrl, sdmmc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open an SD/MMC device. If the device is a card, the card must be plugged in prior to calling this API. This API blocks until the device initialization procedure is complete.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Open()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SD/MMC instance configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sdmmc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close open SD/MMC device.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Close()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from an SD/MMC channel. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Read()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to data buffer to read data to. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sdmmc_ctrl_t *const p_ctrl, uint8_t const *const p_source, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to SD/MMC channel. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Write()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_source</span> :   Pointer to data buffer to write data from. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*control) (sdmmc_ctrl_t *const p_ctrl, ssp_command_t const command, void *p_data)" id="control"><description>
<![CDATA[<form><p>The Control function sends control commands to and receives info from the SD/MMC port.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Control()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. The list of supported commands is below. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data in or out. For each command, this data should be cast as follows:</li><li bindent="0" vspace="false">SSP_COMMAND_GET_SECTOR_COUNT : [out] (uint32_t *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_GET_SECTOR_SIZE : [out] (uint32_t *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_GET_WRITE_PROTECTED : [out] (bool *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_SET_BLOCK_SIZE : [in] (uint32_t *) p_data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*readIo) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address)" id="readIo"><description>
<![CDATA[<form><p>Read one byte of I/O data from an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_ReadIo()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to location to store data byte. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeIo) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address, sdmmc_io_write_mode_t const read_after_write)" id="writeIo"><description>
<![CDATA[<form><p>Write one byte of I/O data to an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_WriteIo()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data byte to write. Read data is also provided here if read_after_write is true. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">read_after_write</span> :   Whether or not to read back the same register after writing </li><p /></form>]]>
</description></function><function display="ssp_err_t (*readIoExt) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const function, uint32_t const address, uint32_t *const count, sdmmc_io_transfer_mode_t transfer_mode, sdmmc_io_address_mode_t address_mode)" id="readIoExt"><description>
<![CDATA[<form><p>Read multiple bytes or blocks of I/O data from an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_ReadIoExt()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to data buffer to read data to. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of bytes or blocks to read, maximum 512 bytes or 511 blocks. </li><li bindent="0" vspace="false"><span font="code">transfer_mode</span> :   Byte or block mode </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Fixed or incrementing address mode </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeIoExt) (sdmmc_ctrl_t *const p_ctrl, uint8_t const *const p_source, uint32_t const function, uint32_t const address, uint32_t const count, sdmmc_io_transfer_mode_t transfer_mode, sdmmc_io_address_mode_t address_mode)" id="writeIoExt"><description>
<![CDATA[<form><p>Write multiple bytes or blocks of I/O data to an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_WriteIoExt()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_source</span> :   Pointer to data buffer to write data from. </li><li bindent="0" vspace="false"><span font="code">function_number</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of bytes or blocks to write, maximum 512 bytes or 511 blocks. </li><li bindent="0" vspace="false"><span font="code">transfer_mode</span> :   Byte or block mode </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Fixed or incrementing address mode </li><p /></form>]]>
</description></function><function display="ssp_err_t (*IoIntEnable) (sdmmc_ctrl_t *const p_ctrl, bool enable)" id="IoIntEnable"><description>
<![CDATA[<form><p>Enables SDIO interrupt for SD/MMC instance. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p>R_SDMMC_IoIntEnable</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">enable</span> :   Interrupt enable = true, interrupt disable = false. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Returns the version of the SD/MMC driver.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_VersionGet()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to return version information to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sdmmc_ctrl_t *const p_ctrl, sdmmc_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get SD/MMC device info.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_InfoGet()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to return device information to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (sdmmc_ctrl_t *const p_ctrl, uint32_t const start_sector, uint32_t const sector_count)" id="erase"><description>
<![CDATA[<form><p>Erase SD/MMC sectors. The sector size for erase is fixed at 512 bytes. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p>R_SDMMC_Erase</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector to erase. Must be a multiple of <span font="code">sdmmc_info_t::erase_sector_count</span>. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to erase. Must be a multiple of <span font="code">sdmmc_info_t::erase_sector_count</span>. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.sdmmc_on_sdmmc.open" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.sdmmc_on_sdmmc.close" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.sdmmc_on_sdmmc.read" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.sdmmc_on_sdmmc.write" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_source}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call control()" id="module.driver.sdmmc_on_sdmmc.control" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="control" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;control(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call readIo()" id="module.driver.sdmmc_on_sdmmc.readIo" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="readIo" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;readIo(${instance}.p_ctrl, ${p_data}, ${function}, ${address});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeIo()" id="module.driver.sdmmc_on_sdmmc.writeIo" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="writeIo" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;writeIo(${instance}.p_ctrl, ${p_data}, ${function}, ${address}, ${read_after_write});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call readIoExt()" id="module.driver.sdmmc_on_sdmmc.readIoExt" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="readIoExt" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;readIoExt(${instance}.p_ctrl, ${p_dest}, ${function}, ${address}, ${count}, ${transfer_mode}, ${address_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeIoExt()" id="module.driver.sdmmc_on_sdmmc.writeIoExt" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="writeIoExt" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;writeIoExt(${instance}.p_ctrl, ${p_source}, ${function}, ${address}, ${count}, ${transfer_mode}, ${address_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call IoIntEnable()" id="module.driver.sdmmc_on_sdmmc.IoIntEnable" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="IoIntEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;IoIntEnable(${instance}.p_ctrl, ${enable});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.sdmmc_on_sdmmc.versionGet" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.sdmmc_on_sdmmc.infoGet" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.driver.sdmmc_on_sdmmc.erase" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdmmc.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.sdmmc_on_sdmmc.callback_def.0" version="1"><moduleRef id="module.driver.sdmmc_on_sdmmc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.sdmmc.p_callback)}(sdmmc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.sdio_on_sdmmc" /><description>
<![CDATA[<form><p><span color="header" font="header">SDMMC HAL Module Introduction</span></p><p>The SDMMC (SD/MMC and SDIO) HAL module is used to read/write and control SDMMC media devices and SDIO cards. The SDMMC module can be used as a standalone SD card, eMMC or media driver, or it can be used with FileX and other compatible file systems. The SDMMC HAL module uses the SDMMC peripheral on the Synergy MCU.</p><p><b>SDMMC HAL Module Features</b></p><li bindent="0" vspace="false">Supports the following memory devices: SDSC (SD Standard Capacity), SDHC (SD High Capacity), SDXC (SD Extended Capacity) and eMMC (embedded Multi Media Card)</li><li bindent="20" vspace="false">Supports reading, writing and erasing SD and eMMC memory devices</li><li bindent="20" vspace="false">Supports 1, 4 or 8-bit data busses (8-bit bus is supported for eMMC only)</li><li bindent="20" vspace="false">Supports detection of hardware write protection (SD cards only)</li><li bindent="20" vspace="false">Automatically selects between backwards compatible mode and high speed SRD mode (eMMC)</li><li bindent="0" vspace="false">Supports SDIO</li><li bindent="20" vspace="false">Supports SDIO single register access (CMD52)</li><li bindent="20" vspace="false">Supports SDIO multiple register access (CMD53)</li><li bindent="20" vspace="false">Supports SDIO interrupts</li><li bindent="20" vspace="false">Automatically configures the clock to the maximum clock rate supported by both host (MCU) and device</li><p><b>SDMMC Hardware Support Details</b></p><p>Legend:</p><p>
 Note: Available on some of the MCUs (for the group indicated in the table) based on the pin map.</p><p><span color="header" font="header">SDMMC HAL Module Features</span></p><li bindent="0" vspace="false">Supports the following memory devices: SDSC (SD Standard Capacity), SDHC (SD High Capacity), SDXC (SD Extended Capacity) and eMMC (embedded Multi Media Card)</li><li bindent="20" vspace="false">Supports reading, writing and erasing SD and eMMC memory devices</li><li bindent="20" vspace="false">Supports 1, 4 or 8-bit data busses (8-bit bus is supported for eMMC only)</li><li bindent="20" vspace="false">Supports detection of hardware write protection (SD cards only)</li><li bindent="20" vspace="false">Automatically selects between backwards compatible mode and high speed SRD mode (eMMC)</li><li bindent="0" vspace="false">Supports SDIO</li><li bindent="20" vspace="false">Supports SDIO single register access (CMD52)</li><li bindent="20" vspace="false">Supports SDIO multiple register access (CMD53)</li><li bindent="20" vspace="false">Supports SDIO interrupts</li><li bindent="20" vspace="false">Automatically configures the clock to the maximum clock rate supported by both host (MCU) and device</li></form>]]>
</description><function display="ssp_err_t (*open) (sdmmc_ctrl_t *const p_ctrl, sdmmc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open an SD/MMC device. If the device is a card, the card must be plugged in prior to calling this API. This API blocks until the device initialization procedure is complete.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Open()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SD/MMC instance configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sdmmc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close open SD/MMC device.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Close()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from an SD/MMC channel. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Read()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to data buffer to read data to. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sdmmc_ctrl_t *const p_ctrl, uint8_t const *const p_source, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to SD/MMC channel. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Write()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_source</span> :   Pointer to data buffer to write data from. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*control) (sdmmc_ctrl_t *const p_ctrl, ssp_command_t const command, void *p_data)" id="control"><description>
<![CDATA[<form><p>The Control function sends control commands to and receives info from the SD/MMC port.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_Control()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. The list of supported commands is below. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data in or out. For each command, this data should be cast as follows:</li><li bindent="0" vspace="false">SSP_COMMAND_GET_SECTOR_COUNT : [out] (uint32_t *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_GET_SECTOR_SIZE : [out] (uint32_t *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_GET_WRITE_PROTECTED : [out] (bool *) p_data</li><li bindent="0" vspace="false">SSP_COMMAND_SET_BLOCK_SIZE : [in] (uint32_t *) p_data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*readIo) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address)" id="readIo"><description>
<![CDATA[<form><p>Read one byte of I/O data from an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_ReadIo()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to location to store data byte. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeIo) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_data, uint32_t const function, uint32_t const address, sdmmc_io_write_mode_t const read_after_write)" id="writeIo"><description>
<![CDATA[<form><p>Write one byte of I/O data to an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_WriteIo()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data byte to write. Read data is also provided here if read_after_write is true. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">read_after_write</span> :   Whether or not to read back the same register after writing </li><p /></form>]]>
</description></function><function display="ssp_err_t (*readIoExt) (sdmmc_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const function, uint32_t const address, uint32_t *const count, sdmmc_io_transfer_mode_t transfer_mode, sdmmc_io_address_mode_t address_mode)" id="readIoExt"><description>
<![CDATA[<form><p>Read multiple bytes or blocks of I/O data from an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_ReadIoExt()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to data buffer to read data to. </li><li bindent="0" vspace="false"><span font="code">function</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of bytes or blocks to read, maximum 512 bytes or 511 blocks. </li><li bindent="0" vspace="false"><span font="code">transfer_mode</span> :   Byte or block mode </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Fixed or incrementing address mode </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeIoExt) (sdmmc_ctrl_t *const p_ctrl, uint8_t const *const p_source, uint32_t const function, uint32_t const address, uint32_t const count, sdmmc_io_transfer_mode_t transfer_mode, sdmmc_io_address_mode_t address_mode)" id="writeIoExt"><description>
<![CDATA[<form><p>Write multiple bytes or blocks of I/O data to an SDIO device. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_WriteIoExt()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_source</span> :   Pointer to data buffer to write data from. </li><li bindent="0" vspace="false"><span font="code">function_number</span> :   SDIO Function Number. </li><li bindent="0" vspace="false"><span font="code">address</span> :   SDIO register address. </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of bytes or blocks to write, maximum 512 bytes or 511 blocks. </li><li bindent="0" vspace="false"><span font="code">transfer_mode</span> :   Byte or block mode </li><li bindent="0" vspace="false"><span font="code">address_mode</span> :   Fixed or incrementing address mode </li><p /></form>]]>
</description></function><function display="ssp_err_t (*IoIntEnable) (sdmmc_ctrl_t *const p_ctrl, bool enable)" id="IoIntEnable"><description>
<![CDATA[<form><p>Enables SDIO interrupt for SD/MMC instance. This API is not supported for SD or eMMC memory devices.</p><p><b>Implemented as</b></p><p>R_SDMMC_IoIntEnable</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">enable</span> :   Interrupt enable = true, interrupt disable = false. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Returns the version of the SD/MMC driver.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_VersionGet()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to return version information to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sdmmc_ctrl_t *const p_ctrl, sdmmc_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get SD/MMC device info.</p><p><b>Implemented as</b></p><p><span font="code">R_SDMMC_InfoGet()</span></p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to return device information to. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (sdmmc_ctrl_t *const p_ctrl, uint32_t const start_sector, uint32_t const sector_count)" id="erase"><description>
<![CDATA[<form><p>Erase SD/MMC sectors. The sector size for erase is fixed at 512 bytes. This API is not supported for SDIO devices.</p><p><b>Implemented as</b></p><p>R_SDMMC_Erase</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to an open SD/MMC instance control block. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   First sector to erase. Must be a multiple of <span font="code">sdmmc_info_t::erase_sector_count</span>. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to erase. Must be a multiple of <span font="code">sdmmc_info_t::erase_sector_count</span>. All sectors must be in the range of <span font="code">sdmmc_info_t::sector_count</span>. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.sdio_on_sdmmc.open" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.sdio_on_sdmmc.close" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.sdio_on_sdmmc.read" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.driver.sdio_on_sdmmc.write" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_source}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call control()" id="module.driver.sdio_on_sdmmc.control" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="control" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;control(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call readIo()" id="module.driver.sdio_on_sdmmc.readIo" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="readIo" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;readIo(${instance}.p_ctrl, ${p_data}, ${function}, ${address});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeIo()" id="module.driver.sdio_on_sdmmc.writeIo" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="writeIo" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;writeIo(${instance}.p_ctrl, ${p_data}, ${function}, ${address}, ${read_after_write});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call readIoExt()" id="module.driver.sdio_on_sdmmc.readIoExt" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="readIoExt" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;readIoExt(${instance}.p_ctrl, ${p_dest}, ${function}, ${address}, ${count}, ${transfer_mode}, ${address_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeIoExt()" id="module.driver.sdio_on_sdmmc.writeIoExt" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="writeIoExt" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;writeIoExt(${instance}.p_ctrl, ${p_source}, ${function}, ${address}, ${count}, ${transfer_mode}, ${address_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call IoIntEnable()" id="module.driver.sdio_on_sdmmc.IoIntEnable" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="IoIntEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;IoIntEnable(${instance}.p_ctrl, ${enable});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.sdio_on_sdmmc.versionGet" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.sdio_on_sdmmc.infoGet" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.driver.sdio_on_sdmmc.erase" version="1"><moduleRef id="module.driver.sdio_on_sdmmc"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.sdio.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.sdio_on_sdmmc.callback_def.0" version="1"><moduleRef id="module.driver.sdio_on_sdmmc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.sdio.p_callback)}(sdmmc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.input_capture_on_gpt" /><description>
<![CDATA[<form><p><span color="header" font="header">GPT Input Capture HAL Module Introduction</span></p><p>The Input Capture HAL module provides an API for measuring input pulse-width and pulse-period measurement. The Input Capture HAL module also configures the input capture parameters to use with the GPT peripheral on the Synergy MCU. A user-defined callback can be created to acquire the value each time a new measurement is complete.</p><p><b>GPT Input Capture HAL Module Features</b></p><p>The Input Capture HAL module configures the GPT for an input capture function.</p><li bindent="0" vspace="false">The Input Capture HAL allows the user to perform the following tasks:</li><li bindent="20" vspace="false">Initialize the module</li><li bindent="20" vspace="false">Enable input capture measurement</li><li bindent="20" vspace="false">Disable input capture measurement</li><li bindent="20" vspace="false">Get the status (running or not) of the measurement counter</li><li bindent="20" vspace="false">Get the last captured timer/overflows counter value</li><li bindent="20" vspace="false">Close the input capture operation</li><li bindent="0" vspace="false">The Input Capture HAL module supports:</li><li bindent="20" vspace="false">Pulse-width measurement and pulse-period measurement</li><li bindent="20" vspace="false">Rising-edge or falling-edge measurement start</li><li bindent="20" vspace="false">One-shot or periodic mode</li><li bindent="20" vspace="false">Hardware-enable signals to enable captures (low enable/high enable)</li><li bindent="20" vspace="false">Callback function with the following events:</li><li bindent="40" vspace="false">Counter overflow</li><li bindent="40" vspace="false">Input capture occur</li><li bindent="20" vspace="false">Callback structure (<span font="code">input_capture_callback_args_t</span>) that provides data on the interrupting event, including which interrupt occurs and the associated counter values.</li><p><b>GPT Input Capture Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for GPT_INPUT_CAPTURE.</p><p>Legend:</p><p><span color="header" font="header">GPT Input Capture HAL Module Features</span></p><p>The Input Capture HAL module configures the GPT for an input capture function.</p><li bindent="0" vspace="false">The Input Capture HAL allows the user to perform the following tasks:</li><li bindent="20" vspace="false">Initialize the module</li><li bindent="20" vspace="false">Enable input capture measurement</li><li bindent="20" vspace="false">Disable input capture measurement</li><li bindent="20" vspace="false">Get the status (running or not) of the measurement counter</li><li bindent="20" vspace="false">Get the last captured timer/overflows counter value</li><li bindent="20" vspace="false">Close the input capture operation</li><li bindent="0" vspace="false">The Input Capture HAL module supports:</li><li bindent="20" vspace="false">Pulse-width measurement and pulse-period measurement</li><li bindent="20" vspace="false">Rising-edge or falling-edge measurement start</li><li bindent="20" vspace="false">One-shot or periodic mode</li><li bindent="20" vspace="false">Hardware-enable signals to enable captures (low enable/high enable)</li><li bindent="20" vspace="false">Callback function with the following events:</li><li bindent="40" vspace="false">Counter overflow</li><li bindent="40" vspace="false">Input capture occur</li><li bindent="20" vspace="false">Callback structure (<span font="code">input_capture_callback_args_t</span>) that provides data on the interrupting event, including which interrupt occurs and the associated counter values.</li></form>]]>
</description><function display="ssp_err_t (*open) (input_capture_ctrl_t *const p_ctrl, input_capture_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureOpen()</span></li><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">input_capture_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block: memory allocated by caller, contents filled in by open. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (input_capture_ctrl_t const *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disables input capture measurement. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureDisable()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (input_capture_ctrl_t const *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enables input capture measurement. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureEnable()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureEnable()</span></li><p><b>Note</b></p><p>Interrupts may already be enabled if specified by input_capture_cfg_t::irq_enable. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (input_capture_ctrl_t const *const p_ctrl, input_capture_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Gets the status (running or not) of the measurement counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureInfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureInfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to returned status. Result will be one of input_capture_status_t. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lastCaptureGet) (input_capture_ctrl_t const *const p_ctrl, input_capture_capture_t *const p_counter)" id="lastCaptureGet"><description>
<![CDATA[<form><p>Gets the last captured timer/counter value </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureLastCaptureGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureLastCaptureGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_counter</span> :   Pointer to location to store last captured counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (input_capture_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the input capture operation. Allows driver to be reconfigured, and may reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureClose()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets the version of this API and stores it in structure pointed to by p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureVersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.input_capture_on_gpt.open" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.input_capture_on_gpt.disable" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.input_capture_on_gpt.enable" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.input_capture_on_gpt.infoGet" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lastCaptureGet()" id="module.driver.input_capture_on_gpt.lastCaptureGet" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="lastCaptureGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;lastCaptureGet(${instance}.p_ctrl, ${p_counter});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.input_capture_on_gpt.close" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.input_capture_on_gpt.versionGet" version="1"><moduleRef id="module.driver.input_capture_on_gpt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.input_capture_on_gpt.callback_def.0" version="1"><moduleRef id="module.driver.input_capture_on_gpt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.input_capture.p_callback)}(input_capture_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.input_capture_on_agt" /><description>
<![CDATA[<form><p><span color="header" font="header">Input Capture HAL Module Introduction</span></p><p>The Input Capture HAL module provides an API for measuring input pulse-width, period measurement and event count measurement. The Input Capture HAL module also configures the input capture parameters to use with the AGT peripheral on the Synergy MCU. A user-defined callback can be created to acquire the value each time a new measurement is complete.</p><p><b>Input Capture HAL Module Features</b></p><p>The Input Capture HAL module configures the AGT for an input capture function.</p><li bindent="0" vspace="false">The Input Capture HAL allows the user to perform the following tasks:</li><li bindent="20" vspace="false">Initialize the module</li><li bindent="20" vspace="false">Enable input capture measurement</li><li bindent="20" vspace="false">Disable input capture measurement</li><li bindent="20" vspace="false">Get the status (running or not) of the measurement counter</li><li bindent="20" vspace="false">Get the last captured timer/overflows counter value</li><li bindent="20" vspace="false">Close the input capture operation</li><li bindent="0" vspace="false">The Input Capture HAL module supports:</li><li bindent="20" vspace="false">Pulse-width measurement, period measurement and event count measurement</li><li bindent="20" vspace="false">Rising-edge or falling-edge measurement start</li><li bindent="20" vspace="false">One-shot or periodic mode</li><li bindent="20" vspace="false">Callback function with the following events:</li><li bindent="40" vspace="false">Measurement and overflow interrupt</li><li bindent="40" vspace="false">Capture compare interrupt</li><li bindent="0" vspace="false">Callback structure (<span font="code">input_capture_callback_args_t</span>) that provides data on the interrupting event, including which interrupt occurs and the associated counter values.</li><p><b>AGT Input Capture Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for AGT Input Capture.</p><p>Legend:</p><p><span color="header" font="header">Input Capture HAL Module Features</span></p><p>The Input Capture HAL module configures the AGT for an input capture function.</p><li bindent="0" vspace="false">The Input Capture HAL allows the user to perform the following tasks:</li><li bindent="20" vspace="false">Initialize the module</li><li bindent="20" vspace="false">Enable input capture measurement</li><li bindent="20" vspace="false">Disable input capture measurement</li><li bindent="20" vspace="false">Get the status (running or not) of the measurement counter</li><li bindent="20" vspace="false">Get the last captured timer/overflows counter value</li><li bindent="20" vspace="false">Close the input capture operation</li><li bindent="0" vspace="false">The Input Capture HAL module supports:</li><li bindent="20" vspace="false">Pulse-width measurement, period measurement and event count measurement</li><li bindent="20" vspace="false">Rising-edge or falling-edge measurement start</li><li bindent="20" vspace="false">One-shot or periodic mode</li><li bindent="20" vspace="false">Callback function with the following events:</li><li bindent="40" vspace="false">Measurement and overflow interrupt</li><li bindent="40" vspace="false">Capture compare interrupt</li><li bindent="0" vspace="false">Callback structure (<span font="code">input_capture_callback_args_t</span>) that provides data on the interrupting event, including which interrupt occurs and the associated counter values.</li></form>]]>
</description><function display="ssp_err_t (*open) (input_capture_ctrl_t *const p_ctrl, input_capture_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureOpen()</span></li><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">input_capture_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block: memory allocated by caller, contents filled in by open. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (input_capture_ctrl_t const *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disables input capture measurement. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureDisable()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (input_capture_ctrl_t const *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enables input capture measurement. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureEnable()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureEnable()</span></li><p><b>Note</b></p><p>Interrupts may already be enabled if specified by input_capture_cfg_t::irq_enable. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (input_capture_ctrl_t const *const p_ctrl, input_capture_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Gets the status (running or not) of the measurement counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureInfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureInfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to returned status. Result will be one of input_capture_status_t. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lastCaptureGet) (input_capture_ctrl_t const *const p_ctrl, input_capture_capture_t *const p_counter)" id="lastCaptureGet"><description>
<![CDATA[<form><p>Gets the last captured timer/counter value </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureLastCaptureGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureLastCaptureGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_counter</span> :   Pointer to location to store last captured counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (input_capture_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the input capture operation. Allows driver to be reconfigured, and may reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureClose()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized by <span font="code">input_capture_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets the version of this API and stores it in structure pointed to by p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InputCaptureVersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InputCaptureVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.input_capture_on_agt.open" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.input_capture_on_agt.disable" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.input_capture_on_agt.enable" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.input_capture_on_agt.infoGet" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lastCaptureGet()" id="module.driver.input_capture_on_agt.lastCaptureGet" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="lastCaptureGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;lastCaptureGet(${instance}.p_ctrl, ${p_counter});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.input_capture_on_agt.close" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.input_capture_on_agt.versionGet" version="1"><moduleRef id="module.driver.input_capture_on_agt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.input_capture.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.input_capture_on_agt.callback_def.0" version="1"><moduleRef id="module.driver.input_capture_on_agt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.input_capture.p_callback)}(input_capture_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.rtc_on_rtc" /><description>
<![CDATA[<form><p><span color="header" font="header">RTC HAL Module Introduction</span></p><p>The Real-Time Clock (RTC) HAL module implements a high-level API for real-time timing applications and uses the real-time clock module on a Synergy MCU. The RTC HAL module configures the RTC module and controls clock, calendar and alarm functions. A callback can be used to respond to any of the three supported interrupt types: alarm, periodic, or carry.</p><p><b>RTC HAL Module Features</b></p><li bindent="0" vspace="false">RTC peripheral configuration.</li><li bindent="0" vspace="false">RTC time and date get and set.</li><li bindent="0" vspace="false">RTC time and date alarm get and set.</li><li bindent="0" vspace="false">RTC time counter start and stop.</li><li bindent="0" vspace="false">RTC alarm, periodic, and carry event notification.</li><li bindent="0" vspace="false">RTC event type enable and disable.</li><li bindent="0" vspace="false">RTC event rate configuration.</li><li bindent="0" vspace="false">RTC clock source set and get.</li><li bindent="0" vspace="false">RTC sub-clock error adjustment.</li><li bindent="0" vspace="false">RTC status get.</li><p><b>RTC Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for the RTC.</p><p>Legend:</p><p><span color="header" font="header">RTC HAL Module Features</span></p><li bindent="0" vspace="false">RTC peripheral configuration.</li><li bindent="0" vspace="false">RTC time and date get and set.</li><li bindent="0" vspace="false">RTC time and date alarm get and set.</li><li bindent="0" vspace="false">RTC time counter start and stop.</li><li bindent="0" vspace="false">RTC alarm, periodic, and carry event notification.</li><li bindent="0" vspace="false">RTC event type enable and disable.</li><li bindent="0" vspace="false">RTC event rate configuration.</li><li bindent="0" vspace="false">RTC clock source set and get.</li><li bindent="0" vspace="false">RTC sub-clock error adjustment.</li><li bindent="0" vspace="false">RTC status get.</li></form>]]>
</description><function display="ssp_err_t (*open) (rtc_ctrl_t *const p_ctrl, rtc_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open the RTC driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (rtc_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the RTC driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*configure) (rtc_ctrl_t *const p_ctrl, void *const p_extend)" id="configure"><description>
<![CDATA[<form><p>Configure the RTC driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_Configure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle. </li><li bindent="0" vspace="false"><span font="code">p_extend</span> :   Currently not implemented, pass NULL. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarTimeSet) (rtc_ctrl_t *const p_ctrl, rtc_time_t *p_time, bool clock_start)" id="calendarTimeSet"><description>
<![CDATA[<form><p>Set the calendar time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarTimeSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">p_time</span> :   Pointer to a time structure that contains the time to set </li><li bindent="0" vspace="false"><span font="code">clock_start</span> :   Flag that starts the clock right after it is set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarTimeGet) (rtc_ctrl_t *const p_ctrl, rtc_time_t *p_time)" id="calendarTimeGet"><description>
<![CDATA[<form><p>Get the calendar time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarTimeGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">p_time</span> :   Pointer to a time structure that contains the time to get </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarAlarmSet) (rtc_ctrl_t *const p_ctrl, rtc_alarm_time_t *p_alarm, bool irq_enable_flag)" id="calendarAlarmSet"><description>
<![CDATA[<form><p>Set the calendar alarm time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarAlarmSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">p_alarm</span> :   Pointer to an alarm structure that contains the alarm time to set </li><li bindent="0" vspace="false"><span font="code">irq_enable_flag</span> :   Enable the ALARM irq if set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarAlarmGet) (rtc_ctrl_t *const p_ctrl, rtc_alarm_time_t *p_alarm)" id="calendarAlarmGet"><description>
<![CDATA[<form><p>Get the calendar alarm time. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarAlarmGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">p_alarm</span> :   Pointer to an alarm structure to fill up with the alarm time </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarCounterStart) (rtc_ctrl_t *const p_ctrl)" id="calendarCounterStart"><description>
<![CDATA[<form><p>Start the calendar counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarCounterStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calendarCounterStop) (rtc_ctrl_t *const p_ctrl)" id="calendarCounterStop"><description>
<![CDATA[<form><p>Stop the calendar counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_CalendarCounterStop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*irqEnable) (rtc_ctrl_t *const p_ctrl, rtc_event_t irq)" id="irqEnable"><description>
<![CDATA[<form><p>Enable the alarm irq. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_IrqEnable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*irqDisable) (rtc_ctrl_t *const p_ctrl, rtc_event_t irq)" id="irqDisable"><description>
<![CDATA[<form><p>Disable the alarm irq. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_IrqDisable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*periodicIrqRateSet) (rtc_ctrl_t *const p_ctrl, rtc_periodic_irq_select_t rate)" id="periodicIrqRateSet"><description>
<![CDATA[<form><p>Set the periodic irq rate </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_PeriodicIrqRateSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to RTC device handle </li><li bindent="0" vspace="false"><span font="code">rate</span> :   Rate of periodic interrupts </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (rtc_ctrl_t *p_ctrl, rtc_info_t *p_rtc_info)" id="infoGet"><description>
<![CDATA[<form><p>Return the currently configure clock source for the RTC</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_rtc_info</span> :   Pointer to RTC information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*errorAdjustmentModeSet) (rtc_ctrl_t *p_ctrl, rtc_error_adjustment_mode_cfg_t *p_error_adjustment_mode)" id="errorAdjustmentModeSet"><description>
<![CDATA[<form><p>Set time error adjustment mode.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_ErrorAdjustmentModeSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_error_adjustment_mode</span> :   Pointer to error adjustment mode configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*errorAdjustmentSet) (rtc_ctrl_t *p_ctrl, rtc_error_adjustment_cfg_t *p_error_adjustment_config)" id="errorAdjustmentSet"><description>
<![CDATA[<form><p>Set time error adjustment.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_ErrorAdjustmentSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control handle structure </li><li bindent="0" vspace="false"><span font="code">p_error_adjustment_config</span> :   Pointer to error adjustment structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_RTC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.rtc_on_rtc.open" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.rtc_on_rtc.close" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call configure()" id="module.driver.rtc_on_rtc.configure" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="configure" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;configure(${instance}.p_ctrl, ${p_extend});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarTimeSet()" id="module.driver.rtc_on_rtc.calendarTimeSet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarTimeSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarTimeSet(${instance}.p_ctrl, ${p_time}, ${clock_start});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarTimeGet()" id="module.driver.rtc_on_rtc.calendarTimeGet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarTimeGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarTimeGet(${instance}.p_ctrl, ${p_time});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarAlarmSet()" id="module.driver.rtc_on_rtc.calendarAlarmSet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarAlarmSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarAlarmSet(${instance}.p_ctrl, ${p_alarm}, ${irq_enable_flag});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarAlarmGet()" id="module.driver.rtc_on_rtc.calendarAlarmGet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarAlarmGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarAlarmGet(${instance}.p_ctrl, ${p_alarm});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarCounterStart()" id="module.driver.rtc_on_rtc.calendarCounterStart" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarCounterStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarCounterStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calendarCounterStop()" id="module.driver.rtc_on_rtc.calendarCounterStop" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="calendarCounterStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;calendarCounterStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call irqEnable()" id="module.driver.rtc_on_rtc.irqEnable" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="irqEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;irqEnable(${instance}.p_ctrl, ${irq});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call irqDisable()" id="module.driver.rtc_on_rtc.irqDisable" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="irqDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;irqDisable(${instance}.p_ctrl, ${irq});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call periodicIrqRateSet()" id="module.driver.rtc_on_rtc.periodicIrqRateSet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="periodicIrqRateSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;periodicIrqRateSet(${instance}.p_ctrl, ${rate});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.rtc_on_rtc.infoGet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_rtc_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call errorAdjustmentModeSet()" id="module.driver.rtc_on_rtc.errorAdjustmentModeSet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="errorAdjustmentModeSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;errorAdjustmentModeSet(${instance}.p_ctrl, ${p_error_adjustment_mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call errorAdjustmentSet()" id="module.driver.rtc_on_rtc.errorAdjustmentSet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="errorAdjustmentSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;errorAdjustmentSet(${instance}.p_ctrl, ${p_error_adjustment_config});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.rtc_on_rtc.versionGet" version="1"><moduleRef id="module.driver.rtc_on_rtc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.rtc.name)}.p_api-&gt;versionGet(${version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.rtc_on_rtc.callback_def.0" version="1"><moduleRef id="module.driver.rtc_on_rtc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.rtc.p_callback)}(rtc_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.timer_on_agt" /><description>
<![CDATA[<form><p><span color="header" font="header">AGT HAL Module Introduction</span></p><p>The AGT HAL module implements a high-level API for timing applications and uses the AGT peripheral on a Synergy MCU. A user-defined callback can be created to respond to a timer event.</p><p><b>AGT HAL Module Features</b></p><li bindent="0" vspace="false">Configures a timer for a set period and generates one of the following events when the period expires:</li><li bindent="20" vspace="false">Interrupt the CPU, which calls a user-callback function (if provided)</li><li bindent="20" vspace="false">Toggle a port pin</li><li bindent="20" vspace="false">Transfer data using DMAC/DTC (if configured with transfer interface)</li><li bindent="20" vspace="false">Start another peripheral (if configured with events and peripheral definitions)</li><li bindent="0" vspace="false">Multiple Channels: 16-bit x 2 channels</li><li bindent="20" vspace="false">Channel 1 can be clocked by the channel 0 underflow, creating a cascaded 32-bit timer</li><li bindent="0" vspace="false">Core Clock: Can be clocked using PCLKB, LOCO, or Fsub. When clocked by LOCO or Fsub, it can be used to wake up the MCU from sleep modes</li><p><b>AGT Hardware support details</b></p><p>The following hardware features are, or are not, supported by the SSP for the AGT.</p><p>Legend:</p><p><span color="header" font="header">AGT HAL Module Features</span></p><li bindent="0" vspace="false">Configures a timer for a set period and generates one of the following events when the period expires:</li><li bindent="20" vspace="false">Interrupt the CPU, which calls a user-callback function (if provided)</li><li bindent="20" vspace="false">Toggle a port pin</li><li bindent="20" vspace="false">Transfer data using DMAC/DTC (if configured with transfer interface)</li><li bindent="20" vspace="false">Start another peripheral (if configured with events and peripheral definitions)</li><li bindent="0" vspace="false">Multiple Channels: 16-bit x 2 channels</li><li bindent="20" vspace="false">Channel 1 can be clocked by the channel 0 underflow, creating a cascaded 32-bit timer</li><li bindent="0" vspace="false">Core Clock: Can be clocked using PCLKB, LOCO, or Fsub. When clocked by LOCO or Fsub, it can be used to wake up the MCU from sleep modes</li></form>]]>
</description><function display="ssp_err_t (*open) (timer_ctrl_t *const p_ctrl, timer_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_TimerOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_TimerOpen()</span></li><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">timer_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (timer_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop the counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Stop()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (timer_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start the counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Start()</span></li><p><b>Note</b></p><p>The counter can also be started in the <span font="code">timer_api_t::open</span> function if <span font="code">timer_cfg_t::autostart</span> is true. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (timer_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset the counter to the initial value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*counterGet) (timer_ctrl_t *const p_ctrl, timer_size_t *const p_value)" id="counterGet"><description>
<![CDATA[<form><p>Get current counter value and store it in provided pointer p_value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_CounterGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_CounterGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">p_value</span> :   Pointer to store current counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*periodSet) (timer_ctrl_t *const p_ctrl, timer_size_t const period, timer_unit_t const unit)" id="periodSet"><description>
<![CDATA[<form><p>Set the time until the timer expires. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_PeriodSet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_PeriodSet()</span></li><p><b>Note</b></p><p>Timer expiration may or may not generate a CPU interrupt based on how the timer is configured in <span font="code">timer_api_t::open</span>. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">period</span> :   Time until timer should expire. </li><li bindent="0" vspace="false"><span font="code">unit</span> :   Units of period parameter. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dutyCycleSet) (timer_ctrl_t *const p_ctrl, timer_size_t const duty_cycle, timer_pwm_unit_t const duty_cycle_unit, uint8_t const pin)" id="dutyCycleSet"><description>
<![CDATA[<form><p>Sets the time until the duty cycle expires.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">duty_cycle</span> :   Time until duty cycle should expire. </li><li bindent="0" vspace="false"><span font="code">duty_cycle_unit</span> :   Units of duty_cycle parameter. </li><li bindent="0" vspace="false"><span font="code">pin</span> :   Which output pin to update. Enter the pin number or if pins are identified by letters, enter 0 for A, 1 for B, 2 for C, etc. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (timer_ctrl_t *const p_ctrl, timer_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get the time until the timer expires in clock counts and store it in provided pointer p_period_counts. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (timer_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allows driver to be reconfigured and may reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.timer_on_agt.open" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.timer_on_agt.stop" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.timer_on_agt.start" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.timer_on_agt.reset" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call counterGet()" id="module.driver.timer_on_agt.counterGet" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="counterGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;counterGet(${instance}.p_ctrl, ${p_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call periodSet()" id="module.driver.timer_on_agt.periodSet" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="periodSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;periodSet(${instance}.p_ctrl, ${period}, ${unit});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dutyCycleSet()" id="module.driver.timer_on_agt.dutyCycleSet" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="dutyCycleSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;dutyCycleSet(${instance}.p_ctrl, ${duty_cycle}, ${duty_cycle_unit}, ${pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.timer_on_agt.infoGet" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.timer_on_agt.close" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.timer_on_agt.versionGet" version="1"><moduleRef id="module.driver.timer_on_agt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.timer_on_agt.callback_def.0" version="1"><moduleRef id="module.driver.timer_on_agt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.timer.p_callback)}(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.timer_on_gpt" /><description>
<![CDATA[<form><p><span color="header" font="header">GPT HAL Module Introduction</span></p><p>The General PWM Timer (GPT) HAL module provides a high-level API for timer applications and uses the GPT peripheral on the Synergy MCU. A user-defined callback can be created to respond to a timer event.</p><p><b>GPT HAL Module Features</b></p><p>The GPT HAL module configures a timer to a user-specified period. When the period elapses, any of the following events can occur:</p><li bindent="0" vspace="false">CPU interrupt that calls a user callback function, if provided</li><li bindent="0" vspace="false">Toggle a port pin</li><li bindent="0" vspace="false">Data transfer using DMAC/DTC if configured with Transfer Interface</li><li bindent="0" vspace="false">Starting of another peripheral if configured with events and peripheral definitions</li><p>General PWM Timer (GPT)</p><li bindent="0" vspace="false">PCLKD as core clock</li><li bindent="0" vspace="false">Two I/O pins per channel</li><p><b>GPT Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for GPT.</p><p>Legend:</p><p><span color="header" font="header">GPT HAL Module Features</span></p><p>The GPT HAL module configures a timer to a user-specified period. When the period elapses, any of the following events can occur:</p><li bindent="0" vspace="false">CPU interrupt that calls a user callback function, if provided</li><li bindent="0" vspace="false">Toggle a port pin</li><li bindent="0" vspace="false">Data transfer using DMAC/DTC if configured with Transfer Interface</li><li bindent="0" vspace="false">Starting of another peripheral if configured with events and peripheral definitions</li><p>General PWM Timer (GPT)</p><li bindent="0" vspace="false">PCLKD as core clock</li><li bindent="0" vspace="false">Two I/O pins per channel</li></form>]]>
</description><function display="ssp_err_t (*open) (timer_ctrl_t *const p_ctrl, timer_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_TimerOpen()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_TimerOpen()</span></li><p><b>Note</b></p><p>To reconfigure after calling this function, call <span font="code">timer_api_t::close</span> first. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (timer_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop the counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Stop()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (timer_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start the counter. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Start()</span></li><p><b>Note</b></p><p>The counter can also be started in the <span font="code">timer_api_t::open</span> function if <span font="code">timer_cfg_t::autostart</span> is true. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (timer_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset the counter to the initial value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*counterGet) (timer_ctrl_t *const p_ctrl, timer_size_t *const p_value)" id="counterGet"><description>
<![CDATA[<form><p>Get current counter value and store it in provided pointer p_value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_CounterGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_CounterGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">p_value</span> :   Pointer to store current counter value. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*periodSet) (timer_ctrl_t *const p_ctrl, timer_size_t const period, timer_unit_t const unit)" id="periodSet"><description>
<![CDATA[<form><p>Set the time until the timer expires. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_PeriodSet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_PeriodSet()</span></li><p><b>Note</b></p><p>Timer expiration may or may not generate a CPU interrupt based on how the timer is configured in <span font="code">timer_api_t::open</span>. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">period</span> :   Time until timer should expire. </li><li bindent="0" vspace="false"><span font="code">unit</span> :   Units of period parameter. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dutyCycleSet) (timer_ctrl_t *const p_ctrl, timer_size_t const duty_cycle, timer_pwm_unit_t const duty_cycle_unit, uint8_t const pin)" id="dutyCycleSet"><description>
<![CDATA[<form><p>Sets the time until the duty cycle expires.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">duty_cycle</span> :   Time until duty cycle should expire. </li><li bindent="0" vspace="false"><span font="code">duty_cycle_unit</span> :   Units of duty_cycle parameter. </li><li bindent="0" vspace="false"><span font="code">pin</span> :   Which output pin to update. Enter the pin number or if pins are identified by letters, enter 0 for A, 1 for B, 2 for C, etc. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (timer_ctrl_t *const p_ctrl, timer_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get the time until the timer expires in clock counts and store it in provided pointer p_period_counts. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Collection of information for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (timer_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Allows driver to be reconfigured and may reduce power consumption. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">timer_api_t::open</span> call for this timer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_GPT_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_AGT_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.timer_on_gpt.open" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.timer_on_gpt.stop" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.timer_on_gpt.start" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.timer_on_gpt.reset" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call counterGet()" id="module.driver.timer_on_gpt.counterGet" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="counterGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;counterGet(${instance}.p_ctrl, ${p_value});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call periodSet()" id="module.driver.timer_on_gpt.periodSet" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="periodSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;periodSet(${instance}.p_ctrl, ${period}, ${unit});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dutyCycleSet()" id="module.driver.timer_on_gpt.dutyCycleSet" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="dutyCycleSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;dutyCycleSet(${instance}.p_ctrl, ${duty_cycle}, ${duty_cycle_unit}, ${pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.timer_on_gpt.infoGet" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.timer_on_gpt.close" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.timer_on_gpt.versionGet" version="1"><moduleRef id="module.driver.timer_on_gpt"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.timer.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.timer_on_gpt.callback_def.0" version="1"><moduleRef id="module.driver.timer_on_gpt" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.timer.p_callback)}(timer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.transfer_on_dmac" /><description>
<![CDATA[<form><p><span color="header" font="header">DMAC HAL Module Introduction</span></p><p>The DMAC HAL module provides a high-level API for data-transfer applications and uses the DMAC peripheral on the Synergy MCU. A user-defined callback can be created to inform the CPU when transfer events occur.</p><p><b>DMAC HAL Module Features</b></p><p>The DMAC HAL module moves data from a user-specified source to a user-specified destination when an interrupt or event occurs. The DMAC HAL module supports the following:</p><li bindent="0" vspace="false">DMAC module on a Synergy MCU</li><li bindent="0" vspace="false">Interrupts, if desired</li><li bindent="0" vspace="false">Multiple transfer modes</li><li bindent="20" vspace="false">Single Transfer</li><li bindent="20" vspace="false">Repeat Transfer</li><li bindent="20" vspace="false">Block Transfer</li><li bindent="20" vspace="false">Address increment, decrement, offset addition, or fixed modes</li><li bindent="0" vspace="false">Multiple channels, with the number depending on the MCU used</li><p><b>DMAC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for DMAC.</p><p>Legend:</p><p><span color="header" font="header">DMAC HAL Module Features</span></p><p>The DMAC HAL module moves data from a user-specified source to a user-specified destination when an interrupt or event occurs. The DMAC HAL module supports the following:</p><li bindent="0" vspace="false">DMAC module on a Synergy MCU</li><li bindent="0" vspace="false">Interrupts, if desired</li><li bindent="0" vspace="false">Multiple transfer modes</li><li bindent="20" vspace="false">Single Transfer</li><li bindent="20" vspace="false">Repeat Transfer</li><li bindent="20" vspace="false">Block Transfer</li><li bindent="20" vspace="false">Address increment, decrement, offset addition, or fixed modes</li><li bindent="0" vspace="false">Multiple channels, with the number depending on the MCU used</li></form>]]>
</description><function display="ssp_err_t (*open) (transfer_ctrl_t *const p_ctrl, transfer_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. Enables the transfer if auto_enable is true and p_src, p_dest, and length are valid. Transfers can also be enabled using <span font="code">transfer_api_t::enable</span> or <span font="code">transfer_api_t::reset</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (transfer_ctrl_t *const p_ctrl, void const *p_src, void *p_dest, uint16_t const num_transfers)" id="reset"><description>
<![CDATA[<form><p>Reset source address pointer, destination address pointer, and/or length, keeping all other settings the same. Enable the transfer if p_src, p_dest, and length are valid. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to source. Set to NULL if source pointer should not change. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination. Set to NULL if destination pointer should not change. </li><li bindent="0" vspace="false"><span font="code">num_transfers</span> :   Transfer length in normal mode or number of blocks in block mode. In DMAC only, resets number of repeats (initially stored in <span font="code">transfer_info_t::num_blocks</span>) in repeat mode. Not used in repeat mode for DTC. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (transfer_ctrl_t *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enable transfer. Transfers occur after the activation source event (or when <span font="code">transfer_api_t::start</span> is called if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as activation source). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Enable()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Enable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (transfer_ctrl_t *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disable transfer. Transfers do not occur after the transfer_info_t::activation source event (or when <span font="code">transfer_api_t::start</span> is called if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source). </p><p><b>Note</b></p><p>If a transfer is in progress, it will be completed. Subsequent transfer requests do not cause a transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Disable()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Disable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (transfer_ctrl_t *const p_ctrl, transfer_start_mode_t mode)" id="start"><description>
<![CDATA[<form><p>Start transfer in software. </p><p><b>Warning</b></p><p>Only works if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source. </p><p><b>Note</b></p><p>DTC only supports TRANSFER_START_MODE_SINGLE. DTC does not support TRANSFER_START_MODE_REPEAT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">mode</span> :   Select mode from <span font="code">transfer_start_mode_t</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (transfer_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop transfer in software. The transfer will stop after completion of the current transfer. </p><p><b>Note</b></p><p>Not supported for DTC. </p><p><b>Note</b></p><p>Only applies for transfers started with TRANSFER_START_MODE_REPEAT. </p><p><b>Warning</b></p><p>Only works if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (transfer_ctrl_t *const p_ctrl, transfer_properties_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Provides information about this transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Driver specific information. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (transfer_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Releases hardware lock. This allows a transfer to be reconfigured using <span font="code">transfer_api_t::open</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*blockReset) (transfer_ctrl_t *const p_ctrl, void const *p_src, void *p_dest, uint16_t const length, transfer_size_t size, uint16_t const num_transfers)" id="blockReset"><description>
<![CDATA[<form><p>Reset source address pointer, destination address pointer, and/or length, for block transfer keeping all other settings the same. Enable the transfer if p_src, p_dest, and length are valid. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_BlockReset()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_BlockReset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to source. Set to NULL if source pointer should not change. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination. Set to NULL if destination pointer should not change. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Transfer length in block mode.In DMAC only. </li><li bindent="0" vspace="false"><span font="code">size</span> :   Transfer size in block mode. In DMAC only. </li><li bindent="0" vspace="false"><span font="code">num_transfers</span> :   number of blocks in block mode. In DMAC only. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*Stop_ActivationRequest) (transfer_ctrl_t *const p_ctrl)" id="Stop_ActivationRequest"><description>
<![CDATA[<form><p>Clears the DMA activation request with a DMA dummy transfer as per flowchart in the hardware manual. Implements <span font="code">transfer_api_t::Stop_ActivationRequest</span>. </p><p><b>Note</b></p><p>This function to be used only in scenario when a DMA activation request source might occur in the next request after a DMA transfer completes. If this happens, the DMA transfer starts and the DMA activation request is held in DMAC. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Stop_ActivationRequest()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Stop_ActivationRequest()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.transfer_on_dmac.open" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.transfer_on_dmac.reset" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${num_transfers});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.transfer_on_dmac.enable" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.transfer_on_dmac.disable" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.transfer_on_dmac.start" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;start(${instance}.p_ctrl, ${mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.transfer_on_dmac.stop" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.transfer_on_dmac.infoGet" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.transfer_on_dmac.close" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.transfer_on_dmac.versionGet" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call blockReset()" id="module.driver.transfer_on_dmac.blockReset" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="blockReset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;blockReset(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${length}, ${size}, ${num_transfers});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call Stop_ActivationRequest()" id="module.driver.transfer_on_dmac.Stop_ActivationRequest" version="1"><moduleRef id="module.driver.transfer_on_dmac"><function id="Stop_ActivationRequest" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;Stop_ActivationRequest(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.transfer_on_dmac.callback_def.0" version="1"><moduleRef id="module.driver.transfer_on_dmac" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.transfer.p_callback)}(transfer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.transfer_on_dtc" /><description>
<![CDATA[<form><p><span color="header" font="header">DTC HAL Module Introduction</span></p><p>The Data Transfer Controller (DTC) HAL module provides a high-level API for data-transfer applications and uses the DTC peripheral on the Synergy MCU. A user-defined callback can be created to inform the CPU when transfer events occur.</p><p><b>DTC HAL Module Features</b></p><p>The Data Transfer Controller (DTC) HAL module moves data from a user-specified source to a user-specified destination when an interrupt or event occurs.</p><li bindent="0" vspace="false">Supports the DTC module on a Synergy MCU</li><li bindent="0" vspace="false">Supports interrupts if desired</li><li bindent="0" vspace="false">Supports multiple transfer modes</li><li bindent="20" vspace="false">Single transfer</li><li bindent="20" vspace="false">Repeat transfer</li><li bindent="20" vspace="false">Block transfer</li><li bindent="20" vspace="false">Address increment or fixed modes</li><li bindent="20" vspace="false">Chain transfers</li><li bindent="0" vspace="false">Supports multiple channels (depending on selected implementation)</li><li bindent="20" vspace="false">Number of channels is limited only by the size of the RAM-based vector table</li><p><b>DTC Hardware support details</b></p><p>The following hardware features are, or are not, supported by SSP for DTC.</p><p>Legend:</p><p><span color="header" font="header">DTC HAL Module Features</span></p><p>The Data Transfer Controller (DTC) HAL module moves data from a user-specified source to a user-specified destination when an interrupt or event occurs.</p><li bindent="0" vspace="false">Supports the DTC module on a Synergy MCU</li><li bindent="0" vspace="false">Supports interrupts if desired</li><li bindent="0" vspace="false">Supports multiple transfer modes</li><li bindent="20" vspace="false">Single transfer</li><li bindent="20" vspace="false">Repeat transfer</li><li bindent="20" vspace="false">Block transfer</li><li bindent="20" vspace="false">Address increment or fixed modes</li><li bindent="20" vspace="false">Chain transfers</li><li bindent="0" vspace="false">Supports multiple channels (depending on selected implementation)</li><li bindent="20" vspace="false">Number of channels is limited only by the size of the RAM-based vector table</li></form>]]>
</description><function display="ssp_err_t (*open) (transfer_ctrl_t *const p_ctrl, transfer_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initial configuration. Enables the transfer if auto_enable is true and p_src, p_dest, and length are valid. Transfers can also be enabled using <span font="code">transfer_api_t::enable</span> or <span font="code">transfer_api_t::reset</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Open()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (transfer_ctrl_t *const p_ctrl, void const *p_src, void *p_dest, uint16_t const num_transfers)" id="reset"><description>
<![CDATA[<form><p>Reset source address pointer, destination address pointer, and/or length, keeping all other settings the same. Enable the transfer if p_src, p_dest, and length are valid. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Reset()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to source. Set to NULL if source pointer should not change. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination. Set to NULL if destination pointer should not change. </li><li bindent="0" vspace="false"><span font="code">num_transfers</span> :   Transfer length in normal mode or number of blocks in block mode. In DMAC only, resets number of repeats (initially stored in <span font="code">transfer_info_t::num_blocks</span>) in repeat mode. Not used in repeat mode for DTC. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enable) (transfer_ctrl_t *const p_ctrl)" id="enable"><description>
<![CDATA[<form><p>Enable transfer. Transfers occur after the activation source event (or when <span font="code">transfer_api_t::start</span> is called if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as activation source). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Enable()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Enable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disable) (transfer_ctrl_t *const p_ctrl)" id="disable"><description>
<![CDATA[<form><p>Disable transfer. Transfers do not occur after the transfer_info_t::activation source event (or when <span font="code">transfer_api_t::start</span> is called if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source). </p><p><b>Note</b></p><p>If a transfer is in progress, it will be completed. Subsequent transfer requests do not cause a transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Disable()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Disable()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (transfer_ctrl_t *const p_ctrl, transfer_start_mode_t mode)" id="start"><description>
<![CDATA[<form><p>Start transfer in software. </p><p><b>Warning</b></p><p>Only works if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source. </p><p><b>Note</b></p><p>DTC only supports TRANSFER_START_MODE_SINGLE. DTC does not support TRANSFER_START_MODE_REPEAT. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Start()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">mode</span> :   Select mode from <span font="code">transfer_start_mode_t</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (transfer_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop transfer in software. The transfer will stop after completion of the current transfer. </p><p><b>Note</b></p><p>Not supported for DTC. </p><p><b>Note</b></p><p>Only applies for transfers started with TRANSFER_START_MODE_REPEAT. </p><p><b>Warning</b></p><p>Only works if ELC_EVENT_ELC_SOFTWARE_EVENT_0 or ELC_EVENT_ELC_SOFTWARE_EVENT_0 is chosen as transfer_info_t::activation_source. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (transfer_ctrl_t *const p_ctrl, transfer_properties_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Provides information about this transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_InfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Driver specific information. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (transfer_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Releases hardware lock. This allows a transfer to be reconfigured using <span font="code">transfer_api_t::open</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_Close()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DTC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">R_DMAC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*blockReset) (transfer_ctrl_t *const p_ctrl, void const *p_src, void *p_dest, uint16_t const length, transfer_size_t size, uint16_t const num_transfers)" id="blockReset"><description>
<![CDATA[<form><p>Reset source address pointer, destination address pointer, and/or length, for block transfer keeping all other settings the same. Enable the transfer if p_src, p_dest, and length are valid. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_BlockReset()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_BlockReset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to source. Set to NULL if source pointer should not change. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination. Set to NULL if destination pointer should not change. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Transfer length in block mode.In DMAC only. </li><li bindent="0" vspace="false"><span font="code">size</span> :   Transfer size in block mode. In DMAC only. </li><li bindent="0" vspace="false"><span font="code">num_transfers</span> :   number of blocks in block mode. In DMAC only. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*Stop_ActivationRequest) (transfer_ctrl_t *const p_ctrl)" id="Stop_ActivationRequest"><description>
<![CDATA[<form><p>Clears the DMA activation request with a DMA dummy transfer as per flowchart in the hardware manual. Implements <span font="code">transfer_api_t::Stop_ActivationRequest</span>. </p><p><b>Note</b></p><p>This function to be used only in scenario when a DMA activation request source might occur in the next request after a DMA transfer completes. If this happens, the DMA transfer starts and the DMA activation request is held in DMAC. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_DMAC_Stop_ActivationRequest()</span></li><li bindent="0" vspace="false"><span font="code">R_DTC_Stop_ActivationRequest()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control block set in <span font="code">transfer_api_t::open</span> call for this transfer. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.transfer_on_dtc.open" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.driver.transfer_on_dtc.reset" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${num_transfers});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enable()" id="module.driver.transfer_on_dtc.enable" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="enable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;enable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disable()" id="module.driver.transfer_on_dtc.disable" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="disable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;disable(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.transfer_on_dtc.start" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;start(${instance}.p_ctrl, ${mode});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.transfer_on_dtc.stop" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.driver.transfer_on_dtc.infoGet" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.transfer_on_dtc.close" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.transfer_on_dtc.versionGet" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call blockReset()" id="module.driver.transfer_on_dtc.blockReset" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="blockReset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;blockReset(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${length}, ${size}, ${num_transfers});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call Stop_ActivationRequest()" id="module.driver.transfer_on_dtc.Stop_ActivationRequest" version="1"><moduleRef id="module.driver.transfer_on_dtc"><function id="Stop_ActivationRequest" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.transfer.name)}.p_api-&gt;Stop_ActivationRequest(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.transfer_on_dtc.callback_def.0" version="1"><moduleRef id="module.driver.transfer_on_dtc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.driver.transfer.p_callback)}(transfer_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.ptp_on_ptp" /><description>
<![CDATA[<form><p><span color="header" font="header">Precision Time Protocol HAL Module Introduction</span></p><p>The PTP HAL Module provides high-level APIs for the time synchronization using the PTP function of the EPTPC peripheral module (EPTPC) on the synergy MCU. A user callback can be created to indicate the occurrence of pulse output timer event or the state change of  Synchronous Frame Processing units(SYNFP0 and SYNFP1), Statistical Time Correction Algorithm(STCA), or Packet Relation Controller unit(PRC-TC).</p><p><b>Precision Time Protocol HAL Module Features</b></p><p>The PTP HAL module configures the PTP for time synchronization functionality.</p><p>The PTP HAL allows the user to perform the following operations:</p><li bindent="0" vspace="false">Set and get local clock counter value.</li><li bindent="0" vspace="false">Set and get master port ID.</li><li bindent="0" vspace="false">Set and get PTP message reception configuration.</li><li bindent="0" vspace="false">Update PTP message information.</li><li bindent="0" vspace="false">Get offset from master and mean path delay values.</li><li bindent="0" vspace="false">Collecting gradient differences and extracting the worst ten values by hardware and software.</li><li bindent="0" vspace="false">Set start time, period, and pulse width of pulse output timer.</li><li bindent="0" vspace="false">Indicate and auto-clear pulse output event signals to the ELC.</li><li bindent="0" vspace="false">Enable and disable INFABT status notification.</li><p><b>Precision Time Protocol Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for PTP.</p><p>Legend:</p><p><span color="header" font="header">Precision Time Protocol HAL Module Features</span></p><p>The PTP HAL module configures the PTP for time synchronization functionality.</p><p>The PTP HAL allows the user to perform the following operations:</p><li bindent="0" vspace="false">Set and get local clock counter value.</li><li bindent="0" vspace="false">Set and get master port ID.</li><li bindent="0" vspace="false">Set and get PTP message reception configuration.</li><li bindent="0" vspace="false">Update PTP message information.</li><li bindent="0" vspace="false">Get offset from master and mean path delay values.</li><li bindent="0" vspace="false">Collecting gradient differences and extracting the worst ten values by hardware and software.</li><li bindent="0" vspace="false">Set start time, period, and pulse width of pulse output timer.</li><li bindent="0" vspace="false">Indicate and auto-clear pulse output event signals to the ELC.</li><li bindent="0" vspace="false">Enable and disable INFABT status notification.</li></form>]]>
</description><function display="ssp_err_t (*open) (ptp_ctrl_t *const p_ctrl, ptp_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open the PTP driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to a configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (ptp_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the PTP driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*configure) (ptp_ctrl_t *const p_ctrl, uint32_t *p_ip_address, uint32_t *p_physical_address_msw, uint32_t *p_physical_address_lsw)" id="configure"><description>
<![CDATA[<form><p>Configures the PTP driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_Configure()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_ip_address</span> :   Pointer to the IP address </li><li bindent="0" vspace="false"><span font="code">p_physical_address_msw</span> :   Pointer to the higher bits of physical address </li><li bindent="0" vspace="false"><span font="code">p_physical_address_lsw</span> :   Pointer to the lower bits of physical address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setExtPromiscuous) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, bool is_set)" id="setExtPromiscuous"><description>
<![CDATA[<form><p>Sets or clears the extended promiscuous mode </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetExtPromiscuous()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">is_set</span> :   Set/clear extended promiscuous mode </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setLocalClock) (ptp_ctrl_t *const p_ctrl, ptp_timestamp_t *p_clock)" id="setLocalClock"><description>
<![CDATA[<form><p>Sets local clock counter </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetLocalClock()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_clock</span> :   Pointer to local clock counter </li><p /></form>]]>
</description></function><function display="ssp_err_t (*getLocalClock) (ptp_ctrl_t *const p_ctrl, ptp_timestamp_t *p_clock, uint32_t wait_option)" id="getLocalClock"><description>
<![CDATA[<form><p>Gets local clock counter </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_GetLocalClock()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Time out interval </li><li bindent="0" vspace="false"><span font="code">p_clock</span> :   Pointer to local clock counter </li><p /></form>]]>
</description></function><function display="ssp_err_t (*getMasterPortID) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, uint32_t *p_clock, uint16_t *p_port)" id="getMasterPortID"><description>
<![CDATA[<form><p>Gets master port ID </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_GetMasterPortID()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_clock</span> :   Pointer to local clock counter </li><li bindent="0" vspace="false"><span font="code">p_port</span> :   Pointer to master port </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setMasterPortID) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, uint32_t *p_clock, uint16_t *p_port)" id="setMasterPortID"><description>
<![CDATA[<form><p>Sets master port ID </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetMasterPortID()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_clock</span> :   Pointer to local clock counter </li><li bindent="0" vspace="false"><span font="code">p_port</span> :   Pointer to master port </li><p /></form>]]>
</description></function><function display="ssp_err_t (*getSyncInfo) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, ptp_timeInterval_t *p_master_offset, ptp_timeInterval_t *p_path_delay)" id="getSyncInfo"><description>
<![CDATA[<form><p>Get current offsetFromMaster and meanPathDelay. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_GetSyncInfo()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_master_offset</span> :   Returns the offset from master </li><li bindent="0" vspace="false"><span font="code">p_path_delay</span> :   Returns the mean path delay </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (ptp_ctrl_t *const p_ctrl, uint32_t wait_option)" id="start"><description>
<![CDATA[<form><p>Starts the time synchronization. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Timeout interval </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (ptp_ctrl_t *const p_ctrl, uint32_t wait_option)" id="stop"><description>
<![CDATA[<form><p>Stops the time synchronization. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Timeout interval </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setWorst10Values) (ptp_ctrl_t *const p_ctrl, uint8_t interval)" id="setWorst10Values"><description>
<![CDATA[<form><p>Sets the time interval for collecting worst 10 values </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetWorst10Values()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">interval</span> :   Time interval to collect worst 10 values </li><p /></form>]]>
</description></function><function display="ssp_err_t (*checkWorst10Values) (ptp_ctrl_t *const p_ctrl, uint32_t wait_option)" id="checkWorst10Values"><description>
<![CDATA[<form><p>Checks worst 10 values by hardware and set as gradient limits. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_CheckWorst10Values()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Timeout interval </li><p /></form>]]>
</description></function><function display="ssp_err_t (*getWorst10Values) (ptp_ctrl_t *const p_ctrl, uint32_t *p_positive_worst10, uint32_t *p_negative_worst10, uint32_t wait_option)" id="getWorst10Values"><description>
<![CDATA[<form><p>Get worst 10 values by software. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_GetWorst10Values()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Timeout interval </li><li bindent="0" vspace="false"><span font="code">p_positive_worst10</span> :   Returns the positive worst 10 values </li><li bindent="0" vspace="false"><span font="code">p_negative_worst10</span> :   Returns the negative worst 10 values </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setGradientLimit) (ptp_ctrl_t *const p_ctrl, uint32_t *p_positive_limit, uint32_t *p_negative_limit)" id="setGradientLimit"><description>
<![CDATA[<form><p>Set the gradient limits for positive and negative worst 10 values. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetGradientLimit()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_positive_limit</span> :   Positive limit of worst 10 values </li><li bindent="0" vspace="false"><span font="code">p_negative_limit</span> :   Negative limit of worst 10 values </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateClockID) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, int8_t *p_clock_id)" id="updateClockID"><description>
<![CDATA[<form><p>Update the clock identity field. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateClockID()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_clock_id</span> :   Pointer to clock ID </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateDomainNumber) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, uint8_t domain_num)" id="updateDomainNumber"><description>
<![CDATA[<form><p>Update the domain number field in the message header. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateDomainNumber()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">domain_num</span> :   Domain number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateAnnounceFlags) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, ptp_announce_flag_t *p_flag)" id="updateAnnounceFlags"><description>
<![CDATA[<form><p>Update the announce message's flag field. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateAnnounceFlags()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_flag</span> :   Pointer to announce message flag field </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateAnnounceMsgs) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, ptp_announce_message_t *p_message)" id="updateAnnounceMsgs"><description>
<![CDATA[<form><p>Update the announce message's message field. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateAnnounceMsgs()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_message</span> :   Pointer to announce message field </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateSyncAnnounceMsgInterval) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, int8_t *p_sync_interval, int8_t *p_announce_interval)" id="updateSyncAnnounceMsgInterval"><description>
<![CDATA[<form><p>Update transmission interval and logMessageInterval of Sync and Announce messages. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateSyncAnnounceMsgInterval()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_sync_interval</span> :   Pointer to sync message interval </li><li bindent="0" vspace="false"><span font="code">p_announce_interval</span> :   Pointer to announce message interval </li><p /></form>]]>
</description></function><function display="ssp_err_t (*updateDelayMsgInterval) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, int8_t *p_interval, uint32_t *p_timeout)" id="updateDelayMsgInterval"><description>
<![CDATA[<form><p>Update transmission interval, logMessageInterval and timeout values of Delay messages. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_UpdateDelayMsgInterval()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_interval</span> :   Case of master: Delay_Resp logMessageInterval Case of slave: Delay_Req/Pdelay_Req transmission interval </li><li bindent="0" vspace="false"><span font="code">p_timeout</span> :   Delay_Resp/Pdelay_Resp receiving timeout </li><p /></form>]]>
</description></function><function display="ssp_err_t (*getMessageReceptionConfig) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, ptp_message_reception_t *p_ptp_message_reception)" id="getMessageReceptionConfig"><description>
<![CDATA[<form><p>Get message reception configuration </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_GetMessageReceptionConfig()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_ptp_message_reception</span> :   Pointer to SYNFP message reception configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setMessageReceptionConfig) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, ptp_message_reception_t *p_ptp_message_reception)" id="setMessageReceptionConfig"><description>
<![CDATA[<form><p>Set message reception configuration. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetMessageReceptionConfig()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_ptp_message_reception</span> :   Pointer to SYNFP message reception config structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disableTimer) (ptp_ctrl_t *const p_ctrl, ptp_stca_timer_channel_t timer_channel)" id="disableTimer"><description>
<![CDATA[<form><p>Disable timer event interrupt. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_DisableTimer()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">timer_channel</span> :   STCA pulse output timer channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*indicateEvent) (ptp_ctrl_t *const p_ctrl, ptp_stca_timer_channel_t timer_channel, ptp_stca_timer_pulse_edge_t timer_pulse_edge, bool is_set)" id="indicateEvent"><description>
<![CDATA[<form><p>Set/clear interrupt indication to ELC output on generation of pulse produced by pulse output timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_IndicateEvent()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">timer_channel</span> :   STCA pulse output timer channel </li><li bindent="0" vspace="false"><span font="code">timer_pulse_edge</span> :   STCA pulse output timer pulse edge </li><li bindent="0" vspace="false"><span font="code">is_set</span> :   Set or clear indication of </li><p /></form>]]>
</description></function><function display="ssp_err_t (*autoClearEvent) (ptp_ctrl_t *const p_ctrl, ptp_stca_timer_channel_t timer_channel, ptp_stca_timer_pulse_edge_t timer_pulse_edge, bool is_set)" id="autoClearEvent"><description>
<![CDATA[<form><p>Set/clear auto clear mode for enabling one time output of ELC event. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_AutoClearEvent()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">timer_channel</span> :   STCA pulse output timer channel </li><li bindent="0" vspace="false"><span font="code">timer_pulse_edge</span> :   STCA pulse output timer edge </li><li bindent="0" vspace="false"><span font="code">is_set</span> :   Enable or disable automatic clearing of event </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setTimer) (ptp_ctrl_t *const p_ctrl, uint8_t timer_channel, UInt64_t event, uint32_t cycle, uint32_t pulse_width)" id="setTimer"><description>
<![CDATA[<form><p>Sets start time, pulse period and pulse width for the pulse output timer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetTimer()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">timer_channel</span> :   STCA pulse output timer channel </li><li bindent="0" vspace="false"><span font="code">event</span> :   Timer event start time </li><li bindent="0" vspace="false"><span font="code">cycle</span> :   Pulse output cycle interval </li><li bindent="0" vspace="false"><span font="code">pulse_width</span> :   Width of the high level of the pulse signal </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setMINTevent) (ptp_ctrl_t *const p_ctrl, ptp_event_t ptp_reg, uint32_t event, bool is_set)" id="setMINTevent"><description>
<![CDATA[<form><p>Set MINT interrupt event to enable notification for change in state of modules. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_SetMINTevent()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_reg</span> :   MINT interrupt register </li><li bindent="0" vspace="false"><span font="code">event</span> :   Interrupt element </li><li bindent="0" vspace="false"><span font="code">is_set</span> :   Set or clear MINT event </li><p /></form>]]>
</description></function><function display="ssp_err_t (*enableINFABTnotification) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel)" id="enableINFABTnotification"><description>
<![CDATA[<form><p>Enable EPTPC INFABT notification </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_EnableINFABTnotification()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disableINFABTnotification) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel)" id="disableINFABTnotification"><description>
<![CDATA[<form><p>Disable EPTPC INFABT notification </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_DisableINFABTnotification()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*checkINFABTstatus) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel, uint8_t *p_status)" id="checkINFABTstatus"><description>
<![CDATA[<form><p>Checks the status of INFABT flag </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_CheckINFABTstatus()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Returns status of INFABT flag </li><p /></form>]]>
</description></function><function display="ssp_err_t (*clearINFABTstatus) (ptp_ctrl_t *const p_ctrl, uint8_t ptp_channel)" id="clearINFABTstatus"><description>
<![CDATA[<form><p>Clear INFABT interrupt occurrence flag. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_ClearINFABTstatus()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">ptp_channel</span> :   EPTPC channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTP_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.ptp_on_ptp.open" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.ptp_on_ptp.close" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call configure()" id="module.driver.ptp_on_ptp.configure" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="configure" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;configure(${instance}.p_ctrl, ${p_ip_address}, ${p_physical_address_msw}, ${p_physical_address_lsw});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setExtPromiscuous()" id="module.driver.ptp_on_ptp.setExtPromiscuous" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setExtPromiscuous" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setExtPromiscuous(${instance}.p_ctrl, ${ptp_channel}, ${is_set});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setLocalClock()" id="module.driver.ptp_on_ptp.setLocalClock" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setLocalClock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setLocalClock(${instance}.p_ctrl, ${p_clock});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call getLocalClock()" id="module.driver.ptp_on_ptp.getLocalClock" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="getLocalClock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;getLocalClock(${instance}.p_ctrl, ${p_clock}, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call getMasterPortID()" id="module.driver.ptp_on_ptp.getMasterPortID" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="getMasterPortID" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;getMasterPortID(${instance}.p_ctrl, ${ptp_channel}, ${p_clock}, ${p_port});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setMasterPortID()" id="module.driver.ptp_on_ptp.setMasterPortID" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setMasterPortID" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setMasterPortID(${instance}.p_ctrl, ${ptp_channel}, ${p_clock}, ${p_port});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call getSyncInfo()" id="module.driver.ptp_on_ptp.getSyncInfo" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="getSyncInfo" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;getSyncInfo(${instance}.p_ctrl, ${ptp_channel}, ${p_master_offset}, ${p_path_delay});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.driver.ptp_on_ptp.start" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;start(${instance}.p_ctrl, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.driver.ptp_on_ptp.stop" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;stop(${instance}.p_ctrl, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setWorst10Values()" id="module.driver.ptp_on_ptp.setWorst10Values" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setWorst10Values" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setWorst10Values(${instance}.p_ctrl, ${interval});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call checkWorst10Values()" id="module.driver.ptp_on_ptp.checkWorst10Values" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="checkWorst10Values" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;checkWorst10Values(${instance}.p_ctrl, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call getWorst10Values()" id="module.driver.ptp_on_ptp.getWorst10Values" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="getWorst10Values" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;getWorst10Values(${instance}.p_ctrl, ${p_positive_worst10}, ${p_negative_worst10}, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setGradientLimit()" id="module.driver.ptp_on_ptp.setGradientLimit" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setGradientLimit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setGradientLimit(${instance}.p_ctrl, ${p_positive_limit}, ${p_negative_limit});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateClockID()" id="module.driver.ptp_on_ptp.updateClockID" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateClockID" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateClockID(${instance}.p_ctrl, ${ptp_channel}, ${p_clock_id});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateDomainNumber()" id="module.driver.ptp_on_ptp.updateDomainNumber" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateDomainNumber" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateDomainNumber(${instance}.p_ctrl, ${ptp_channel}, ${domain_num});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateAnnounceFlags()" id="module.driver.ptp_on_ptp.updateAnnounceFlags" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateAnnounceFlags" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateAnnounceFlags(${instance}.p_ctrl, ${ptp_channel}, ${p_flag});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateAnnounceMsgs()" id="module.driver.ptp_on_ptp.updateAnnounceMsgs" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateAnnounceMsgs" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateAnnounceMsgs(${instance}.p_ctrl, ${ptp_channel}, ${p_message});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateSyncAnnounceMsgInterval()" id="module.driver.ptp_on_ptp.updateSyncAnnounceMsgInterval" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateSyncAnnounceMsgInterval" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateSyncAnnounceMsgInterval(${instance}.p_ctrl, ${ptp_channel}, ${p_sync_interval}, ${p_announce_interval});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call updateDelayMsgInterval()" id="module.driver.ptp_on_ptp.updateDelayMsgInterval" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="updateDelayMsgInterval" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;updateDelayMsgInterval(${instance}.p_ctrl, ${ptp_channel}, ${p_interval}, ${p_timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call getMessageReceptionConfig()" id="module.driver.ptp_on_ptp.getMessageReceptionConfig" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="getMessageReceptionConfig" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;getMessageReceptionConfig(${instance}.p_ctrl, ${ptp_channel}, ${p_ptp_message_reception});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setMessageReceptionConfig()" id="module.driver.ptp_on_ptp.setMessageReceptionConfig" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setMessageReceptionConfig" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setMessageReceptionConfig(${instance}.p_ctrl, ${ptp_channel}, ${p_ptp_message_reception});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disableTimer()" id="module.driver.ptp_on_ptp.disableTimer" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="disableTimer" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;disableTimer(${instance}.p_ctrl, ${timer_channel});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call indicateEvent()" id="module.driver.ptp_on_ptp.indicateEvent" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="indicateEvent" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;indicateEvent(${instance}.p_ctrl, ${timer_channel}, ${timer_pulse_edge}, ${is_set});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call autoClearEvent()" id="module.driver.ptp_on_ptp.autoClearEvent" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="autoClearEvent" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;autoClearEvent(${instance}.p_ctrl, ${timer_channel}, ${timer_pulse_edge}, ${is_set});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setTimer()" id="module.driver.ptp_on_ptp.setTimer" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setTimer" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setTimer(${instance}.p_ctrl, ${timer_channel}, ${event}, ${cycle}, ${pulse_width});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setMINTevent()" id="module.driver.ptp_on_ptp.setMINTevent" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="setMINTevent" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;setMINTevent(${instance}.p_ctrl, ${ptp_reg}, ${event}, ${is_set});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call enableINFABTnotification()" id="module.driver.ptp_on_ptp.enableINFABTnotification" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="enableINFABTnotification" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;enableINFABTnotification(${instance}.p_ctrl, ${ptp_channel});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disableINFABTnotification()" id="module.driver.ptp_on_ptp.disableINFABTnotification" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="disableINFABTnotification" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;disableINFABTnotification(${instance}.p_ctrl, ${ptp_channel});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call checkINFABTstatus()" id="module.driver.ptp_on_ptp.checkINFABTstatus" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="checkINFABTstatus" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;checkINFABTstatus(${instance}.p_ctrl, ${ptp_channel}, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call clearINFABTstatus()" id="module.driver.ptp_on_ptp.clearINFABTstatus" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="clearINFABTstatus" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;clearINFABTstatus(${instance}.p_ctrl, ${ptp_channel});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.ptp_on_ptp.versionGet" version="1"><moduleRef id="module.driver.ptp_on_ptp"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptp.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.ptp_on_ptp.callback_def.0" version="1"><moduleRef id="module.driver.ptp_on_ptp" /><content>/* Callback function */
ssp_err_t ${callback_function:synergyProperty(module.driver.ptp.p_callback)}(ptp_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.driver.ptpedmac_on_ptpedmac" /><description>
<![CDATA[<form><p><span color="header" font="header">PTPEDMAC HAL Module Introduction</span></p><p>The PTPEDMAC HAL Module provides high-level APIs for message transmission using a DMA controller for EPTPC peripheral in synergy MCU. A user callback can be created to indicate the occurrence of frame receive complete event, frame transmit complete event, or error event.</p><p><b>PTPEDMAC HAL Module Features</b></p><p>The PTPEDMAC HAL module configures PTPEDMAC for data transmission and reception of PTP messages.</p><p>The PTPEDMAC HAL allows the user to perform the following operations:</p><li bindent="0" vspace="false">Link the PTP host interface to transmit and receive PTP messages.</li><li bindent="0" vspace="false">Check the communication status.</li><li bindent="0" vspace="false">Read PTP messages.</li><p><b>PTPEDMAC Hardware Support Details</b></p><p>The following hardware features are, or are not, supported by SSP for PTPEDMAC.</p><p>Legend:</p><p><span color="header" font="header">PTPEDMAC HAL Module Features</span></p><p>The PTPEDMAC HAL module configures PTPEDMAC for data transmission and reception of PTP messages.</p><p>The PTPEDMAC HAL allows the user to perform the following operations:</p><li bindent="0" vspace="false">Link the PTP host interface to transmit and receive PTP messages.</li><li bindent="0" vspace="false">Check the communication status.</li><li bindent="0" vspace="false">Read PTP messages.</li></form>]]>
</description><function display="ssp_err_t (*open) (ptpedmac_ctrl_t *const p_ctrl, ptpedmac_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open the PTPEDMAC driver module for reception of PTP messages. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linkProcess) (ptpedmac_ctrl_t *const p_api_ctrl)" id="linkProcess"><description>
<![CDATA[<form><p>Sets host interface to transfer PTP messages </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_LinkProcess()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linkCheck) (ptpedmac_ctrl_t *const p_ctrl)" id="linkCheck"><description>
<![CDATA[<form><p>Checks host interface communication status </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_CheckLink()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (ptpedmac_ctrl_t *const p_ctrl, uint32_t *p_channel, void *const p_buffer, int32_t *p_num_received)" id="read"><description>
<![CDATA[<form><p>Receives PTP message </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_Read()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><li bindent="0" vspace="false"><span font="code">p_channel</span> :   Pointer to received channel </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to received data buffer </li><li bindent="0" vspace="false"><span font="code">p_num_received</span> :   Pointer to number of received data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (ptpedmac_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the PTPEDMAC driver module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the driver version based on compile time macros. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_PTPEDMAC_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.driver.ptpedmac_on_ptpedmac.open" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linkProcess()" id="module.driver.ptpedmac_on_ptpedmac.linkProcess" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="linkProcess" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;linkProcess(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linkCheck()" id="module.driver.ptpedmac_on_ptpedmac.linkCheck" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="linkCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;linkCheck(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.driver.ptpedmac_on_ptpedmac.read" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_channel}, ${p_buffer}, ${p_num_received});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.driver.ptpedmac_on_ptpedmac.close" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.driver.ptpedmac_on_ptpedmac.versionGet" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.driver.ptpedmac.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.driver.ptpedmac_on_ptpedmac.callback_def.0" version="1"><moduleRef id="module.driver.ptpedmac_on_ptpedmac" /><content>/* Callback function */
ssp_err_t ${callback_function:synergyProperty(module.driver.ptpedmac.p_callback)}(ptpedmac_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic" /><description>
<![CDATA[<form><p><span color="header" font="header">ADC Periodic Framework Module Introduction</span></p><p>The ADC Periodic Framework provides a high-level API for signal processing applications. The module configures the ADC/SDADC to sample any of the available channels (using the single-scan mode) at a configurable rate and buffers the data for a configurable number of sampling iterations before notifying the application. The ADC Periodic Framework uses the ADC/SDADC, GPT or AGT and DTC peripherals on a Renesas Synergy™ Microcontroller. A user‑defined callback can be created to process the data each time a new sample is available.​​​​​​​</p><p><b>ADC Periodic Framework Module Features</b></p><li bindent="0" vspace="false">24-bit Sigma-Delta A/D Converter (S1JA only).</li><li bindent="0" vspace="false">16-bit A/D Converter (S1JA)</li><li bindent="0" vspace="false">14-bit A/D Converter (S3A7, S3A6, S3A3, S124, S128)</li><li bindent="0" vspace="false">12-bit A/D Converter (S7G2, S5D9, S5D5)</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Single Scan</li><li bindent="20" vspace="false">Group Scan</li><li bindent="20" vspace="false">Continuous Scan</li><li bindent="0" vspace="false">Multiple Channels</li><li bindent="20" vspace="false">1 channel (S1JA)</li><li bindent="20" vspace="false">13 channels (unit 0), 12 channels (unit 1) (S7G2 and S5D9)</li><li bindent="20" vspace="false">13 channels (unit 0), 9 channels (unit 1) (S5D5)</li><li bindent="20" vspace="false">18 channels (S124)</li><li bindent="20" vspace="false">21 channels (S128)</li><li bindent="20" vspace="false">25 channels (S3A6)</li><li bindent="20" vspace="false">28 channels (S3A7)</li><li bindent="20" vspace="false">Temperature sensor channel</li><li bindent="20" vspace="false">Voltage sensor channel</li><p><span color="header" font="header">ADC Periodic Framework Module Features</span></p><li bindent="0" vspace="false">24-bit Sigma-Delta A/D Converter (S1JA only).</li><li bindent="0" vspace="false">16-bit A/D Converter (S1JA)</li><li bindent="0" vspace="false">14-bit A/D Converter (S3A7, S3A6, S3A3, S124, S128)</li><li bindent="0" vspace="false">12-bit A/D Converter (S7G2, S5D9, S5D5)</li><li bindent="0" vspace="false">Multiple Operation Modes</li><li bindent="20" vspace="false">Single Scan</li><li bindent="20" vspace="false">Group Scan</li><li bindent="20" vspace="false">Continuous Scan</li><li bindent="0" vspace="false">Multiple Channels</li><li bindent="20" vspace="false">1 channel (S1JA)</li><li bindent="20" vspace="false">13 channels (unit 0), 12 channels (unit 1) (S7G2 and S5D9)</li><li bindent="20" vspace="false">13 channels (unit 0), 9 channels (unit 1) (S5D5)</li><li bindent="20" vspace="false">18 channels (S124)</li><li bindent="20" vspace="false">21 channels (S128)</li><li bindent="20" vspace="false">25 channels (S3A6)</li><li bindent="20" vspace="false">28 channels (S3A7)</li><li bindent="20" vspace="false">Temperature sensor channel</li><li bindent="20" vspace="false">Voltage sensor channel</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_adc_periodic_ctrl_t *const p_ctrl, sf_adc_periodic_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Acquires mutex, then initializes driver at the HAL layer </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_adc_periodic_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Starts the scan. </p><p><b>Warning</b></p><p>The driver will enable the ADC to be triggered via timer event; there will be a time delay from the time this function is called to the time the hardware timer count expires and triggers the scan. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_ADC_PERIODIC_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_adc_periodic_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stops the hardware trigger (timer) from triggering any more ADC scans. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_ADC_PERIODIC_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_adc_periodic_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Releases channel mutex and closes channel at HAL layer. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_ADC_PERIODIC_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.open" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_adc_periodic.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.start" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_adc_periodic.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.stop" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_adc_periodic.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.close" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_adc_periodic.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.versionGet" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_adc_periodic.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.callback_def.0" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_adc_periodic.p_callback)}(sf_adc_periodic_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_adc_periodic_on_sf_adc_periodic.callback_def.error" version="1"><moduleRef id="module.framework.sf_adc_periodic_on_sf_adc_periodic" /><content>/* ${instance:synergyProperty(module.framework.sf_adc_periodic.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback" /><description>
<![CDATA[<form><p><span color="header" font="header">Audio Playback Framework Introduction</span></p><p>The Audio Playback Framework module provides a high-level API for audio playback applications and is implemented on either <span font="code">sf_audio_playback_hw_dac</span> or <span font="code">sf_audio_playback_hw_i2s</span>. The Audio Playback Framework handles the synchronization needed to play 16-bit and 8-bit pulse-code modulation (PCM) samples and uses the DAC (DAC12 or DAC8) or I2S, timer (AGT or GPT) and data-transfer (DMA or DTC) peripherals on a Synergy MCU. A user-defined callback can be created to respond to the need for additional data.</p><p><b>Audio Playback Framework Module Features</b></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until a ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pause and resume functions.</li><li bindent="0" vspace="false">Scaling, for example to move signed 16-bit PCM data into range of the unsigned 12-bit DAC or unsigned 8-bit DAC8.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li><p><span color="header" font="header">Audio Playback Framework Module Features</span></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until a ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pause and resume functions.</li><li bindent="0" vspace="false">Scaling, for example to move signed 16-bit PCM data into range of the unsigned 12-bit DAC or unsigned 8-bit DAC8.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li><p><span color="header" font="header">Audio Playback Framework Module Operational Overview</span></p><p>The Audio Playback Framework module creates a thread internally to support audio playback. The following figure shows a flowchart of the audio playback framework thread and its interactions with public Audio Playback Framework API functions:</p><p>
 Suggested use of the audio playback framework:</p><li bindent="0" vspace="false">Create a semaphore (for example, g_sf_audio_playback_semaphore). This can be done on the <b>Threads</b> tab. Set the initial value to 2 (the audio playback framework can store up to two data messages per stream).</li><li bindent="0" vspace="false">Create a callback function (for example, sf_audio_playback_callback). Enter the name of your callback function in the Audio Playback Framework instance. The callback function will be called when the audio playback framework is done with the data. In the callback, put the semaphore created above.</li><li bindent="0" vspace="false">In your main loop, get the semaphore before playing data. To play data, first acquire a buffer from the messaging framework, then create your audio playback data structure inside the buffer.</li><p>The Audio Playback Framework supports multiple audio streams on a single hardware port. A block diagram of the modules required if two streams are used is shown in the following figure:</p><p><b>Audio Playback Framework Module Important Operational Notes and Limitations</b></p><p><span color="header">Audio Playback Framework Module Operational Notes</span></p><p><b>Configuring Messages</b></p><p>Use the Messaging Framework configurator on the Messaging tab to configure the messaging framework:</p><li bindent="0" style="text" value="1." vspace="false">Highlight the Audio Playback event class.</li><li bindent="0" style="text" value="2." vspace="false">Add a new subscriber. Select the following configurations and make sure the Message Class Instance property set in the <b>Properties</b> tab of the Audio Playback Framework on sf_audio_playback module is between the Start and End instance.</li><li bindent="20" vspace="false">Thread: Any thread in the application.</li><li bindent="20" vspace="false">Start: First audio instance used in application.</li><li bindent="20" vspace="false">End: Last audio instance used in application.</li><li bindent="0" style="text" value="3." vspace="false">Highlight the new Subscriber in the Audio Playback Subscribers. Record the Symbol name.</li><li bindent="0" style="text" value="4." vspace="false">Go back to the <b>Threads</b> tab.</li><li bindent="0" style="text" value="5." vspace="false">Highlight the Audio Playback Framework Shared module in HAL/Common, and set the Audio Message Queue Name to the Symbol name from the Audio Playback Subscriber.</li><p><b>Using the I2S Implementation</b></p><p>The audio framework I2S hardware port has dependencies on the I2S Driver module. The I2S driver module can be accelerated with DTC.</p><li bindent="0" vspace="false">Set the ISDE properties for the I2S driver module.</li><li bindent="20" vspace="false">Set the Audio Clock Frequency (Hertz) to the frequency of the input audio clock used.</li><li bindent="20" vspace="false">Set the Sampling Frequency (Hertz) to the sampling frequency of your audio data.</li><li bindent="20" vspace="false">Set the Data Bits and Word Length to 16 bits (audio framework accepts 16 bit samples only).</li><li bindent="20" vspace="false">Enable the SSIn TXI and SSIn INT interrupts.</li><li bindent="0" vspace="false">The Transfer module on r_dtc is added automatically.</li><p><b>Using the DAC Implementation</b></p><p>The audio framework DAC hardware port has dependencies on the Timer, DAC, and Transfer API modules.</p><li bindent="0" vspace="false">Add a Timer module.</li><li bindent="20" vspace="false">Set the Frequency in Hz to the sampling frequency of your audio data.</li><li bindent="20" vspace="false">Enable the interrupt if using DTC as the transfer module (recommended).</li><li bindent="0" vspace="false">Add a DAC (DAC12 or DAC8) module.</li><li bindent="0" vspace="false">Add a Transfer module on r_dtc.</li><li bindent="20" vspace="false">Set Destination pointer to <span font="code">&amp;R_DAC-&gt;DADRn[0]</span> if using DAC channel 0 or <span font="code">&amp;R_DAC-&gt;DADRn[1]</span> if using DAC channel 1.</li><li bindent="20" vspace="false">Set Destination pointer to <span font="code">&amp;R_DAC8-&gt;DADRn[2]</span> if using DAC8 channel 2 (S128) or <span font="code">&amp;R_DAC8-&gt;DADRn[0]</span> if using DAC8 channel 0 (S1JA).</li><li bindent="20" vspace="false">Set the Activation source to the timer interrupt chosen above.</li><p><b>Other Operational Notes</b></p><p>The Queue used must match the name specified in Properties for Audio Playback Framework Shared on sf_audio_playback (default is g_sf_audio_playback_queue).</p><p><span color="header">Audio Playback Framework Module Limitations</span></p><li bindent="0" vspace="false">Refer to the latest SSP Release Notes for any additional operational limitations for this module.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_audio_playback_ctrl_t *const p_ctrl, sf_audio_playback_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Configure the audio framework by creating a thread for audio playback and configuring HAL layer drivers used. This function must be called before any other audio functions. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a device structure allocated by user. The device control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_audio_playback_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>The close API handles cleans up internal driver data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_audio_playback_ctrl_t *const p_ctrl, sf_audio_playback_data_t *const p_data, UINT const timeout)" id="start"><description>
<![CDATA[<form><p>Play audio. Currently only 16-bit mono PCM buffers are supported. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Start()</span></li><p><b>Precondition</b></p><p>Call <span font="code">SF_MESSAGE_Open</span> to configure the messaging framework control block and queues with the parameters specified in sf_audio_playback_cfg_t::p_message and sf_audio_playback_cfg_t::p_queue.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data, description, timeout values, and synchronization options. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout, represents the maximum amount of time to wait to post to the audio queue. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout values from 0x00000001 through 0xFFFFFFFE in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pause) (sf_audio_playback_ctrl_t *const p_ctrl)" id="pause"><description>
<![CDATA[<form><p>Pause audio playback. This stops the peripheral that triggers the DMA/DTC transfer and posts a flag to notify <span font="code">SF_AUDIO_PLAYBACK_Start()</span> to pause any playback in progress. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Pause()</span></li><p><b>Precondition</b></p><p>Call <span font="code">SF_AUDIO_PLAYBACK_Start()</span> before using this function. Calling <span font="code">SF_AUDIO_PLAYBACK_Pause()</span> before <span font="code">SF_AUDIO_PLAYBACK_Start()</span> has no effect and does not return an error code.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_audio_playback_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop audio playback. Causes <span font="code">SF_AUDIO_PLAYBACK_Start()</span> halt playback and return. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Stop()</span></li><p><b>Precondition</b></p><p>Call <span font="code">SF_AUDIO_PLAYBACK_Start()</span> before using this function. Calling <span font="code">SF_AUDIO_PLAYBACK_Stop()</span> before <span font="code">SF_AUDIO_PLAYBACK_Start()</span> has no effect and does not return an error code.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*resume) (sf_audio_playback_ctrl_t *const p_ctrl)" id="resume"><description>
<![CDATA[<form><p>Resume audio playback. Posts a flag to notify <span font="code">SF_AUDIO_PLAYBACK_Start()</span> to restart the peripheral that triggers the DMA/DTC transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_Resume()</span></li><p><b>Precondition</b></p><p>Call <span font="code">SF_AUDIO_PLAYBACK_Pause()</span> before using this function. Calling <span font="code">SF_AUDIO_PLAYBACK_Resume()</span> before <span font="code">SF_AUDIO_PLAYBACK_Pause()</span> has no effect and does not return an error code.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*volumeSet) (sf_audio_playback_ctrl_t *const p_ctrl, uint8_t const volume)" id="volumeSet"><description>
<![CDATA[<form><p>Set software volume control. Software volume control is applied globally to all streams on the hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_VolumeSet()</span></li><p><b>Warning</b></p><p>Software volume control reduces resolution and may require extra memory and processing bandwidth.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for audio driver. </li><li bindent="0" vspace="false"><span font="code">volume</span> :   Volume level requested. Valid range is from 0 (muted, which will stop playback) to 255 (maximum volume, default on open). </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Store version information in provided pointer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to device control block initialized in Open call for UART driver. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_audio_playback_on_sf_audio_playback.open" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_audio_playback_on_sf_audio_playback.close" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_audio_playback_on_sf_audio_playback.start" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;start(${instance}.p_ctrl, ${p_data}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pause()" id="module.framework.sf_audio_playback_on_sf_audio_playback.pause" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="pause" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;pause(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_audio_playback_on_sf_audio_playback.stop" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call resume()" id="module.framework.sf_audio_playback_on_sf_audio_playback.resume" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="resume" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;resume(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call volumeSet()" id="module.framework.sf_audio_playback_on_sf_audio_playback.volumeSet" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="volumeSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;volumeSet(${instance}.p_ctrl, ${volume});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_audio_playback_on_sf_audio_playback.versionGet" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_audio_playback_on_sf_audio_playback.callback_def.0" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_audio_playback.p_callback)}(sf_message_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_audio_playback_on_sf_audio_playback.callback_def.error" version="1"><moduleRef id="module.framework.sf_audio_playback_on_sf_audio_playback" /><content>/* ${instance:synergyProperty(module.framework.sf_audio_playback.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_audio_playback_hw" /><description>
<![CDATA[<form><p><span color="header" font="header">Audio Playback DAC Framework Introduction</span></p><p>The Audio Playback Framework DAC module provides a high-level API for audio playback applications and handles the synchronization needed to play 8-bit or 16-bit pulse-code modulation (PCM) samples. The Audio Playback DAC Framework uses the DAC/DAC8, timer (AGT or GPT) and data-transfer (DMA or DTC) peripherals on a Synergy MCU. A user-defined callback can be created to respond to the need for additional data.</p><p><b>Audio Playback DAC Framework Module Features</b></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until a ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pauses and resumes functions.</li><li bindent="0" vspace="false">Scaling, for example, to move signed 16-bit PCM data into range of the unsigned 12-bit or 8-bit DAC.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li><p><b>Note</b></p><p>Selection options of DAC or DAC8 Driver is MCU specific.</p><p><span color="header" font="header">Audio Playback DAC Framework Module Features</span></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until a ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pauses and resumes functions.</li><li bindent="0" vspace="false">Scaling, for example, to move signed 16-bit PCM data into range of the unsigned 12-bit or 8-bit DAC.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li><p><b>Note</b></p><p>Selection options of DAC or DAC8 Driver is MCU specific.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_audio_playback_hw_ctrl_t *const p_ctrl, sf_audio_playback_hw_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to memory allocated for control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the hardware configurations. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start audio playback hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop audio playback hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*play) (sf_audio_playback_hw_ctrl_t *const p_ctrl, int16_t const *const p_buffer, uint32_t length)" id="play"><description>
<![CDATA[<form><p>Play audio buffer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Play()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to buffer with PCM samples to play. Data must be scaled for audio playback hardware. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Length of data in p_buffer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dataTypeGet) (sf_audio_playback_hw_ctrl_t *const p_ctrl, sf_audio_playback_data_type_t *const p_data_type)" id="dataTypeGet"><description>
<![CDATA[<form><p>Stores expected data type in provided pointer p_data_type. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_DataTypeGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><li bindent="0" vspace="false"><span font="code">p_data_type</span> :   Pointer to audio sample data type required by hardware. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the audio driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to variable that will be populated with version information. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_audio_playback_hw.open" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_audio_playback_hw.start" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_audio_playback_hw.stop" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call play()" id="module.framework.sf_audio_playback_hw.play" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="play" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;play(${instance}.p_ctrl, ${p_buffer}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dataTypeGet()" id="module.framework.sf_audio_playback_hw.dataTypeGet" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="dataTypeGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;dataTypeGet(${instance}.p_ctrl, ${p_data_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_audio_playback_hw.close" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_audio_playback_hw.versionGet" version="1"><moduleRef id="module.framework.sf_audio_playback_hw"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_audio_playback_hw_i2s" /><description>
<![CDATA[<form><p><span color="header" font="header">Audio Playback I2S Framework Introduction</span></p><p>The I2S Audio Playback Framework module provides a high-level API for Audio Playback applications and handles the synchronization needed to play 8-bit or 16-bit pulse-code modulation (PCM) samples. The Audio Playback Framework uses the I2S, Timer (AGT or GPT) and Data Transfer (DMA or DTC) peripherals on a Synergy MCU. A user defined callback can be created to respond to the need for additional data.</p><p><b>Audio Playback I2S Framework Module Features</b></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pauses and resumes functions.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li><p><span color="header" font="header">Audio Playback I2S Framework Module Features</span></p><li bindent="0" vspace="false">Plays long buffers by splitting the data into manageable chunks.</li><li bindent="0" vspace="false">Repeats playback until ThreadX timeout (for repeated audio like sine wave tones or looped background music).</li><li bindent="0" vspace="false">Requests next data using callback after last buffer playback begins.</li><li bindent="0" vspace="false">Software volume control.</li><li bindent="0" vspace="false">Pauses and resumes functions.</li><li bindent="0" vspace="false">Basic mixing for multiple streams.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_audio_playback_hw_ctrl_t *const p_ctrl, sf_audio_playback_hw_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to memory allocated for control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the hardware configurations. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start audio playback hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop audio playback hardware. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*play) (sf_audio_playback_hw_ctrl_t *const p_ctrl, int16_t const *const p_buffer, uint32_t length)" id="play"><description>
<![CDATA[<form><p>Play audio buffer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Play()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to buffer with PCM samples to play. Data must be scaled for audio playback hardware. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Length of data in p_buffer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dataTypeGet) (sf_audio_playback_hw_ctrl_t *const p_ctrl, sf_audio_playback_data_type_t *const p_data_type)" id="dataTypeGet"><description>
<![CDATA[<form><p>Stores expected data type in provided pointer p_data_type. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_DataTypeGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><li bindent="0" vspace="false"><span font="code">p_data_type</span> :   Pointer to audio sample data type required by hardware. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_audio_playback_hw_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the audio driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block initialized in <span font="code">sf_audio_playback_hw_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_PLAYBACK_HW_DAC_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to variable that will be populated with version information. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_audio_playback_hw_i2s.open" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_audio_playback_hw_i2s.start" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_audio_playback_hw_i2s.stop" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call play()" id="module.framework.sf_audio_playback_hw_i2s.play" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="play" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;play(${instance}.p_ctrl, ${p_buffer}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dataTypeGet()" id="module.framework.sf_audio_playback_hw_i2s.dataTypeGet" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="dataTypeGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;dataTypeGet(${instance}.p_ctrl, ${p_data_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_audio_playback_hw_i2s.close" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_audio_playback_hw_i2s.versionGet" version="1"><moduleRef id="module.framework.sf_audio_playback_hw_i2s"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_playback_hw.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc" /><description>
<![CDATA[<form><p><span color="header" font="header">Audio Record ADC Framework Module Introduction</span></p><p>The Audio Record ADC Framework module provides a high-level API for audio recording applications and uses the sf_adc_periodic and its lower layer ADC, GPT and DTC peripherals on the Synergy MCU. A user-defined callback can be created to indicate that the sample count has been completed.</p><p><b>Audio Record ADC Framework Module Features</b></p><li bindent="0" vspace="false">Currently supports 12-bit ADCs (supports 8, 10, and 12 bits) and 14-bit ADCs (supports 14 or 12-bit PCM data)</li><li bindent="0" vspace="false">Uses ADC Periodic Framework to simplify configuration and integration</li><li bindent="0" vspace="false">Uses a ThreadX object (for example, mutex) to protect hardware from improper access</li><li bindent="0" vspace="false">APIs for high-level functions simplify coding:</li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::open</span>, <span font="code">sf_audio_record_api_t::start</span></li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::stop</span>, <span font="code">sf_audio_record_api_t::infoGet</span></li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::close</span></li><p><span color="header" font="header">Audio Record ADC Framework Module Features</span></p><li bindent="0" vspace="false">Currently supports 12-bit ADCs (supports 8, 10, and 12 bits) and 14-bit ADCs (supports 14 or 12-bit PCM data)</li><li bindent="0" vspace="false">Uses ADC Periodic Framework to simplify configuration and integration</li><li bindent="0" vspace="false">Uses a ThreadX object (for example, mutex) to protect hardware from improper access</li><li bindent="0" vspace="false">APIs for high-level functions simplify coding:</li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::open</span>, <span font="code">sf_audio_record_api_t::start</span></li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::stop</span>, <span font="code">sf_audio_record_api_t::infoGet</span></li><li bindent="20" vspace="false"><span font="code">sf_audio_record_api_t::close</span></li></form>]]>
</description><function display="ssp_err_t (*open) (sf_audio_record_ctrl_t *const p_ctrl, sf_audio_record_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes audio recording framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_audio_record_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Starts audio recording. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Start()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Start()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_audio_record_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stops audio recording. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Stop()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_audio_record_ctrl_t *const p_ctrl, sf_audio_record_info_t *p_info)" id="infoGet"><description>
<![CDATA[<form><p>Gets channel information(Mono/Stereo). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_InfoGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to information block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_audio_record_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Releases channel mutex and closes channel at HAL layer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.open" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.start" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.stop" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.infoGet" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.close" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.versionGet" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.callback_def.0" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_audio_record_adc.p_callback)}(sf_audio_record_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc.callback_def.error" version="1"><moduleRef id="module.framework.sf_audio_record_adc_on_sf_audio_record_adc" /><content>/* ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s" /><description>
<![CDATA[<form><p><span color="header" font="header">Audio Record I2S Framework Introduction</span></p><p>The Audio Record I2S Framework module provides a high-level API for audio recording applications and uses the I2S interface. The Audio Record I2S Framework module uses the SSI, GPT and DTC peripherals on the Synergy MCU. A user-defined callback can be created to indicate that new samples are stored in the user buffer.</p><p><b>Audio Record I2S Framework Module Features</b></p><li bindent="0" vspace="false">Thread safe</li><li bindent="0" vspace="false">Records data in 8 or 16-bit PCM</li><li bindent="0" vspace="false">Periodic callback function when new samples are available</li><li bindent="0" vspace="false">Configurable number of samples (sample count) per callback</li><p><span color="header" font="header">Audio Record I2S Framework Module Features</span></p><li bindent="0" vspace="false">Thread safe</li><li bindent="0" vspace="false">Records data in 8 or 16-bit PCM</li><li bindent="0" vspace="false">Periodic callback function when new samples are available</li><li bindent="0" vspace="false">Configurable number of samples (sample count) per callback</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_audio_record_ctrl_t *const p_ctrl, sf_audio_record_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes audio recording framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_audio_record_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Starts audio recording. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Start()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Start()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_audio_record_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stops audio recording. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Stop()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_audio_record_ctrl_t *const p_ctrl, sf_audio_record_info_t *p_info)" id="infoGet"><description>
<![CDATA[<form><p>Gets channel information(Mono/Stereo). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_InfoGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_InfoGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to information block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_audio_record_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Releases channel mutex and closes channel at HAL layer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_ADC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_AUDIO_RECORD_I2S_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.open" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.start" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.stop" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.infoGet" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.close" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.versionGet" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.callback_def.0" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_audio_record_adc.p_callback)}(sf_audio_record_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s.callback_def.error" version="1"><moduleRef id="module.framework.sf_audio_record_i2s_on_sf_audio_record_i2s" /><content>/* ${instance:synergyProperty(module.framework.sf_audio_record_adc.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_comms" /><description>
<![CDATA[<form><p><span color="header" font="header">Telnet Communications Framework Introduction</span></p><p>The Communications Framework on NX provides a high-level API for communications framework applications and uses the Ethernet peripheral on the Synergy MCU.</p><p><b>Telnet Communications Framework Module Features</b></p><li bindent="0" vspace="false">High-level connectivity is supported on Ethernet but is easily changeable to UART and USB connectivity without API modification</li><li bindent="0" vspace="false">Supports channel locking for exclusive access</li><li bindent="0" vspace="false">Thread-aware implementation uses mutex and event flags internally</li><p><span color="header" font="header">Telnet Communications Framework Module Features</span></p><li bindent="0" vspace="false">High-level connectivity is supported on Ethernet but is easily changeable to UART and USB connectivity without API modification</li><li bindent="0" vspace="false">Supports channel locking for exclusive access</li><li bindent="0" vspace="false">Thread-aware implementation uses mutex and event flags internally</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_comms_ctrl_t *const p_ctrl, sf_comms_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a control structure allocated by user. The control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_comms_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Clean up communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_comms_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, UINT const timeout)" id="read"><description>
<![CDATA[<form><p>Read data from communications driver. This call will return after the number of bytes requested is read or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_comms_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const bytes, UINT const timeout)" id="write"><description>
<![CDATA[<form><p>Write data to communications driver. This call will return after all bytes are written or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address to read data out from </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Write data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type, UINT timeout)" id="lock"><description>
<![CDATA[<form><p>Lock the communications driver. Reserve exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type)" id="unlock"><description>
<![CDATA[<form><p>Unlock the communications driver. Release exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Store the driver version in the provided p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to memory version to be stored. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_comms.open" version="1"><moduleRef id="module.framework.sf_comms"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_comms.close" version="1"><moduleRef id="module.framework.sf_comms"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_comms.read" version="1"><moduleRef id="module.framework.sf_comms"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_comms.write" version="1"><moduleRef id="module.framework.sf_comms"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_comms.lock" version="1"><moduleRef id="module.framework.sf_comms"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;lock(${instance}.p_ctrl, ${lock_type}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_comms.unlock" version="1"><moduleRef id="module.framework.sf_comms"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;unlock(${instance}.p_ctrl, ${lock_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_comms.versionGet" version="1"><moduleRef id="module.framework.sf_comms"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_comms.callback_def.error" version="1"><moduleRef id="module.framework.sf_comms" /><content>/* ${instance:synergyProperty(module.framework.sf_comms.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_ux_comms_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Communications Framework on USBX v2 Module Introduction</span></p><p>The Communications Framework on USBX™ (sf_el_ux_comms_v2) implements a high-level API for communications applications that provides an easy-to-use connection over the USB port. The high-level API functions in the framework are compatible with other connection implementations (such as UART and Ethernet), so it is easy to switch from one implementation to another without changing application code. The Communications Framework on USBX uses the USB peripheral on the Synergy MCU device.</p><p><b>Communications Framework on USBX v2 Module Features</b></p><li bindent="0" vspace="false">High-level connectivity is supported on USB but is easily changed to UART and Ethernet connectivity without API modification</li><li bindent="0" vspace="false">Supports channel locking for exclusive access</li><li bindent="0" vspace="false">Supports USB high speed (HS) or full speed (FS) operation</li><li bindent="0" vspace="false">Supports data-transfer (DMAC or DTC) peripherals on a Synergy MCU</li><li bindent="0" vspace="false">ThreadX®-aware implementation uses mutex</li><p><b>Note</b></p><p>Currently, DTC is not supported by both the host and device side driver (only DMAC is supported).</p><p><span color="header" font="header">Communications Framework on USBX v2 Module Features</span></p><li bindent="0" vspace="false">High-level connectivity is supported on USB but is easily changed to UART and Ethernet connectivity without API modification</li><li bindent="0" vspace="false">Supports channel locking for exclusive access</li><li bindent="0" vspace="false">Supports USB high speed (HS) or full speed (FS) operation</li><li bindent="0" vspace="false">Supports data-transfer (DMAC or DTC) peripherals on a Synergy MCU</li><li bindent="0" vspace="false">ThreadX®-aware implementation uses mutex</li><p><b>Note</b></p><p>Currently, DTC is not supported by both the host and device side driver (only DMAC is supported).</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_comms_ctrl_t *const p_ctrl, sf_comms_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a control structure allocated by user. The control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_comms_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Clean up communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_comms_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, UINT const timeout)" id="read"><description>
<![CDATA[<form><p>Read data from communications driver. This call will return after the number of bytes requested is read or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_comms_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const bytes, UINT const timeout)" id="write"><description>
<![CDATA[<form><p>Write data to communications driver. This call will return after all bytes are written or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address to read data out from </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Write data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type, UINT timeout)" id="lock"><description>
<![CDATA[<form><p>Lock the communications driver. Reserve exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type)" id="unlock"><description>
<![CDATA[<form><p>Unlock the communications driver. Release exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Store the driver version in the provided p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to memory version to be stored. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_el_ux_comms_v2.open" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_el_ux_comms_v2.close" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_el_ux_comms_v2.read" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_el_ux_comms_v2.write" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_el_ux_comms_v2.lock" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;lock(${instance}.p_ctrl, ${lock_type}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_el_ux_comms_v2.unlock" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;unlock(${instance}.p_ctrl, ${lock_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_el_ux_comms_v2.versionGet" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_el_ux_comms_v2.callback_def.error" version="1"><moduleRef id="module.framework.sf_el_ux_comms_v2" /><content>/* ${instance:synergyProperty(module.framework.sf_comms.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_comms_on_sf_uart_comms" /><description>
<![CDATA[<form><p><span color="header" font="header">UART Communications Framework Module Introduction</span></p><p>The UART communications framework implements a high-level API for serial communications supporting the industry standard UART protocol on a UART-compliant Synergy MCU peripheral. It utilizes the r_sci_uart HAL driver to configure and operate the Synergy MCU SCI peripheral in the UART mode.</p><p><b>UART Communications Framework Module Features</b></p><p>This module is a ThreadX-aware communications framework; it uses ThreadX objects to ensure that the operations are thread safe.</p><p>Key features include:</p><li bindent="0" vspace="false">Support for UART Communications protocol</li><li bindent="0" vspace="false">Support for locking a channel to reserve exclusive access</li><li bindent="0" vspace="false">ThreadX-aware implementation</li><p><span color="header" font="header">UART Communications Framework Module Features</span></p><p>This module is a ThreadX-aware communications framework; it uses ThreadX objects to ensure that the operations are thread safe.</p><p>Key features include:</p><li bindent="0" vspace="false">Support for UART Communications protocol</li><li bindent="0" vspace="false">Support for locking a channel to reserve exclusive access</li><li bindent="0" vspace="false">ThreadX-aware implementation</li></form>]]>
</description><function display="ssp_err_t (*open) (uart_ctrl_t *const p_ctrl, uart_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open UART device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartOpen()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">uart_cfg_t</span> :   Pointer to UART configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (uart_ctrl_t *const p_ctrl, uint8_t const *const p_dest, uint32_t const bytes)" id="read"><description>
<![CDATA[<form><p>Read from UART device. If a transfer instance is used for reception, the received bytes are stored directly in the read input buffer. When a transfer is complete, the callback is called with event UART_EVENT_RX_COMPLETE. Bytes received outside an active transfer are received in the callback function with event UART_EVENT_RX_CHAR. The maximum transfer size is reported by <span font="code">infoGet()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartRead()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data from. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length. Only applicable if <span font="code">uart_cfg_t::p_transfer_rx</span> is not NULL. Otherwise all read bytes will be provided through the callback set in <span font="code">uart_cfg_t::p_callback</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (uart_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const bytes)" id="write"><description>
<![CDATA[<form><p>Write to UART device. The write buffer is used until write is complete. Do not overwrite write buffer contents until the write is finished. When the write is complete (all bytes are fully transmitted on the wire), the callback called with event UART_EVENT_TX_COMPLETE. The maximum transfer size is reported by <span font="code">infoGet()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartWrite()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address to write data to. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Write data length. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*baudSet) (uart_ctrl_t *const p_ctrl, uint32_t const baudrate)" id="baudSet"><description>
<![CDATA[<form><p>Change baud rate. </p><p><b>Warning</b></p><p>Calling this API aborts any in-progress transmission and disables reception until the new baud settings have been applied.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartBaudSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">baudrate</span> :   Baud rate in bps. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (uart_ctrl_t *const p_ctrl, uart_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Get the driver specific information. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartInfoGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">baudrate</span> :   Baud rate in bps. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (uart_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close UART device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartClose()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartVersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*communicationAbort) (uart_ctrl_t *const p_ctrl, uart_dir_t communication_to_abort)" id="communicationAbort"><description>
<![CDATA[<form><p>Abort ongoing transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">R_SCI_UartAbort()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the UART control block. </li><li bindent="0" vspace="false"><span font="code">communication_to_abort</span> :   Type of abort request. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_comms_on_sf_uart_comms.open" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_comms_on_sf_uart_comms.read" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_comms_on_sf_uart_comms.write" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call baudSet()" id="module.framework.sf_comms_on_sf_uart_comms.baudSet" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="baudSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;baudSet(${instance}.p_ctrl, ${baudrate});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_comms_on_sf_uart_comms.infoGet" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_comms_on_sf_uart_comms.close" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_comms_on_sf_uart_comms.versionGet" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call communicationAbort()" id="module.framework.sf_comms_on_sf_uart_comms.communicationAbort" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms"><function id="communicationAbort" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;communicationAbort(${instance}.p_ctrl, ${communication_to_abort});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_comms_on_sf_uart_comms.callback_def.error" version="1"><moduleRef id="module.framework.sf_comms_on_sf_uart_comms" /><content>/* ${instance:synergyProperty(module.framework.sf_comms.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">I2C Framework Introduction</span></p><p>The I2C Framework module provides a ThreadX-aware high-level API for I2C industry standard serial device communications and configures the I2C peripheral in order to enable serial communication to be used by the framework. The I2C Framework module uses the I2C and SCI peripherals on the Synergy MCU.</p><p><b>I2C Framework Module Features</b></p><li bindent="0" vspace="false">ThreadX-aware framework</li><li bindent="0" vspace="false">Handles integration and synchronization of multiple I2C peripherals on the I2C bus</li><li bindent="0" vspace="false">Provides a single interface to access both SCI I2C and RIIC drivers</li><li bindent="0" vspace="false">The I2C framework module configures I2C communication in master mode</li><li bindent="0" vspace="false">The I2C framework module supports three data rates: 100 kHz, 400 kHz, and 1 MHz</li><li bindent="0" vspace="false">The I2C framework module supports both 7-bit addressing and 10-bit addressing</li><li bindent="0" vspace="false">The I2C framework module also provides support for callbacks internally. User defined callback is not used. The callback functions are called with the following events <span font="code">i2c_event_t</span></li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete</li><li bindent="20" vspace="false">Receive complete</li><li bindent="0" vspace="false">The callback structure <span font="code">i2c_callback_args_t</span> also provides the number of bytes that were sent or received</li><li bindent="0" vspace="false">Implemented by:</li><li bindent="20" vspace="false">Simple I2C on SCI</li><li bindent="20" vspace="false">RIIC</li><p><span color="header" font="header">I2C Framework Module Features</span></p><li bindent="0" vspace="false">ThreadX-aware framework</li><li bindent="0" vspace="false">Handles integration and synchronization of multiple I2C peripherals on the I2C bus</li><li bindent="0" vspace="false">Provides a single interface to access both SCI I2C and RIIC drivers</li><li bindent="0" vspace="false">The I2C framework module configures I2C communication in master mode</li><li bindent="0" vspace="false">The I2C framework module supports three data rates: 100 kHz, 400 kHz, and 1 MHz</li><li bindent="0" vspace="false">The I2C framework module supports both 7-bit addressing and 10-bit addressing</li><li bindent="0" vspace="false">The I2C framework module also provides support for callbacks internally. User defined callback is not used. The callback functions are called with the following events <span font="code">i2c_event_t</span></li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete</li><li bindent="20" vspace="false">Receive complete</li><li bindent="0" vspace="false">The callback structure <span font="code">i2c_callback_args_t</span> also provides the number of bytes that were sent or received</li><li bindent="0" vspace="false">Implemented by:</li><li bindent="20" vspace="false">Simple I2C on SCI</li><li bindent="20" vspace="false">RIIC</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_i2c_ctrl_t *p_ctrl, sf_i2c_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a designated I2C device on a bus. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control handle for I2C framework driver context for a device (Value returns from this function). This value must be cleared by user. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   I2C configuration includes I2C bus and low level configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_i2c_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, bool const restart, uint32_t const timeout)" id="read"><description>
<![CDATA[<form><p>Receive data from I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Read()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to previously opened I2C SF control structure. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to location to store read data. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to read. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Indicates whether the restart condition should be issued after reading. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_i2c_ctrl_t *const p_ctrl, uint8_t *const p_src, uint32_t const bytes, bool const restart, uint32_t const timeout)" id="write"><description>
<![CDATA[<form><p>Transmit data to I2C device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Write()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to previously opened I2C control structure. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to location to get write data. </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Number of bytes to write. </li><li bindent="0" vspace="false"><span font="code">restart</span> :   Indicates whether the restart condition should be issued after writing. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (sf_i2c_ctrl_t *const p_ctrl, uint32_t const timeout)" id="reset"><description>
<![CDATA[<form><p>Abort any in-progress transfer and force the I2C peripheral into a ready state. </p><p>
This function safely terminates any in-progress I2C transfer with the device. If a transfer is aborted, the user is be notified via callback with an abort event. Since the callback is optional, this function also returns a specific error code in this situation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Reset()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for I2C driver. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_i2c_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disable the I2C device designated by the control handle. Close the RTOS services used by the bus if no devices are connected to the bus. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control handle for I2C framework driver context for a device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_i2c_ctrl_t *const p_ctrl)" id="lock"><description>
<![CDATA[<form><p>Lock the bus for a device. Locking allows devices to reserve a bus to themselves for a given period of time (i.e. between lock and unlock). This allows devices to complete several reads and writes on the bus without interrupt, which is required in some instances. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Lock()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control handle for I2C framework driver context for a device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_i2c_ctrl_t *const p_ctrl)" id="unlock"><description>
<![CDATA[<form><p>Unlock the bus from a particular device and make it available for other devices. This allows other devices to use bus for reads and writes on the bus. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_Unlock()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control handle for I2C framework driver context for a device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*version) (ssp_version_t *const p_version)" id="version"><description>
<![CDATA[<form><p>Get I2C framework version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle for I2C framework control block for a device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lockWait) (sf_i2c_ctrl_t *const p_ctrl, uint32_t const timeout)" id="lockWait"><description>
<![CDATA[<form><p>Lock the I2C bus for a device. Locking reserves exclusive access to the I2C driver. Here a wait option is provided to the user. This allows devices to complete several reads and writes on the bus without interrupt, which is required in some instances. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_I2C_LockWait()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control handle for I2C framework driver context for a device </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_i2c_on_sf_i2c_v2.open" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_i2c_on_sf_i2c_v2.read" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${restart}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_i2c_on_sf_i2c_v2.write" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${restart}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.framework.sf_i2c_on_sf_i2c_v2.reset" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_i2c_on_sf_i2c_v2.close" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_i2c_on_sf_i2c_v2.lock" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;lock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_i2c_on_sf_i2c_v2.unlock" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;unlock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call version()" id="module.framework.sf_i2c_on_sf_i2c_v2.version" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="version" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;version(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lockWait()" id="module.framework.sf_i2c_on_sf_i2c_v2.lockWait" version="1"><moduleRef id="module.framework.sf_i2c_on_sf_i2c_v2"><function id="lockWait" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_i2c_v2.name)}.p_api-&gt;lockWait(${instance}.p_ctrl, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_i2c_bus_on_sf_i2c_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">I2C Framework Introduction</span></p><p>The I2C Framework module provides a ThreadX-aware high-level API for I2C industry standard serial device communications and configures the I2C peripheral in order to enable serial communication to be used by the framework. The I2C Framework module uses the I2C and SCI peripherals on the Synergy MCU.</p><p><b>I2C Framework Module Features</b></p><li bindent="0" vspace="false">ThreadX-aware framework</li><li bindent="0" vspace="false">Handles integration and synchronization of multiple I2C peripherals on the I2C bus</li><li bindent="0" vspace="false">Provides a single interface to access both SCI I2C and RIIC drivers</li><li bindent="0" vspace="false">The I2C framework module configures I2C communication in master mode</li><li bindent="0" vspace="false">The I2C framework module supports three data rates: 100 kHz, 400 kHz, and 1 MHz</li><li bindent="0" vspace="false">The I2C framework module supports both 7-bit addressing and 10-bit addressing</li><li bindent="0" vspace="false">The I2C framework module also provides support for callbacks internally. User defined callback is not used. The callback functions are called with the following events <span font="code">i2c_event_t</span></li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete</li><li bindent="20" vspace="false">Receive complete</li><li bindent="0" vspace="false">The callback structure <span font="code">i2c_callback_args_t</span> also provides the number of bytes that were sent or received</li><li bindent="0" vspace="false">Implemented by:</li><li bindent="20" vspace="false">Simple I2C on SCI</li><li bindent="20" vspace="false">RIIC</li><p><span color="header" font="header">I2C Framework Module Features</span></p><li bindent="0" vspace="false">ThreadX-aware framework</li><li bindent="0" vspace="false">Handles integration and synchronization of multiple I2C peripherals on the I2C bus</li><li bindent="0" vspace="false">Provides a single interface to access both SCI I2C and RIIC drivers</li><li bindent="0" vspace="false">The I2C framework module configures I2C communication in master mode</li><li bindent="0" vspace="false">The I2C framework module supports three data rates: 100 kHz, 400 kHz, and 1 MHz</li><li bindent="0" vspace="false">The I2C framework module supports both 7-bit addressing and 10-bit addressing</li><li bindent="0" vspace="false">The I2C framework module also provides support for callbacks internally. User defined callback is not used. The callback functions are called with the following events <span font="code">i2c_event_t</span></li><li bindent="20" vspace="false">Transfer aborted</li><li bindent="20" vspace="false">Transmit complete</li><li bindent="20" vspace="false">Receive complete</li><li bindent="0" vspace="false">The callback structure <span font="code">i2c_callback_args_t</span> also provides the number of bytes that were sent or received</li><li bindent="0" vspace="false">Implemented by:</li><li bindent="20" vspace="false">Simple I2C on SCI</li><li bindent="20" vspace="false">RIIC</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_spi_v2_on_sf_spi" /><description>
<![CDATA[<form><p><span color="header" font="header">SPI Framework Introduction</span></p><p>The SPI Framework module provides a ThreadX-aware framework API and handles the integration and synchronization of multiple SPI peripherals on an SPI bus (including chip-select handling and its level activation). With the SPI Framework, one or more SPI buses can be created and multiple SPI peripherals can be connected to the SPI bus. The SPI Framework module uses a single interface to access both SCI SPI and RSPI drivers. The SPI Framework module uses the SCI and RSPI peripherals on the Synergy MCU.</p><p><b>SPI Framework Module Features</b></p><p>The SPI Framework module uses either the SCI in SPI mode (together with the SCI common lower-level modules) or the RSPI lower-level driver module to communicate with the SPI peripherals on the Synergy microcontroller.</p><li bindent="0" vspace="false">Supports multiple devices on a bus</li><li bindent="0" vspace="false">Provides high-level APIs for initialization, transfers and closing the module</li><li bindent="0" vspace="false">Supports synchronized transfers</li><li bindent="0" vspace="false">Supports chip-select operations</li><li bindent="0" vspace="false">Supports bus-locking</li><p><span color="header" font="header">SPI Framework Module Features</span></p><p>The SPI Framework module uses either the SCI in SPI mode (together with the SCI common lower-level modules) or the RSPI lower-level driver module to communicate with the SPI peripherals on the Synergy microcontroller.</p><li bindent="0" vspace="false">Supports multiple devices on a bus</li><li bindent="0" vspace="false">Provides high-level APIs for initialization, transfers and closing the module</li><li bindent="0" vspace="false">Supports synchronized transfers</li><li bindent="0" vspace="false">Supports chip-select operations</li><li bindent="0" vspace="false">Supports bus-locking</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_spi_ctrl_t *p_ctrl, sf_spi_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a designated SPI device on a bus. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SPI Framework configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_spi_ctrl_t *const p_ctrl, void *const p_dest, uint32_t const length, spi_bit_width_t const bit_width, uint32_t const timeout)" id="read"><description>
<![CDATA[<form><p>Receive data from SPI device. </p><p><b>Precondition</b></p><p>Call <span font="code">sf_spi_api_t::open</span> to configure the SPI device before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Indicates the number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Indicates data bit width to be transferred. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_spi_ctrl_t *const p_ctrl, void *const p_src, uint32_t const length, spi_bit_width_t const bit_width, uint32_t const timeout)" id="write"><description>
<![CDATA[<form><p>Transmit data to SPI device. </p><p><b>Precondition</b></p><p>Call <span font="code">sf_spi_api_t::open</span> to configure the SPI device before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. 
 The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Indicates the number of units of data to be transferred (unit size specified by the bit_width). </li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Indicates data bit width to be transferred. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*writeRead) (sf_spi_ctrl_t *const p_ctrl, void *const p_src, void *const p_dest, uint32_t const length, spi_bit_width_t const bit_width, uint32_t const timeout)" id="writeRead"><description>
<![CDATA[<form><p>Simultaneously transmit data to an SPI device while receiving data from an SPI device (full duplex). </p><p>The writeread API gets mutex object, handles SPI data transmission at SPI HAL layer and receive data from the SPI HAL layer. The API uses the event flag wait to synchronize to completion of data transfer . </p><p><b>Precondition</b></p><p>Call <span font="code">sf_spi_api_t::open</span> to configure the SPI before using this function. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a source data buffer from which data will be transmitted to a SPI device. 
 The argument must not be NULL. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to destination buffer into which data will be copied that is received from a SPI device. It is the responsibility of the caller to ensure that adequate space is available to hold the requested data count. </li><li bindent="0" vspace="false"><span font="code">length</span> :   Indicates the number of units of data to be transferred (unit size specified by the bit_width).</li><li bindent="0" vspace="false"><span font="code">bit_width</span> :   Indicates data bit width to be transferred. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_spi_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disable the SPI device designated by the control handle and close the RTOS services used by the bus if no devices are connected to the bus. This function removes power to the SPI channel designated by the handle and disables the associated interrupts. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_spi_ctrl_t *const p_ctrl)" id="lock"><description>
<![CDATA[<form><p>Lock the bus for a device. The locking allows devices to reserve a bus to themselves for a given period of time (i.e. between lock and unlock). This allows devices to complete several reads and writes on the bus without interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lockWait) (sf_spi_ctrl_t *const p_ctrl, uint32_t const timeout)" id="lockWait"><description>
<![CDATA[<form><p>Lock the bus for a device. The locking allows devices to reserve a bus to themselves for a given period of time (i.e. between lock and unlock). This allows devices to complete several reads and writes on the bus without interrupt. The wait option allows thread to wait for the specified timeout when acquiring the bus mutex. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_SPI_LockWait()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_spi_ctrl_t *const p_ctrl)" id="unlock"><description>
<![CDATA[<form><p>Unlock the bus for a particular device and make the bus usable for other devices. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the device. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*version) (ssp_version_t *const p_version)" id="version"><description>
<![CDATA[<form><p>Get the version information of the underlying driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_spi_v2_on_sf_spi.open" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_spi_v2_on_sf_spi.read" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${length}, ${bit_width}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_spi_v2_on_sf_spi.write" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${length}, ${bit_width}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call writeRead()" id="module.framework.sf_spi_v2_on_sf_spi.writeRead" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="writeRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;writeRead(${instance}.p_ctrl, ${p_src}, ${p_dest}, ${length}, ${bit_width}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_spi_v2_on_sf_spi.close" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_spi_v2_on_sf_spi.lock" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;lock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lockWait()" id="module.framework.sf_spi_v2_on_sf_spi.lockWait" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="lockWait" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;lockWait(${instance}.p_ctrl, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_spi_v2_on_sf_spi.unlock" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;unlock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call version()" id="module.framework.sf_spi_v2_on_sf_spi.version" version="1"><moduleRef id="module.framework.sf_spi_v2_on_sf_spi"><function id="version" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_spi_v2.name)}.p_api-&gt;version(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_spi_bus_v2_on_sf_spi_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">SPI Framework Introduction</span></p><p>The SPI Framework module provides a ThreadX-aware framework API and handles the integration and synchronization of multiple SPI peripherals on an SPI bus (including chip-select handling and its level activation). With the SPI Framework, one or more SPI buses can be created and multiple SPI peripherals can be connected to the SPI bus. The SPI Framework module uses a single interface to access both SCI SPI and RSPI drivers. The SPI Framework module uses the SCI and RSPI peripherals on the Synergy MCU.</p><p><b>SPI Framework Module Features</b></p><p>The SPI Framework module uses either the SCI in SPI mode (together with the SCI common lower-level modules) or the RSPI lower-level driver module to communicate with the SPI peripherals on the Synergy microcontroller.</p><li bindent="0" vspace="false">Supports multiple devices on a bus</li><li bindent="0" vspace="false">Provides high-level APIs for initialization, transfers and closing the module</li><li bindent="0" vspace="false">Supports synchronized transfers</li><li bindent="0" vspace="false">Supports chip-select operations</li><li bindent="0" vspace="false">Supports bus-locking</li><p><span color="header" font="header">SPI Framework Module Features</span></p><p>The SPI Framework module uses either the SCI in SPI mode (together with the SCI common lower-level modules) or the RSPI lower-level driver module to communicate with the SPI peripherals on the Synergy microcontroller.</p><li bindent="0" vspace="false">Supports multiple devices on a bus</li><li bindent="0" vspace="false">Provides high-level APIs for initialization, transfers and closing the module</li><li bindent="0" vspace="false">Supports synchronized transfers</li><li bindent="0" vspace="false">Supports chip-select operations</li><li bindent="0" vspace="false">Supports bus-locking</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_ux_comms" /><description>
<![CDATA[<form />]]>
</description><function display="ssp_err_t (*open) (sf_comms_ctrl_t *const p_ctrl, sf_comms_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a control structure allocated by user. The control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_comms_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Clean up communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_comms_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, UINT const timeout)" id="read"><description>
<![CDATA[<form><p>Read data from communications driver. This call will return after the number of bytes requested is read or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_comms_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const bytes, UINT const timeout)" id="write"><description>
<![CDATA[<form><p>Write data to communications driver. This call will return after all bytes are written or if a timeout occurs while waiting for access to the driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address to read data out from </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Write data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type, UINT timeout)" id="lock"><description>
<![CDATA[<form><p>Lock the communications driver. Reserve exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_comms_ctrl_t *const p_ctrl, sf_comms_lock_t lock_type)" id="unlock"><description>
<![CDATA[<form><p>Unlock the communications driver. Release exclusive access to the communications driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">lock_type</span> :   Locking type, transmission channel or reception channel </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Store the driver version in the provided p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for communications driver. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to memory version to be stored. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_el_ux_comms.open" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_el_ux_comms.close" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_el_ux_comms.read" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_el_ux_comms.write" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_el_ux_comms.lock" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;lock(${instance}.p_ctrl, ${lock_type}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_el_ux_comms.unlock" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;unlock(${instance}.p_ctrl, ${lock_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_el_ux_comms.versionGet" version="1"><moduleRef id="module.framework.sf_el_ux_comms"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_comms.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_el_ux_comms.callback_def.error" version="1"><moduleRef id="module.framework.sf_el_ux_comms" /><content>/* ${instance:synergyProperty(module.framework.sf_comms.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_ctrl_t *const p_ctrl, sf_crypto_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP Crypto Framework Common Module. This function is to be called only once to initialize the Crypto services. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a Crypto framework control block. Must be declared by user. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to a Crypto framework configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP Crypto Framework Common Module. This function is to be called only once when the the Crypto services are no longer required. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a Crypto framework control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lock) (sf_crypto_ctrl_t *const p_ctrl)" id="lock"><description>
<![CDATA[<form><p>Lock shared resources for Cryptography operations. This function is typically called by Crypto Framework modules (SF_CRYPTO_XXX) to protect shared software resources provided in Crypto Framework Common module or shared crypto hardware engine. Once <span font="code">lock()</span> is called by a thread, any Crypto Framework services called by the other thread will be blocked until <span font="code">unlock()</span> is called. The lock and unlock operations are managed by Crypto Framework modules so users do not need to call this function in typical use-cases. However, if this function is called by a user thread, users must be aware that any cryptography operations by the other threads will be locked out until <span font="code">unlock()</span> is called by the thread which called <span font="code">lock()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_Lock()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a Crypto framework control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*unlock) (sf_crypto_ctrl_t *const p_ctrl)" id="unlock"><description>
<![CDATA[<form><p>Unlock shared resources for Cryptography operations. This function is typically called by Crypto Framework modules (SF_CRYPTO_XXX) to allow any other threads to access to shared software resources provided in Crypto Framework Common module or shared crypto hardware engine. This function must be called by a thread which called <span font="code">lock()</span>. The lock and unlock operations are managed by Crypto Framework modules so users do not need to call this function in typical use-cases. However, this function must be called by a user thread if the thread has ever called <span font="code">lock()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_Unlock()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a Crypto framework control block. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto Framework Common Module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (sf_crypto_ctrl_t *const p_ctrl, sf_crypto_state_t *p_status)" id="statusGet"><description>
<![CDATA[<form><p>Get status of SSP Crypto Framework Common Module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_StatusGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a Crypto framework control block. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Memory location to store module status. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto.open" version="1"><moduleRef id="module.framework.sf_crypto"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto.close" version="1"><moduleRef id="module.framework.sf_crypto"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lock()" id="module.framework.sf_crypto.lock" version="1"><moduleRef id="module.framework.sf_crypto"><function id="lock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;lock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call unlock()" id="module.framework.sf_crypto.unlock" version="1"><moduleRef id="module.framework.sf_crypto"><function id="unlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;unlock(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto.versionGet" version="1"><moduleRef id="module.framework.sf_crypto"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.framework.sf_crypto.statusGet" version="1"><moduleRef id="module.framework.sf_crypto"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_cipher" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_cipher_ctrl_t *const p_ctrl, sf_crypto_cipher_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Opens SSP Crypto Cipher framework. This function initializes a control block of the framework module based on the configuration parameters such as the key type, key size and chaining mode. The module allows users to have multiple instances with different control blocks, if required. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. Caller only needs to allocate <span font="code">sf_crypto_cipher_instance_ctrl_t</span> and not fill any parameters. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_cipher_cfg_t</span> configuration structure. All elements of this structure must be filled by caller. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*cipherInit) (sf_crypto_cipher_ctrl_t *const p_ctrl, sf_crypto_cipher_op_mode_t cipher_operation_mode, sf_crypto_key_t const *const p_key, sf_crypto_cipher_algorithm_init_params_t *const p_algorithm_specific_params)" id="cipherInit"><description>
<![CDATA[<form><p>Initializes a cipher operation. Must be called after <span font="code">open()</span> or <span font="code">cipherFinal()</span> is called, to initialize a new cipher operation. Unless a different key type or key size or chaining mode is used, users do not need to close the module for a new cipher operation but can call this function to restart another cipher operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_CipherInit()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">cipher_operation_mode</span> :   Specifies encrypt or decrypt operation. </li><li bindent="0" vspace="false"><span font="code">p_key</span> :   The key to be used for the cipher operation. </li><li bindent="0" vspace="false"><span font="code">p_algorithm_specific_params</span> :   Algorithm specific parameters. Allocate and fill parameters specific to the algorithm for the key type configured at <span font="code">open()</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*cipherUpdate) (sf_crypto_cipher_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_data_in, sf_crypto_data_handle_t *const p_data_out)" id="cipherUpdate"><description>
<![CDATA[<form><p>Encrypts / decrypts input data and writes it to the output buffer. Can be called multiple times for additional blocks of data. If input length is 0 this method does nothing. There may be 0 to (input length+block size - 1) bytes of data for AES operations. For RSA operation there will be no output until <span font="code">cipherFinal()</span> is called. RSA Encryption is only supported with the RSA Public Key. RSA Decryption is only supported with the RSA Private Key. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_CipherUpdate()</span></li><p><b>Note</b></p><p>Data buffers must be WORD aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_data_in</span> :   Pointer to an input data buffer and the input data length. </li><li bindent="0" vspace="false"><span font="code">p_data_out</span> :   Pointer to an output data buffer and the buffer size on input. If there is data to be output, buffer is filled and the length is updated.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*cipherFinal) (sf_crypto_cipher_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_data_in, sf_crypto_data_handle_t *const p_data_out)" id="cipherFinal"><description>
<![CDATA[<form><p>Encrypts/decrypts all/last block of data and writes to the output buffer. Once <span font="code">cipherFinal()</span> is called, no additional call of <span font="code">cipherUpdate()</span> is allowed but <span font="code">cipherInit()</span> can be called to initialize a new cipher operation unless another key type / key size/chaining mode is needed. In such a case a call to <span font="code">close()</span> and <span font="code">open()</span> is required. For AES operations, the number of bytes output into output data buffer may be larger or smaller than input length or even 0. RSA Encryption is only supported with the RSA Public Key. RSA Decryption is only supported with the RSA Private Key. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_CipherFinal()</span></li><p><b>Note</b></p><p>Data buffers must be WORD aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_data_in</span> :   Pointer to an input data buffer and the input data length. </li><li bindent="0" vspace="false"><span font="code">p_data_out</span> :   Pointer to the output data buffer and the buffer size on input. If there is data to be output, buffer is filled and the length is updated.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*cipherAadUpdate) (sf_crypto_cipher_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_aad)" id="cipherAadUpdate"><description>
<![CDATA[<form><p>Updates AAD (Additional Authenticated Data) for AES GCM operation. Can be called multiple times for additional blocks of data. This is ONLY to provide AAD for AES GCM operation. Not applicable to any other algorithms or modes. This has to be called prior to processing any plain text / cipher text data. In other words, before any call to <span font="code">cipherUpdate()</span> or <span font="code">cipherFinal()</span> is made. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_CipherAadUpdate()</span></li><p><b>Note</b></p><p>Data buffer must be WORD aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_aad</span> :   Pointer to an input data buffer containing AAD and the AAD length.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_cipher_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes SSP Crypto Cipher framework. This function resets a control block of the framework module and allows users to re-configure the module differently. For instance, users can close the module and re-open it with different key type or key size or chaining mode / algorithm for a new cipher operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Cipher Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto Cipher framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_CIPHER_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_cipher.open" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call cipherInit()" id="module.framework.sf_crypto_cipher.cipherInit" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="cipherInit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;cipherInit(${instance}.p_ctrl, ${cipher_operation_mode}, ${p_key}, ${p_algorithm_specific_params});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call cipherUpdate()" id="module.framework.sf_crypto_cipher.cipherUpdate" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="cipherUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;cipherUpdate(${instance}.p_ctrl, ${p_data_in}, ${p_data_out});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call cipherFinal()" id="module.framework.sf_crypto_cipher.cipherFinal" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="cipherFinal" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;cipherFinal(${instance}.p_ctrl, ${p_data_in}, ${p_data_out});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call cipherAadUpdate()" id="module.framework.sf_crypto_cipher.cipherAadUpdate" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="cipherAadUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;cipherAadUpdate(${instance}.p_ctrl, ${p_aad});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_cipher.close" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_cipher.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_cipher"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_cipher.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_cipher" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_cipher.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_hash" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_hash_ctrl_t *const p_ctrl, sf_crypto_hash_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Opens SSP Crypto HASH framework. This function initializes a control block of the framework module based on the configuration parameters such as the HASH algorithm type. The module allows users to have multiple instances with different control blocks, if required. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto HASH Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_hash_cfg_t</span> configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_hash_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes SSP Crypto HASH framework. This function de-initializes a control block of the framework module and allow users to re-configure the module differently. For instance, users can close the module and re-open it with different HASH algorithm for a new digest operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto HASH Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*hashInit) (sf_crypto_hash_ctrl_t *const p_ctrl)" id="hashInit"><description>
<![CDATA[<form><p>Initializes a message digest operation. Must be called once <span font="code">open()</span> or <span font="code">hashFinal()</span> is called to initialize a new digest operation. Unless a different HASH type is used, users do not need to close the module for a new digest operation but can call this function to restart another digest operation. This is a blocking call. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_MessageDigestInit()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto HASH Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*hashUpdate) (sf_crypto_hash_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_data_in)" id="hashUpdate"><description>
<![CDATA[<form><p>Hashes input data and saves it in an internal context buffer. Can be called multiple times for additional blocks of data. This is a blocking call. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_MessageDigestUpdate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto HASH Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_data_in</span> :   Pointer to an input data buffer and the data length. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*hashFinal) (sf_crypto_hash_ctrl_t *const p_ctrl, sf_crypto_data_handle_t *const p_msg_digest, uint32_t *p_size)" id="hashFinal"><description>
<![CDATA[<form><p>Hashes the last block of data and returns a message digest in the output buffer. Once <span font="code">hashFinal()</span> is called, no additional call of <span font="code">hashUpdate()</span> is allowed but <span font="code">hashInit()</span> can be called to initialize a new digest operation unless the other HASH algorithm type needed. If the other HASH algorithm is required for a new digest operation, call <span font="code">close()</span> and <span font="code">open()</span>. This is a blocking call. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_MessageDigestUpdate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto HASH Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_msg_digest</span> :   Pointer to an output data buffer and the buffer size. Message digest will be generated in the buffer. Data buffer must be aligned to word alignment and the size must be sufficient to store the message digest. </li><li bindent="0" vspace="false"><span font="code">p_size</span> :   Pointer to the 32-bit memory space to store the size of message digest. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto HASH framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_HASH_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_hash.open" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_hash.close" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call hashInit()" id="module.framework.sf_crypto_hash.hashInit" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="hashInit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;hashInit(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call hashUpdate()" id="module.framework.sf_crypto_hash.hashUpdate" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="hashUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;hashUpdate(${instance}.p_ctrl, ${p_data_in});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call hashFinal()" id="module.framework.sf_crypto_hash.hashFinal" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="hashFinal" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;hashFinal(${instance}.p_ctrl, ${p_msg_digest}, ${p_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_hash.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_hash"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_hash.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_hash.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_hash" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_hash.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_key" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_key_ctrl_t *const p_ctrl, sf_crypto_key_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP Crypto Key framework for subsequent call / Key generation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_key_cfg_t</span> configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_key_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP Crypto Key framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*keyGenerate) (sf_crypto_key_ctrl_t *const p_ctrl, sf_crypto_key_t *const p_secret_key, sf_crypto_key_t *const p_public_key)" id="keyGenerate"><description>
<![CDATA[<form><p>Generate a key. This is a blocking call. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_Generate()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_secret_key</span> :   Pointer to a secret key structure. The pointer to the buffer and it's length in bytes, are to be populated on input. On success the key and it's length in bytes, are returned. Refer to r_rsa_api.h for RSA secret key sizes. Refer to r_aes_api.h for AES key sizes. Refer to r_ecc_api.h for ECC key sizes. p_secret_key should be WORD aligned. The memory allocation to store the secret key is user's responsibility. </li><li bindent="0" vspace="false"><span font="code">p_public_key</span> :   Pointer to a public key structure. The pointer to the buffer and it's length in bytes, are to be populated on input. On success the key and it's length in bytes, are returned. Refer to r_rsa_api.h for RSA public key sizes. Refer to r_ecc_api.h for ECC public key sizes. Should set to NULL for AES. p_public_key should be WORD aligned. The memory allocation to store the public key is user's responsibility. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*EcdhSharedSecretCompute) (sf_crypto_key_ctrl_t *const p_ctrl, sf_crypto_key_t *const p_local_secret_key, sf_crypto_key_t *const p_remote_public_key, sf_crypto_key_t *const p_shared_secret)" id="EcdhSharedSecretCompute"><description>
<![CDATA[<form><p>Perform scalar multiplication for ECC algorithms only. This is a blocking call. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_CRYPTO_KEY_EcdhSharedSecretCompute </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_local_secret_key</span> :   Pointer to a secret key structure. The pointer to the secret key and it's length in bytes, are to be populated on input. Refer to r_ecc_api.h for ECC key sizes. p_secret_key should be WORD aligned. The memory allocation to store the secret key is user's responsibility. </li><li bindent="0" vspace="false"><span font="code">p_remote_public_key</span> :   pointer to a point on the curve data. The pointer to the point on curve data and its length in bytes, are to be populated on input. Refer to r_ecc_api.h for ECC point on curve sizes. p_point_on_curve should be WORD aligned. The memory allocation to store the point on curve data is user's responsibility. </li><li bindent="0" vspace="false"><span font="code">p_shared_secret</span> :   The pointer to the buffer and it's length in bytes, are to be populated on input. On success the resultant point on curve data and it's length in bytes, are returned. Refer to r_ecc_api.h for ECC public key sizes. p_resultant_vector should be WORD aligned. The memory allocation to store the resultant point on curve data is user's responsibility. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto Key framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_key.open" version="1"><moduleRef id="module.framework.sf_crypto_key"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_key.close" version="1"><moduleRef id="module.framework.sf_crypto_key"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call keyGenerate()" id="module.framework.sf_crypto_key.keyGenerate" version="1"><moduleRef id="module.framework.sf_crypto_key"><function id="keyGenerate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key.name)}.p_api-&gt;keyGenerate(${instance}.p_ctrl, ${p_secret_key}, ${p_public_key});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call EcdhSharedSecretCompute()" id="module.framework.sf_crypto_key.EcdhSharedSecretCompute" version="1"><moduleRef id="module.framework.sf_crypto_key"><function id="EcdhSharedSecretCompute" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key.name)}.p_api-&gt;EcdhSharedSecretCompute(${instance}.p_ctrl, ${p_local_secret_key}, ${p_remote_public_key}, ${p_shared_secret});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_key.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_key"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_key.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_key" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_key.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_key_installation" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_key_installation_ctrl_t *const p_ctrl, sf_crypto_key_installation_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP Crypto Key Installation framework for subsequent call / Key installation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_INSTALLATION_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Installation Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_key_installation_cfg_t</span> configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_key_installation_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP Crypto Key Installation framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_INSTALLATION_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Installation Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto Key Installation framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_INSTALLATION_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*keyInstall) (sf_crypto_key_installation_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_user_key_rsa_modulus, sf_crypto_data_handle_t const *const p_user_key_input, sf_crypto_key_installation_shared_index_t const shared_index_input, sf_crypto_data_handle_t const *const p_session_key_input, uint32_t const *const p_iv_input, sf_crypto_data_handle_t *const p_key_data_out)" id="keyInstall"><description>
<![CDATA[<form><p>Install a key from the user's encrypted key, a shared index, session key, and an IV generated using a scheme designed to maintain plaintext source key isolation. This returns a wrapped key (sometimes called a key index) that can be used in other crypto APIs in place of the associated plaintext key (stored offline). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_KEY_INSTALLATION_KeyInstall()</span> </li><p><b>Note</b></p><p>It is the user's responsibility to ensure all the above input/output buffers are WORD aligned. </p><p><b>Note</b></p><p>Caller must assign appropriate length to data_length field for all buffers before calling this API. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Key Installation Framework control block structure. Caller should not modify any elements of this structure at any time. </li><li bindent="0" vspace="false"><span font="code">p_user_key_rsa_modulus</span> :   Pointer to sf_crypto_key_handle_t structure which includes a pointer to the WORD aligned buffer which holds the RSA modulus portion of the encrypted user RSA private key and the modulus length. This is only applicable when a RSA standard key is being installed. To be set to NULL otherwise. </li><li bindent="0" vspace="false"><span font="code">p_user_key_input</span> :   Pointer to sf_crypto_key_handle_t structure which includes a pointer to the WORD aligned buffer which holds the encrypted user key and length. This is the key to be installed in encrypted format. </li><li bindent="0" vspace="false"><span font="code">shared_index_input</span> :   An enumerated type that reflects the shared key index returned by the DLM Service, accompanied by the session key that follows. </li><li bindent="0" vspace="false"><span font="code">p_session_key_input</span> :   Pointer to sf_crypto_key_handle_t structure which includes a pointer to the WORD aligned buffer which holds the session key and length returned by the DLM Service, accompanied by the shared index key, above. </li><li bindent="0" vspace="false"><span font="code">p_iv_input</span> :   Pointer to the 128-bit IV array used to encrypt p_user_key_input. </li><li bindent="0" vspace="false"><span font="code">p_key_data_out</span> :   Pointer to sf_crypto_key_handle_t structure which includes a pointer to the WORD aligned buffer to hold the wrapped key and the buffer length. This is the wrapped key returned after key installation. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_key_installation.open" version="1"><moduleRef id="module.framework.sf_crypto_key_installation"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key_installation.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_key_installation.close" version="1"><moduleRef id="module.framework.sf_crypto_key_installation"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key_installation.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_key_installation.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_key_installation"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key_installation.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call keyInstall()" id="module.framework.sf_crypto_key_installation.keyInstall" version="1"><moduleRef id="module.framework.sf_crypto_key_installation"><function id="keyInstall" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_key_installation.name)}.p_api-&gt;keyInstall(${instance}.p_ctrl, ${p_user_key_rsa_modulus}, ${p_user_key_input}, ${shared_index_input}, ${p_session_key_input}, ${p_iv_input}, ${p_key_data_out});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_key_installation.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_key_installation" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_key_installation.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_signature" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_signature_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP Crypto Signature framework. This function sets up a control block of the framework module based on the configuration parameters such as the key type, key size and domain parameters. The module allows users to have multiple instances with different control blocks, if required. This API will allocate memory internally according to the cryptography algorithm selected through key_type and key_size parameters. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_signature_cfg_t</span> configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_signature_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP Crypto Signature framework module. This API will free any memory allocated when the signature framework module was opened. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*contextInit) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_signature_mode_t operation_mode, sf_crypto_signature_algorithm_init_params_t *const p_algorithm_specific_params, sf_crypto_key_t const *const p_key)" id="contextInit"><description>
<![CDATA[<form><p>Perform Signature Module Context Initialization operation. This API initializes the signature module by setting operating mode, the message padding scheme and appropriate key for subsequent calls to signUpdate, verifyUpdate, signFinal and verifyFinal APIs. This API can be called only after this module has be opened using the open API. This API can be called after signFinal or verifyFinal API to initialize context for a new operation. This API sets up the internal context for sign/verify operation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_ContextInit()</span> </li><p><b>Note</b></p><p>p_key should be WORD aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">operation_mode</span> :   Selects Sign or Verify Operation enumeration. </li><li bindent="0" vspace="false"><span font="code">p_algorithm_specific_params</span> :   Algorithm specific parameters. </li><li bindent="0" vspace="false"><span font="code">p_key</span> :   Pointer to a private key for Sign operation OR Pointer to a public key for Verify operation.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*signUpdate) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_message)" id="signUpdate"><description>
<![CDATA[<form><p>Perform Signature Module Signature-Update operation. This API can be called multiple times to accumulate the message to be signed. This API can be used when the input message to be signed is not available all at once in a byte array. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_SignUpdate()</span> </li><p><b>Note</b></p><p>p_message should be WORD aligned. </p><p><b>Note</b></p><p>In case SF_CRYPTO_SIGNATURE_NO_PADDING is chosen as the padding scheme ensure p_message is a valid message digest in appropriate format. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_message</span> :   Pointer to input message to be signed.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*verifyUpdate) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_message)" id="verifyUpdate"><description>
<![CDATA[<form><p>Perform Signature Module Signature-Verification-Update operation. This API can be called multiple times to accumulate the message whose signature is to be verified. This API can be used when the input message to be verified against a signature is not available all at once in a byte array. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_VerifyUpdate()</span> </li><p><b>Note</b></p><p>p_message should be WORD aligned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_message</span> :   Pointer to message whose signature is to be verified.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*signFinal) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_message, sf_crypto_data_handle_t *const p_dest)" id="signFinal"><description>
<![CDATA[<form><p>Perform Signature Module Signature-Final Operation. Call to this API generates signature and writes it to p_dest. p_message can be the pointer to last block of input message to be signed or can be passed as NULL if all of the input is passed through one or more signUpdate API call(s). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_SignFinal()</span> </li><p><b>Note</b></p><p>p_message should be WORD aligned. </p><p><b>Note</b></p><p>p_dest should be WORD aligned. </p><p><b>Note</b></p><p>p_message can be set to NULL. </p><p><b>Note</b></p><p>In case SF_CRYPTO_SIGNATURE_NO_PADDING is chosen as the padding scheme ensure p_message is a valid message digest in appropriate format. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_message</span> :   Pointer to data handle containing last block of data and its length. If there is no more data to be passed this param can be set to NULL.</li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Pointer to data handle containing pointer to a buffer for storing signature. The data_length of this handle must be populated with the buffer length. Upon successful return this data_length will be updated with the number of bytes written to this buffer.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*verifyFinal) (sf_crypto_signature_ctrl_t *const p_ctrl, sf_crypto_data_handle_t const *const p_signature, sf_crypto_data_handle_t const *const p_message)" id="verifyFinal"><description>
<![CDATA[<form><p>Perform Signature Module Signature-Verification-Final Operation. Call to this API performs signature verification operation. p_message can be the pointer to last block of message or can be passed as NULL if all of the message whose signature is to be verified is passed through one or more verifyUpdate API call(s). </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_VerifyFinal()</span> </li><p><b>Note</b></p><p>p_message should be WORD aligned. </p><p><b>Note</b></p><p>p_message can be set to NULL. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to Crypto Signature Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_signature</span> :   Pointer to Signature buffer to be verified. </li><li bindent="0" vspace="false"><span font="code">p_message</span> :   Pointer to last block of message whose signature is being verified. If there is no more data to be passed this param can be set to NULL.</li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto Signature framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_SIGNATURE_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_signature.open" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_signature.close" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call contextInit()" id="module.framework.sf_crypto_signature.contextInit" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="contextInit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;contextInit(${instance}.p_ctrl, ${operation_mode}, ${p_algorithm_specific_params}, ${p_key});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call signUpdate()" id="module.framework.sf_crypto_signature.signUpdate" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="signUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;signUpdate(${instance}.p_ctrl, ${p_message});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call verifyUpdate()" id="module.framework.sf_crypto_signature.verifyUpdate" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="verifyUpdate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;verifyUpdate(${instance}.p_ctrl, ${p_message});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call signFinal()" id="module.framework.sf_crypto_signature.signFinal" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="signFinal" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;signFinal(${instance}.p_ctrl, ${p_message}, ${p_dest});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call verifyFinal()" id="module.framework.sf_crypto_signature.verifyFinal" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="verifyFinal" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;verifyFinal(${instance}.p_ctrl, ${p_signature}, ${p_message});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_signature.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_signature"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_signature.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_signature.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_signature" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_signature.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_crypto_trng" /><description>
<![CDATA[<form><p><span color="header" font="header">Crypto Framework Introduction</span></p><p>The Crypto Framework layer is composed of multiple Crypto modules providing varied cryptographic services. It includes:</p><p>SF_CRYPTO for resource synchronization between the crypto modules.</p><p>SF_CRYPTO_TRNG for true random number generation.</p><p>SF_CRYPTO_HASH for message digest generation. Provides support for MD5, SHA1, SHA 224, SHA 256 algorithms.</p><p>SF_CRYPTO_KEY for Key Generation services. Provides support for AES, ECC and RSA keys.</p><p>SF_CRYPTO_CIPHER for encryption and decryption services. Provides support for AES and RSA algorithms.</p><p>SF_CRYPTO_SIGNATURE for RSA signature generation and verification services.</p><p>SF_CRYPTO_KEY_INSTALLATION for key installation services. Provides support for AES, ECC and RSA keys.</p><p><b>Crypto Framework Module Features</b></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li><p><span color="header" font="header">Crypto Framework Module Features</span></p><p>The terms "key wrapping" and "key installation" in the context of SSP are defined as follows:</p><p><b>Key Wrapping</b>: The APIs to generate symmetric keys or asymmetric key pairs on the Synergy platform where the private / secret key is a wrapped key (encrypted key).</p><p><b>Key Installation</b>: User generated private /secret keys on a PC (system outside of the Synergy platform) will be installed (no storage) on the Synergy platform and the wrapped private /secret key returned to the user.</p><p>Wrapped keys provide the following advantages:</p><li bindent="0" vspace="false">The wrapped key can only be used on the Synergy platform (MCU) on which it was generated.</li><li bindent="0" vspace="false">It cannot be moved to another Synergy platform (MCU).</li><li bindent="0" vspace="false">Original Key cannot be recovered from the wrapped key.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_crypto_trng_ctrl_t *const p_ctrl, sf_crypto_trng_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP Crypto TRNG framework for true random number generation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_TRNG_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl_api</span> :   Pointer to Crypto TRNG Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to <span font="code">sf_crypto_trng_cfg_t</span> configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_crypto_trng_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP Crypto TRNG framework. This API should be called once TRNG services are no longer needed. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_TRNG_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl_api</span> :   Pointer to Crypto TRNG Framework control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*randomNumberGenerate) (sf_crypto_trng_ctrl_t *const p_ctrl, sf_crypto_data_handle_t *const p_random_number_buff)" id="randomNumberGenerate"><description>
<![CDATA[<form><p>Generate a True Random Number of specified size </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_TRNG_RandomNumberGenerate()</span> </li><p><b>Note</b></p><p>Size value specified under p_random_number_buff must be specified in Bytes. </p><p><b>Note</b></p><p>Size value specified under p_random_number_buff must not be 0 Bytes. Its minimum value is 1. </p><p><b>Note</b></p><p>Pointer to data buffer specified under p_random_number_buff must not be NULL. </p><p><b>Note</b></p><p>Data buffer must be WORD aligned. The memory allocation to store the true random number is user's responsibility. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl_api</span> :   Pointer to Crypto TRNG Framework control block structure. </li><li bindent="0" vspace="false"><span font="code">p_random_number_buff</span> :   Pointer to <span font="code">sf_crypto_data_handle_t</span> structure storing pointer to buffer and its size where true random number will be returned. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version of SSP Crypto TRNG Framework Module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CRYPTO_TRNG_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the module version. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_crypto_trng.open" version="1"><moduleRef id="module.framework.sf_crypto_trng"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_trng.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_crypto_trng.close" version="1"><moduleRef id="module.framework.sf_crypto_trng"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_trng.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call randomNumberGenerate()" id="module.framework.sf_crypto_trng.randomNumberGenerate" version="1"><moduleRef id="module.framework.sf_crypto_trng"><function id="randomNumberGenerate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_trng.name)}.p_api-&gt;randomNumberGenerate(${instance}.p_ctrl, ${p_random_number_buff});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_crypto_trng.versionGet" version="1"><moduleRef id="module.framework.sf_crypto_trng"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_crypto_trng.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_crypto_trng.callback_def.error" version="1"><moduleRef id="module.framework.sf_crypto_trng" /><content>/* ${instance:synergyProperty(module.framework.sf_crypto_trng.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.block_media_on_lx_nor" /><description>
<![CDATA[<form><p><span color="header" font="header">Block Media Framework Module Introduction</span></p><p>The Block Media Framework on sf_block_media_lx_nor module provides a high-level API for interfacing with QSPI NOR flash memory devices. It provides API functions for reading, writing and controlling the QSPI NOR Flash memory. The framework includes the Azure RTOS wear leveling component LevelX NOR. The LevelX functions to support wear leveling are automatic and transparent to the developer. File system accesses, using the Azure RTOS FileX system, are also supported, making it easy to implement file system based applications.</p><p><b>Block Media Framework Module Features</b></p><li bindent="0" vspace="false">Supports Block Media Framework interface for NOR flash memory device.</li><li bindent="0" vspace="false">Supports file system access on NOR flash memory.</li><li bindent="0" vspace="false">Supports LevelX wear leveling functions transparently to the developer.</li><p><span color="header" font="header">Block Media Framework Module Introduction</span></p><p>The Block Media Framework on sf_block_media_lx_nor module provides a high-level API for interfacing with QSPI NOR flash memory devices. It provides API functions for reading, writing and controlling the QSPI NOR Flash memory. The framework includes the Azure RTOS wear leveling component LevelX NOR. The LevelX functions to support wear leveling are automatic and transparent to the developer. File system accesses, using the Azure RTOS FileX system, are also supported, making it easy to implement file system based applications.</p><p><b>Block Media Framework Module Features</b></p><li bindent="0" vspace="false">Supports Block Media Framework interface for NOR flash memory device.</li><li bindent="0" vspace="false">Supports file system access on NOR flash memory.</li><li bindent="0" vspace="false">Supports LevelX wear leveling functions transparently to the developer.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_block_media_ctrl_t *p_ctrl, sf_block_media_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_block_media_ctrl_t *p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_block_media_ctrl_t *p_ctrl, uint8_t const *const p_src, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address of data for writing. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ioctl) (sf_block_media_ctrl_t *p_ctrl, ssp_command_t const command, void *p_data)" id="ioctl"><description>
<![CDATA[<form><p>Send control commands to and receives the status from the media port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Control()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Void pointer to data in or out. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_block_media_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the open media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.block_media_on_lx_nor.open" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.block_media_on_lx_nor.read" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.block_media_on_lx_nor.write" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ioctl()" id="module.framework.block_media_on_lx_nor.ioctl" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="ioctl" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;ioctl(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.block_media_on_lx_nor.close" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.block_media_on_lx_nor.versionGet" version="1"><moduleRef id="module.framework.block_media_on_lx_nor"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.block_media_on_qspi" /><description>
<![CDATA[<form><p><span color="header" font="header">Block Media QSPI Framework Module Introduction</span></p><p>The Block Media Framework Module can implement the QSPI channel for reading, writing and controlling the QSPI Flash memory peripheral through the r_qspi driver. The driver has all the functionality needed to interface with a file system through a block media interface.</p><p><b>Block Media QSPI Framework Module Features</b></p><li bindent="0" vspace="false">Supports QSPI channel interface for QSPI flash memory device.</li><li bindent="0" vspace="false">Support file system on QSPI flash memory.</li><p><span color="header" font="header">Block Media QSPI Framework Module Features</span></p><li bindent="0" vspace="false">Supports QSPI channel interface for QSPI flash memory device.</li><li bindent="0" vspace="false">Support file system on QSPI flash memory.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_block_media_ctrl_t *p_ctrl, sf_block_media_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_block_media_ctrl_t *p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_block_media_ctrl_t *p_ctrl, uint8_t const *const p_src, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address of data for writing. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ioctl) (sf_block_media_ctrl_t *p_ctrl, ssp_command_t const command, void *p_data)" id="ioctl"><description>
<![CDATA[<form><p>Send control commands to and receives the status from the media port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Control()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Void pointer to data in or out. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_block_media_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the open media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.block_media_on_qspi.open" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.block_media_on_qspi.read" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.block_media_on_qspi.write" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ioctl()" id="module.framework.block_media_on_qspi.ioctl" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="ioctl" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;ioctl(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.block_media_on_qspi.close" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.block_media_on_qspi.versionGet" version="1"><moduleRef id="module.framework.block_media_on_qspi"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.block_media_on_ram" /><description>
<![CDATA[<form><p><span color="header" font="header">Block Media RAM Framework Module Introduction</span></p><p>The Block Media Framework Module can implement the file system on RAM for reading from, writing to and controlling the read/write region of the RAM memory. The framework has all the functionality needed to interface with a file system through a block media interface.</p><p><b>Block Media RAM Framework Module Features</b></p><li bindent="0" vspace="false">Enables FileX to be run on linear memory-mapped devices.</li><li bindent="0" vspace="false">Temporary and fast storage of data on RAM.</li><p><span color="header" font="header">Block Media RAM Framework Module Features</span></p><li bindent="0" vspace="false">Enables FileX to be run on linear memory-mapped devices.</li><li bindent="0" vspace="false">Temporary and fast storage of data on RAM.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_block_media_ctrl_t *p_ctrl, sf_block_media_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_block_media_ctrl_t *p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_block_media_ctrl_t *p_ctrl, uint8_t const *const p_src, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address of data for writing. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ioctl) (sf_block_media_ctrl_t *p_ctrl, ssp_command_t const command, void *p_data)" id="ioctl"><description>
<![CDATA[<form><p>Send control commands to and receives the status from the media port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Control()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Void pointer to data in or out. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_block_media_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the open media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.block_media_on_ram.open" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.block_media_on_ram.read" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.block_media_on_ram.write" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ioctl()" id="module.framework.block_media_on_ram.ioctl" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="ioctl" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;ioctl(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.block_media_on_ram.close" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.block_media_on_ram.versionGet" version="1"><moduleRef id="module.framework.block_media_on_ram"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.block_media_on_sdmmc" /><description>
<![CDATA[<form><p><span color="header" font="header">Block Media SDMMC Framework Module Introduction</span></p><p>The Block Media Framework module can implement the SD/MMC bus protocol for reading from, writing to and the control of SD cards and eMMC embedded devices through the SDHI (SD Host Interface) peripheral and the SD/MMC media driver. The driver has all the functionality needed to interface with a file system through a block media interface.</p><p><b>Block Media SDMMC Framework Module Features</b></p><li bindent="0" vspace="false">Supports SDHI host interface for SD/MMC.</li><li bindent="0" vspace="false">Supports SDSC (SD Standard Capacity), SDHC (SD High Capacity) and eMMC (embedded).</li><li bindent="0" vspace="false">Supports 1, 4 or 8-bit (eMMC only) data bus.</li><p><span color="header" font="header">Block Media SDMMC Framework Module Features</span></p><li bindent="0" vspace="false">Supports SDHI host interface for SD/MMC.</li><li bindent="0" vspace="false">Supports SDSC (SD Standard Capacity), SDHC (SD High Capacity) and eMMC (embedded).</li><li bindent="0" vspace="false">Supports 1, 4 or 8-bit (eMMC only) data bus.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_block_media_ctrl_t *p_ctrl, sf_block_media_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open a device channel for read/write and control. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Open()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_block_media_ctrl_t *p_ctrl, uint8_t *const p_dest, uint32_t const start_sector, uint32_t const sector_count)" id="read"><description>
<![CDATA[<form><p>Read data from a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Read()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to read. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_block_media_ctrl_t *p_ctrl, uint8_t const *const p_src, uint32_t const start_sector, uint32_t const sector_count)" id="write"><description>
<![CDATA[<form><p>Write data to a media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Write()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Write()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Source address of data for writing. </li><li bindent="0" vspace="false"><span font="code">start_sector</span> :   Beginning sector address to write to. </li><li bindent="0" vspace="false"><span font="code">sector_count</span> :   Number of sectors to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ioctl) (sf_block_media_ctrl_t *p_ctrl, ssp_command_t const command, void *p_data)" id="ioctl"><description>
<![CDATA[<form><p>Send control commands to and receives the status from the media port. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Control()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Control()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">command</span> :   Command to execute. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Void pointer to data in or out. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_block_media_ctrl_t *p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close the open media channel. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_Close()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_Block_Media_SDMMC_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_RAM_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_QSPI_VersionGet()</span></li><li bindent="0" vspace="false"><span font="code">SF_BLOCK_MEDIA_LX_NOR_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to the media configuration structure for a channel. </li><li bindent="0" vspace="false"><span font="code">p_version</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.block_media_on_sdmmc.open" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.block_media_on_sdmmc.read" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.block_media_on_sdmmc.write" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${start_sector}, ${sector_count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ioctl()" id="module.framework.block_media_on_sdmmc.ioctl" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="ioctl" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;ioctl(${instance}.p_ctrl, ${command}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.block_media_on_sdmmc.close" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.block_media_on_sdmmc.versionGet" version="1"><moduleRef id="module.framework.block_media_on_sdmmc"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.block_media.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_fx" /><description>
<![CDATA[<form><p><span color="header" font="header">FileX On Block Media Framework Module Introduction</span></p><p>The FileX Port on Media Framework module supports the Azure RTOS FileX system, a complete FAT and exFAT format media and a file management system for deeply embedded applications. FileX is highly optimized for both size and performance.</p><p><b>FileX On Block Media Framework Module Features</b></p><p><b>Single Partition (Uses total available memory size):</b></p><li bindent="0" vspace="false">Supports FAT32, FAT16, FAT12 and exFAT filesystems</li><li bindent="0" vspace="false">Supports single FAT and exFAT partition operations in all SSP block media, that is, sf_block_media_lx_nor, sf_block_media_sdmmc, sf_block_media_qspi and sf_block_media_ram.</li><li bindent="0" vspace="false">Multiple FileX objects (that is, media, directories, and files, only limited by available memory)</li><li bindent="0" vspace="false">Dynamic FileX object creation/deletion</li><li bindent="0" vspace="false">Flexible memory usage</li><li bindent="0" vspace="false">Size scales automatically</li><li bindent="0" vspace="false">Small footprint</li><li bindent="0" vspace="false">Complete integration with ThreadX</li><p><b>Multi Partition:</b></p><li bindent="0" vspace="false">Supports FAT32, FAT16 and exFAT filesystem.</li><li bindent="0" vspace="false">Supports the creation of any number of partition on single physical media,  and supports all other fileX operations on them, for underlying block media sf_block_media_lx_nor and sf_block_media_sdmmc.</li><li bindent="0" vspace="false">MBR/EBR support with visibility of partitions under Windows OS environment.</li><li bindent="0" vspace="false">Each partition can be operated-on independently of other partitions.</li><li bindent="0" vspace="false">Provides following operations on synergy platform for FAT and exFAT filesystem:</li><li bindent="20" style="text" value="1." vspace="false">Format/re-format</li><li bindent="20" style="text" value="2." vspace="false">open</li><li bindent="20" style="text" value="3." vspace="false">close</li><li bindent="20" style="text" value="4." vspace="false">write</li><li bindent="20" style="text" value="5." vspace="false">read</li><p><span color="header" font="header">FileX On Block Media Framework Module Features</span></p><p><b>Single Partition (Uses total available memory size):</b></p><li bindent="0" vspace="false">Supports FAT32, FAT16, FAT12 and exFAT filesystems</li><li bindent="0" vspace="false">Supports single FAT and exFAT partition operations in all SSP block media, that is, sf_block_media_lx_nor, sf_block_media_sdmmc, sf_block_media_qspi and sf_block_media_ram.</li><li bindent="0" vspace="false">Multiple FileX objects (that is, media, directories, and files, only limited by available memory)</li><li bindent="0" vspace="false">Dynamic FileX object creation/deletion</li><li bindent="0" vspace="false">Flexible memory usage</li><li bindent="0" vspace="false">Size scales automatically</li><li bindent="0" vspace="false">Small footprint</li><li bindent="0" vspace="false">Complete integration with ThreadX</li><p><b>Multi Partition:</b></p><li bindent="0" vspace="false">Supports FAT32, FAT16 and exFAT filesystem.</li><li bindent="0" vspace="false">Supports the creation of any number of partition on single physical media,  and supports all other fileX operations on them, for underlying block media sf_block_media_lx_nor and sf_block_media_sdmmc.</li><li bindent="0" vspace="false">MBR/EBR support with visibility of partitions under Windows OS environment.</li><li bindent="0" vspace="false">Each partition can be operated-on independently of other partitions.</li><li bindent="0" vspace="false">Provides following operations on synergy platform for FAT and exFAT filesystem:</li><li bindent="20" style="text" value="1." vspace="false">Format/re-format</li><li bindent="20" style="text" value="2." vspace="false">open</li><li bindent="20" style="text" value="3." vspace="false">close</li><li bindent="20" style="text" value="4." vspace="false">write</li><li bindent="20" style="text" value="5." vspace="false">read</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_tes_2d_drw" /><description>
<![CDATA[<form><p><span color="header" font="header">GUIX Synergy Port Framework Introduction</span></p><p>The SF_EL_GX (GUIX Port) module is the Azure RTOS GUIX adaptation layer for Synergy MCU groups, which have graphics engines GLCDC, DRW (2DG engine) or a JPEG decode engine. The API supports graphics hardware engine setup for GUIX and supports graphics rendering and displaying accelerated by hardware engines. The module defines full-set of GUIX low-level display driver functions which draw graphics accelerated by the DRW (2DG engine) or the JPEG or displays graphics with the GLCDC (See the GUIX User Guide Chapter 5: GUIX Display Drivers). The module encourages the hardware acceleration for graphics rendering, but also allows software processing without hardware support.</p><p><b>Supported and Unsupported Features</b></p><p>The following GUIX features are supported in SSP:</p><li bindent="0" vspace="false">RGB565 Pixel Format</li><li bindent="0" vspace="false">CLUT8 Pixel Format</li><li bindent="0" vspace="false">ARGB888 Pixel Format</li><li bindent="0" vspace="false">ARGB8888 Pixel Format</li><li bindent="0" vspace="false">Rotation Of Screen: Supported in SSP v2.0.0</li><li bindent="0" vspace="false">Dynamic Loading of Binary Resources</li><li bindent="0" vspace="false">Hardware and Software JPEG Support</li><p>The following features are not supported:</p><li bindent="0" vspace="false">ARGB4444 Format                        </li><li bindent="0" vspace="false">Multiple Canvases: GUIX allows use of multiple canvases but SSP supports only a single canvas                          </li><p><b>GUIX Synergy Port Framework Module Features</b></p><li bindent="0" vspace="false">Adapts GUIX on top of the SSP</li><li bindent="0" vspace="false">Attaches the SSP Display Interface driver to GUIX Display Driver Interface</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy D2W (2DG) engine</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy JPEG engine</li><li bindent="0" vspace="false">Supports double-buffer toggling control for screen transitions without tearing</li><li bindent="0" vspace="false">Supports screen rotation (90/180/270 degree)</li><li bindent="0" vspace="false">Supports various output color formats</li><li bindent="20" vspace="false">32bpp (ARGB8888, RGB-888)</li><li bindent="20" vspace="false">16bpp (RGB565)</li><li bindent="20" vspace="false">8bpp (8bit Palette (CLUT))</li><li bindent="0" vspace="false">Supports user callback functions</li><p><span color="header" font="header">GUIX Synergy Port Framework Module Features</span></p><li bindent="0" vspace="false">Adapts GUIX on top of the SSP</li><li bindent="0" vspace="false">Attaches the SSP Display Interface driver to GUIX Display Driver Interface</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy D2W (2DG) engine</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy JPEG engine</li><li bindent="0" vspace="false">Supports double-buffer toggling control for screen transitions without tearing</li><li bindent="0" vspace="false">Supports screen rotation (90/180/270 degree)</li><li bindent="0" vspace="false">Supports various output color formats</li><li bindent="20" vspace="false">32bpp (ARGB8888, RGB-888)</li><li bindent="20" vspace="false">16bpp (RGB565)</li><li bindent="20" vspace="false">8bpp (8bit Palette (CLUT))</li><li bindent="0" vspace="false">Supports user callback functions</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_gx" /><description>
<![CDATA[<form><p><span color="header" font="header">GUIX Synergy Port Framework Introduction</span></p><p>The SF_EL_GX (GUIX Port) module is the Azure RTOS GUIX adaptation layer for Synergy MCU groups, which have graphics engines GLCDC, DRW (2DG engine) or a JPEG decode engine. The API supports graphics hardware engine setup for GUIX and supports graphics rendering and displaying accelerated by hardware engines. The module defines full-set of GUIX low-level display driver functions which draw graphics accelerated by the DRW (2DG engine) or the JPEG or displays graphics with the GLCDC (See the GUIX User Guide Chapter 5: GUIX Display Drivers). The module encourages the hardware acceleration for graphics rendering, but also allows software processing without hardware support.</p><p><b>Supported and Unsupported Features</b></p><p>The following GUIX features are supported in SSP:</p><li bindent="0" vspace="false">RGB565 Pixel Format</li><li bindent="0" vspace="false">CLUT8 Pixel Format</li><li bindent="0" vspace="false">ARGB888 Pixel Format</li><li bindent="0" vspace="false">ARGB8888 Pixel Format</li><li bindent="0" vspace="false">Rotation Of Screen: Supported in SSP v2.0.0</li><li bindent="0" vspace="false">Dynamic Loading of Binary Resources</li><li bindent="0" vspace="false">Hardware and Software JPEG Support</li><p>The following features are not supported:</p><li bindent="0" vspace="false">ARGB4444 Format                        </li><li bindent="0" vspace="false">Multiple Canvases: GUIX allows use of multiple canvases but SSP supports only a single canvas                          </li><p><b>GUIX Synergy Port Framework Module Features</b></p><li bindent="0" vspace="false">Adapts GUIX on top of the SSP</li><li bindent="0" vspace="false">Attaches the SSP Display Interface driver to GUIX Display Driver Interface</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy D2W (2DG) engine</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy JPEG engine</li><li bindent="0" vspace="false">Supports double-buffer toggling control for screen transitions without tearing</li><li bindent="0" vspace="false">Supports screen rotation (90/180/270 degree)</li><li bindent="0" vspace="false">Supports various output color formats</li><li bindent="20" vspace="false">32bpp (ARGB8888, RGB-888)</li><li bindent="20" vspace="false">16bpp (RGB565)</li><li bindent="20" vspace="false">8bpp (8bit Palette (CLUT))</li><li bindent="0" vspace="false">Supports user callback functions</li><p><span color="header" font="header">GUIX Synergy Port Framework Module Features</span></p><li bindent="0" vspace="false">Adapts GUIX on top of the SSP</li><li bindent="0" vspace="false">Attaches the SSP Display Interface driver to GUIX Display Driver Interface</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy D2W (2DG) engine</li><li bindent="0" vspace="false">Allows GUIX to draw widgets accelerated by the Synergy JPEG engine</li><li bindent="0" vspace="false">Supports double-buffer toggling control for screen transitions without tearing</li><li bindent="0" vspace="false">Supports screen rotation (90/180/270 degree)</li><li bindent="0" vspace="false">Supports various output color formats</li><li bindent="20" vspace="false">32bpp (ARGB8888, RGB-888)</li><li bindent="20" vspace="false">16bpp (RGB565)</li><li bindent="20" vspace="false">8bpp (8bit Palette (CLUT))</li><li bindent="0" vspace="false">Supports user callback functions</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_el_gx_ctrl_t *const p_ctrl, sf_el_gx_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open SSP GUIX adaptation framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EL_GX_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to SF_EL_GX control block structure. Must be declared by user. Value set here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to SF_EL_GX configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_el_gx_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close SSP GUIX adaptation framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EL_GX_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to SF_EL_GX control block structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EL_GX_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory to store the version information. </li><p /></form>]]>
</description></function><function display="UINT (*setup) (GX_DISPLAY *p_display)" id="setup"><description>
<![CDATA[<form><p>Microsoft GUIX Driver setup entry. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EL_GX_Setup()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_display</span> :   Pointer to GUIX display driver setup function. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*canvasInit) (sf_el_gx_ctrl_t *const p_ctrl, GX_WINDOW_ROOT *p_window_root)" id="canvasInit"><description>
<![CDATA[<form><p>Canvas initialization. Set the memory address of the initial canvas. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EL_GX_CanvasInit()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to SF_EL_GX control block structure. </li><li bindent="0" vspace="false"><span font="code">p_window_root</span> :   Pointer to GUIX root window context. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_el_gx.open" version="1"><moduleRef id="module.framework.sf_el_gx"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_el_gx.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_el_gx.close" version="1"><moduleRef id="module.framework.sf_el_gx"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_el_gx.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_el_gx.versionGet" version="1"><moduleRef id="module.framework.sf_el_gx"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_el_gx.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setup()" id="module.framework.sf_el_gx.setup" version="1"><moduleRef id="module.framework.sf_el_gx"><function id="setup" /></moduleRef><content>${status:localVar(UINT)} = ${instance:synergyProperty(module.framework.sf_el_gx.name)}.p_api-&gt;setup(${p_display});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call canvasInit()" id="module.framework.sf_el_gx.canvasInit" version="1"><moduleRef id="module.framework.sf_el_gx"><function id="canvasInit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_el_gx.name)}.p_api-&gt;canvasInit(${instance}.p_ctrl, ${p_window_root});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_el_gx.callback_def.0" version="1"><moduleRef id="module.framework.sf_el_gx" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_el_gx.p_callback)}(sf_el_gx_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_jpeg_decode" /><description>
<![CDATA[<form><p><span color="header" font="header">JPEG Decode Framework Module Introduction</span></p><p>The JPEG Decode HAL module provides a high-level API for industry standard JPEG image decode processing and supports the Renesas Synergy™ JPEG Codec peripheral. The JPEG Decode Framework Module is a ThreadX ® -aware implementation and provides thread-safe access to the Synergy JPEG hardware on a Synergy MCU. A user-defined callback can be created to detect hardware supported events.</p><p><b>JPEG Decode Framework Module Features</b></p><li bindent="0" vspace="false">Provides thread-safe access to the Synergy JPEG hardware.</li><li bindent="0" vspace="false">Supports JPEG decompression using the JPEG Decode HAL module.</li><li bindent="0" vspace="false">Supports a polling mode that allows an application to wait for the JPEG Decoder to complete.</li><li bindent="0" vspace="false">Supports an interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical subsample values, horizontal stride, decoded pixel format, input and output data format, and color space.</li><li bindent="0" vspace="false">Obtains the size of the image prior to decoding it.</li><li bindent="0" vspace="false">Supports putting coded data in an input buffer and an output buffer to store the decoded image frame.</li><li bindent="0" vspace="false">Supports streaming coded data into the JPEG Decoder module. This feature allows an application to read a coded JPEG image from a file or from a network without buffering the entire image.</li><li bindent="0" vspace="false">Configures the number of image lines to decode. This feature enables the application to process the decoded image on the fly without buffering the entire frame.</li><li bindent="0" vspace="false">Supports the input decoded formats YCbCr444, YCbCr422, YCbCr420 and YCbCr411.</li><li bindent="0" vspace="false">Supports the output formats ARGB8888 and RGB565.</li><li bindent="0" vspace="false">Returns an error when the JPEG image's size, height, and width do not meet the requirements.</li><li bindent="0" vspace="false">Supports the <span font="code">sf_jpeg_decode_api_t::wait</span> API function to suspend/resume the thread for synchronizing with the JPEG hardware supported events.</li><p><span color="header" font="header">JPEG Decode Framework Module Features</span></p><li bindent="0" vspace="false">Provides thread-safe access to the Synergy JPEG hardware.</li><li bindent="0" vspace="false">Supports JPEG decompression using the JPEG Decode HAL module.</li><li bindent="0" vspace="false">Supports a polling mode that allows an application to wait for the JPEG Decoder to complete.</li><li bindent="0" vspace="false">Supports an interrupt mode with user-supplied callback functions.</li><li bindent="0" vspace="false">Configures parameters such as horizontal and vertical subsample values, horizontal stride, decoded pixel format, input and output data format, and color space.</li><li bindent="0" vspace="false">Obtains the size of the image prior to decoding it.</li><li bindent="0" vspace="false">Supports putting coded data in an input buffer and an output buffer to store the decoded image frame.</li><li bindent="0" vspace="false">Supports streaming coded data into the JPEG Decoder module. This feature allows an application to read a coded JPEG image from a file or from a network without buffering the entire image.</li><li bindent="0" vspace="false">Configures the number of image lines to decode. This feature enables the application to process the decoded image on the fly without buffering the entire frame.</li><li bindent="0" vspace="false">Supports the input decoded formats YCbCr444, YCbCr422, YCbCr420 and YCbCr411.</li><li bindent="0" vspace="false">Supports the output formats ARGB8888 and RGB565.</li><li bindent="0" vspace="false">Returns an error when the JPEG image's size, height, and width do not meet the requirements.</li><li bindent="0" vspace="false">Supports the <span font="code">sf_jpeg_decode_api_t::wait</span> API function to suspend/resume the thread for synchronizing with the JPEG hardware supported events.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_jpeg_decode_ctrl_t *const p_ctrl, sf_jpeg_decode_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Acquire mutex, then handle driver initialization at the HAL layer. This function releases mutex before it returns to the caller. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*inputBufferSet) (sf_jpeg_decode_ctrl_t *const p_ctrl, void *const p_buffer, uint32_t const buffer_size)" id="inputBufferSet"><description>
<![CDATA[<form><p>Feed data into JPEG codec module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Buffer contains data to be processed by the JPEG codec module. The buffer starting address must be 8-byte aligned </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the data buffer, must be multiple of 8 bytes </li><p /></form>]]>
</description></function><function display="ssp_err_t (*outputBufferSet) (sf_jpeg_decode_ctrl_t *const p_ctrl, void *p_buffer, uint32_t buffer_size)" id="outputBufferSet"><description>
<![CDATA[<form><p>Read processed data from JPEG codec module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   User-supplied buffer space to hold output from JPEG codec module. The buffer starting address must be 8-byte aligned </li><li bindent="0" vspace="false"><span font="code">buffer_size</span> :   Size of the output data buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*linesDecodedGet) (sf_jpeg_decode_ctrl_t *const p_ctrl, uint32_t *const p_lines)" id="linesDecodedGet"><description>
<![CDATA[<form><p>Obtain number of lines JPEG codec decoded. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_lines</span> :   Number of lines decoded into the output buffer. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*horizontalStrideSet) (sf_jpeg_decode_ctrl_t *const p_ctrl, uint32_t horizontal_stride)" id="horizontalStrideSet"><description>
<![CDATA[<form><p>Configure the horizontal stride value. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">horizontal_stride</span> :   Set the horizontal stride value, in pixels </li><p /></form>]]>
</description></function><function display="ssp_err_t (*imageSubsampleSet) (sf_jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_subsample_t horizontal_subsample, jpeg_decode_subsample_t vertical_subsample)" id="imageSubsampleSet"><description>
<![CDATA[<form><p>Configure the horizontal and vertical subsample values. This allows an application to reduce the size of the decoded image. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">horizontal_subsample</span> :   Set the horizontal subsample value </li><li bindent="0" vspace="false"><span font="code">vertical_subsample</span> :   Set the vertical subsample value </li><p /></form>]]>
</description></function><function display="ssp_err_t (*wait) (sf_jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_status_t *const p_status, uint32_t timeout)" id="wait"><description>
<![CDATA[<form><p>Wait for current JPEG codec operation to finish </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Status of current JPEG codec module </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Amount of time (in ThreadX ticks) to wait </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statusGet) (sf_jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_status_t *const p_status)" id="statusGet"><description>
<![CDATA[<form><p>Obtain JPEG codec status </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_status</span> :   Status of current JPEG codec module </li><p /></form>]]>
</description></function><function display="ssp_err_t (*imageSizeGet) (sf_jpeg_decode_ctrl_t *const p_ctrl, uint16_t *p_horizontal_size, uint16_t *p_vertical_size)" id="imageSizeGet"><description>
<![CDATA[<form><p>Obtain the size of the image. This function is only useful for decoding a JPEG image. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_horizontal_size</span> :   Width of the image, in pixels </li><li bindent="0" vspace="false"><span font="code">p_vertical_size</span> :   Height of the image, in pixels </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pixelFormatGet) (sf_jpeg_decode_ctrl_t *const p_ctrl, jpeg_decode_color_space_t *const p_color_space)" id="pixelFormatGet"><description>
<![CDATA[<form><p>Obtain the pixel format of the image. This function is only useful for decoding a JPEG image. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block initialized in <span font="code">SF_JPEG_Decode_Open()</span>. </li><li bindent="0" vspace="false"><span font="code">p_color_space</span> :   Color space of the image </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_jpeg_decode_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes JPEG codec device. Un-finished codec operation is interrupted, and output data are discarded. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block set in <span font="code">SF_JPEG_Decode_Open()</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_jpeg_decode.open" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call inputBufferSet()" id="module.framework.sf_jpeg_decode.inputBufferSet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="inputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;inputBufferSet(${instance}.p_ctrl, ${p_buffer}, ${buffer_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call outputBufferSet()" id="module.framework.sf_jpeg_decode.outputBufferSet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="outputBufferSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;outputBufferSet(${instance}.p_ctrl, ${p_buffer}, ${buffer_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call linesDecodedGet()" id="module.framework.sf_jpeg_decode.linesDecodedGet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="linesDecodedGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;linesDecodedGet(${instance}.p_ctrl, ${p_lines});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call horizontalStrideSet()" id="module.framework.sf_jpeg_decode.horizontalStrideSet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="horizontalStrideSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;horizontalStrideSet(${instance}.p_ctrl, ${horizontal_stride});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call imageSubsampleSet()" id="module.framework.sf_jpeg_decode.imageSubsampleSet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="imageSubsampleSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;imageSubsampleSet(${instance}.p_ctrl, ${horizontal_subsample}, ${vertical_subsample});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call wait()" id="module.framework.sf_jpeg_decode.wait" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="wait" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;wait(${instance}.p_ctrl, ${p_status}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statusGet()" id="module.framework.sf_jpeg_decode.statusGet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="statusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;statusGet(${instance}.p_ctrl, ${p_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call imageSizeGet()" id="module.framework.sf_jpeg_decode.imageSizeGet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="imageSizeGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;imageSizeGet(${instance}.p_ctrl, ${p_horizontal_size}, ${p_vertical_size});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pixelFormatGet()" id="module.framework.sf_jpeg_decode.pixelFormatGet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="pixelFormatGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;pixelFormatGet(${instance}.p_ctrl, ${p_color_space});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_jpeg_decode.close" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_jpeg_decode.versionGet" version="1"><moduleRef id="module.framework.sf_jpeg_decode"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_jpeg_decode.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_touch_ctsu_button" /><description>
<![CDATA[<form />]]>
</description></api><template category="function_call" display="Error callback function definition" id="module.framework.sf_touch_ctsu_button.callback_def.error" version="1"><moduleRef id="module.framework.sf_touch_ctsu_button" /><content>/* ${instance:synergyProperty(module.framework.sf_touch_ctsu_button.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_touch_ctsu" /><description>
<![CDATA[<form />]]>
</description><function display="ssp_err_t (*open) (sf_touch_ctsu_ctrl_t *const p_ctrl, sf_touch_ctsu_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to pin configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scanStart) (sf_touch_ctsu_ctrl_t *const p_ctrl)" id="scanStart"><description>
<![CDATA[<form><p>Scan start. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_ScanStart()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dataGet) (sf_touch_ctsu_ctrl_t *const p_ctrl, uint64_t *p_button_status, uint16_t *p_slider_position, uint16_t *p_wheel_position)" id="dataGet"><description>
<![CDATA[<form><p>Data get. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_DataGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_button_status</span> :   Pointer to get data bitmap. </li><li bindent="0" vspace="false"><span font="code">p_slider_position</span> :   Pointer to get data array. </li><li bindent="0" vspace="false"><span font="code">p_wheel_position</span> :   Pointer to get data array. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*callbackSet) (sf_touch_ctsu_ctrl_t *const p_api_ctrl, void(*p_callback)(sf_touch_ctsu_callback_args_t *), void const *const p_context, sf_touch_ctsu_callback_args_t *const p_callback_memory)" id="callbackSet"><description>
<![CDATA[<form><p>Specify callback function and optional context pointer and working memory pointer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_CallbackSet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the CTSU control block. </li><li bindent="0" vspace="false"><span font="code">p_callback</span> :   Callback function </li><li bindent="0" vspace="false"><span font="code">p_context</span> :   Pointer to send to callback function </li><li bindent="0" vspace="false"><span font="code">p_working_memory</span> :   Pointer to volatile memory where callback structure can be allocated. Callback arguments allocated here are only valid during the callback. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_touch_ctsu_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_data)" id="versionGet"><description>
<![CDATA[<form><p>Return the version of the driver. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_CTSU_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Memory address to return version information to. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_touch_ctsu.open" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scanStart()" id="module.framework.sf_touch_ctsu.scanStart" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="scanStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;scanStart(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dataGet()" id="module.framework.sf_touch_ctsu.dataGet" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="dataGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;dataGet(${instance}.p_ctrl, ${p_button_status}, ${p_slider_position}, ${p_wheel_position});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call callbackSet()" id="module.framework.sf_touch_ctsu.callbackSet" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="callbackSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;callbackSet(${instance}.p_ctrl, ${sf_touch_ctsu_callback_args_t}, ${p_context}, ${p_callback_memory});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_touch_ctsu.close" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_touch_ctsu.versionGet" version="1"><moduleRef id="module.framework.sf_touch_ctsu"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_ctsu.name)}.p_api-&gt;versionGet(${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_touch_ctsu_slider" /><description>
<![CDATA[<form />]]>
</description></api><template category="function_call" display="Error callback function definition" id="module.framework.sf_touch_ctsu_slider.callback_def.error" version="1"><moduleRef id="module.framework.sf_touch_ctsu_slider" /><content>/* ${instance:synergyProperty(module.framework.sf_touch_ctsu_slider.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_external_irq_on_sf_external_irq" /><description>
<![CDATA[<form><p><span color="header" font="header">External IRQ Framework Module Introduction</span></p><p>The External IRQ Framework provides a high-level API for applications using the external pin interrupts with the ThreadX RTOS and supports the external IRQ pins on the Synergy microcontroller. A callback function (sf_external_irq_callback) is available that will be called from the interrupt service routine (ISR) each time the IRQn triggers.</p><p><b>External IRQ Framework Module Features</b></p><li bindent="0" vspace="false">Responds to external interrupt inputs</li><li bindent="0" vspace="false">RTOS aware implementation using an internal semaphore for thread synchronization</li><li bindent="20" vspace="false">Can signal internal threads</li><li bindent="20" vspace="false">Can trigger transfers via the Event Link Controller (ELC)</li><li bindent="0" vspace="false">Uses the port pins available on Synergy MCUs</li><li bindent="20" vspace="false">Pins may differ between MCUs so refer to MCU User's Manuals for specifics</li><li bindent="0" vspace="false">Supports several hardware features such as</li><li bindent="20" vspace="false">Channel selection</li><li bindent="20" vspace="false">Trigger conditions</li><li bindent="20" vspace="false">Digital filtering</li><li bindent="20" vspace="false">Auto-start</li><p><span color="header" font="header">External IRQ Framework Module Features</span></p><li bindent="0" vspace="false">Responds to external interrupt inputs</li><li bindent="0" vspace="false">RTOS aware implementation using an internal semaphore for thread synchronization</li><li bindent="20" vspace="false">Can signal internal threads</li><li bindent="20" vspace="false">Can trigger transfers via the Event Link Controller (ELC)</li><li bindent="0" vspace="false">Uses the port pins available on Synergy MCUs</li><li bindent="20" vspace="false">Pins may differ between MCUs so refer to MCU User's Manuals for specifics</li><li bindent="0" vspace="false">Supports several hardware features such as</li><li bindent="20" vspace="false">Channel selection</li><li bindent="20" vspace="false">Trigger conditions</li><li bindent="20" vspace="false">Digital filtering</li><li bindent="20" vspace="false">Auto-start</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_external_irq_ctrl_t *const p_ctrl, sf_external_irq_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Create the semaphore, then handle driver initialization at the HAL layer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EXTERNAL_IRQ_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. The device control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*wait) (sf_external_irq_ctrl_t *const p_ctrl, ULONG const timeout)" id="wait"><description>
<![CDATA[<form><p>Wait for the next external interrupt expiration, then return. </p><p><b>Precondition</b></p><p>Call <span font="code">SF_EXTERNAL_IRQ_Open</span> to configure the external IRQ before using this function. During <span font="code">SF_EXTERNAL_IRQ_Open</span>, set sf_external_irq_cfg_t::sf_external_irq_event_t to <span font="code">SF_EXTERNAL_IRQ_EVENT_SEMAPHORE_PUT</span>.</p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EXTERNAL_IRQ_Wait()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">SF_EXTERNAL_IRQ_Open</span>. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Select TX_NO_WAIT, a value in system clock counts between 1 and 0xFFFFFFFF, or TX_WAIT_FOREVER. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EXTERNAL_IRQ_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used stored here. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_external_irq_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close channel at HAL layer and release the RTOS services. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_EXTERNAL_IRQ_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for this external interrupt. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_external_irq_on_sf_external_irq.open" version="1"><moduleRef id="module.framework.sf_external_irq_on_sf_external_irq"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_external_irq.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call wait()" id="module.framework.sf_external_irq_on_sf_external_irq.wait" version="1"><moduleRef id="module.framework.sf_external_irq_on_sf_external_irq"><function id="wait" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_external_irq.name)}.p_api-&gt;wait(${instance}.p_ctrl, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_external_irq_on_sf_external_irq.versionGet" version="1"><moduleRef id="module.framework.sf_external_irq_on_sf_external_irq"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_external_irq.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_external_irq_on_sf_external_irq.close" version="1"><moduleRef id="module.framework.sf_external_irq_on_sf_external_irq"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_external_irq.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Touch Panel V2 Framework Introduction</span></p><p>The Touch Panel V2 Framework module provides a high-level API for obtaining touch data on coordinates and events from the touch controller. The Touch Panel V2 Framework module uses the touch chip driver SSP Supplement module for communication with the touch panel.</p><p><b>Touch Panel V2 Framework Module Features</b></p><li bindent="0" vspace="false">Provides position data (X and Y coordinates).</li><li bindent="0" vspace="false">Provides rotation of touch coordinates.</li><li bindent="0" vspace="false">Provides the touch event type (down, up, move, hold, or invalid).</li><li bindent="0" vspace="false">A callback can be registered or an API function can be used to get touch data.</li><li bindent="0" vspace="false">Supports calibration of the touch panel for key elements: scalar, rotation and mechanical shifts.</li><li bindent="0" vspace="false">Provides a common API interface to touch chip drivers.</li><li bindent="0" vspace="false">Supports an adjustable update frequency.</li><p><span color="header" font="header">Touch Panel V2 Framework Module Features</span></p><li bindent="0" vspace="false">Provides position data (X and Y coordinates).</li><li bindent="0" vspace="false">Provides rotation of touch coordinates.</li><li bindent="0" vspace="false">Provides the touch event type (down, up, move, hold, or invalid).</li><li bindent="0" vspace="false">A callback can be registered or an API function can be used to get touch data.</li><li bindent="0" vspace="false">Supports calibration of the touch panel for key elements: scalar, rotation and mechanical shifts.</li><li bindent="0" vspace="false">Provides a common API interface to touch chip drivers.</li><li bindent="0" vspace="false">Supports an adjustable update frequency.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_touch_panel_v2_ctrl_t *const p_ctrl, sf_touch_panel_v2_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Create required RTOS objects, call lower level module for hardware specific initialization, and create a thread to post touch data to user application. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. This control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*calibrate) (sf_touch_panel_v2_ctrl_t *const p_ctrl, sf_touch_panel_v2_calibrate_t const *const p_display, sf_touch_panel_v2_calibrate_t const *const p_touchscreen, ULONG const timeout)" id="calibrate"><description>
<![CDATA[<form><p>Begin calibration routine based on provided expected and actual coordinates. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Calibrate()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">sf_touch_panel_v2_api_t::open</span>. </li><li bindent="0" vspace="false"><span font="code">p_display</span> :   Expected coordinates of the display. </li><li bindent="0" vspace="false"><span font="code">p_touchscreen</span> :   Actual coordinates obtained from the touch driver. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Select TX_NO_WAIT, a value in system clock counts between 1 and 0xFFFFFFFF, or TX_WAIT_FOREVER. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*start) (sf_touch_panel_v2_ctrl_t *const p_ctrl)" id="start"><description>
<![CDATA[<form><p>Start scanning for touch events. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Start()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">sf_touch_panel_v2_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*touchDataGet) (sf_touch_panel_v2_ctrl_t *const p_ctrl, sf_touch_panel_v2_payload_t *p_payload, ULONG const timeout)" id="touchDataGet"><description>
<![CDATA[<form><p>Reads the touch data and fills in the touch payload data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_TouchDataGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. This control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_payload</span> :   Pointer to the payload to data structure. Touch data provided should be processed to logical pixel values. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Select TX_NO_WAIT, a value in system clock counts between 1 and 0xFFFFFFFF, or TX_WAIT_FOREVER. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*stop) (sf_touch_panel_v2_ctrl_t *const p_ctrl)" id="stop"><description>
<![CDATA[<form><p>Stop scanning for touch events. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Stop()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">sf_touch_panel_v2_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (sf_touch_panel_v2_ctrl_t *const p_ctrl)" id="reset"><description>
<![CDATA[<form><p>Reset touch chip if reset pin is provided. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Reset()</span></li><p><b>Note</b></p><p>This does not include calibration. Use <span font="code">sf_touch_panel_v2_api_t::calibrate</span> from the application after this function if calibration is required after reset.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">sf_touch_panel_v2_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_touch_panel_v2_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Terminate touch thread and close channel at HAL layer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Handle set in <span font="code">sf_touch_panel_v2_api_t::open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_TOUCH_PANEL_V2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used stored here. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.open" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call calibrate()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.calibrate" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="calibrate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;calibrate(${instance}.p_ctrl, ${p_display}, ${p_touchscreen}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call start()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.start" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="start" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;start(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call touchDataGet()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.touchDataGet" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="touchDataGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;touchDataGet(${instance}.p_ctrl, ${p_payload}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call stop()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.stop" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="stop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;stop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.reset" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;reset(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.close" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.versionGet" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2.callback_def.error" version="1"><moduleRef id="module.framework.sf_touch_panel_v2_on_sf_touch_panel_v2" /><content>/* ${instance:synergyProperty(module.framework.sf_touch_panel_v2.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_lx_nor" /><description>
<![CDATA[<form><p><span color="header" font="header">Port LevelX Framework Module Introduction</span></p><p>The Port LevelX Framework implements the driver APIs (sector read, sector write, block erase and block erased verify) mandated by Azure RTOS LevelX NOR component. In addition to implementing the LevelX NOR driver method, it is also responsible for updating the flash geometry to perform LevelX NOR initialization. It uses the sf_memory_api implementation to perform operations on the NOR flash.</p><p><b>Unsupported Features</b></p><p>LevelX NAND is not supported in this version of SSP.</p><p><b>Port LevelX Framework Module Features</b></p><li bindent="0" vspace="false">Implements LevelX NOR driver APIs to perform operations on NOR flash memory device.</li><li bindent="0" vspace="false">Set up NOR flash geometry.</li><p><span color="header" font="header">Port LevelX Framework Module Features</span></p><li bindent="0" vspace="false">Implements LevelX NOR driver APIs to perform operations on NOR flash memory device.</li><li bindent="0" vspace="false">Set up NOR flash geometry.</li></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_memory_qspi_nor" /><description>
<![CDATA[<form><p><span color="header" font="header">Memory Framework Module Introduction</span></p><p>The Memory Framework on sf_memory_qspi_nor module provides a high-level API for interfacing with QSPI NOR memory devices. It provides API functions for reading, writing, and erasing data in QSPI NOR Flash memory.  The Memory Framework on sf_memory_qspi_nor module is also used by the higher-level Port LevelX Framework on sf_el_lx_nor framework module when support for LevelX wear leveling is required.</p><p><b>Memory Framework Module Features</b></p><li bindent="0" vspace="false">Supports memory interface for QSPI NOR flash memory device.</li><li bindent="0" vspace="false">Supports I/O Operations on QSPI NOR flash memory device.</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="20" vspace="false">Erase</li><p><span color="header" font="header">Memory Framework Module Features</span></p><li bindent="0" vspace="false">Supports memory interface for QSPI NOR flash memory device.</li><li bindent="0" vspace="false">Supports I/O Operations on QSPI NOR flash memory device.</li><li bindent="20" vspace="false">Read</li><li bindent="20" vspace="false">Write</li><li bindent="20" vspace="false">Erase</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_memory_ctrl_t *const p_api_ctrl, sf_memory_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize Memory framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Open </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Pointer to control block. Must be declared by user. Elements set here. </li><li bindent="0" vspace="false"><span font="code">p_config</span> :   Pointer to configuration structure. All elements of this structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_memory_ctrl_t *const p_api_ctrl, uint8_t *const p_dest_address, uint32_t const memory_address, uint32_t const num_bytes)" id="read"><description>
<![CDATA[<form><p>Reads data from the specified memory device address to the location specified by the caller. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Read </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_dest_address</span> :   Destination to read the data into. </li><li bindent="0" vspace="false"><span font="code">memory_address</span> :   Address to read the data from. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   Number of bytes of data to read. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_memory_ctrl_t *const p_api_ctrl, uint8_t *const p_src_address, uint32_t const memory_address, uint32_t const num_bytes)" id="write"><description>
<![CDATA[<form><p>Writes the specified number of data bytes to the specified device memory address. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Write </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_src_address</span> :   Address to read the data to be written. </li><li bindent="0" vspace="false"><span font="code">memory_address</span> :   Address to write the data to. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   Number of bytes of data to write. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*flush) (sf_memory_ctrl_t *const p_api_ctrl)" id="flush"><description>
<![CDATA[<form><p>Performs any buffered pending writes. This function MUST be called by the application after the final write is called to complete any pending writes. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Flush </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*erase) (sf_memory_ctrl_t *const p_api_ctrl, uint32_t const memory_address, uint32_t const num_bytes)" id="erase"><description>
<![CDATA[<form><p>Erases the specified number of bytes from the memory device. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Erase </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">memory_address</span> :   Address to start the erase process at. </li><li bindent="0" vspace="false"><span font="code">num_bytes</span> :   Number of bytes of data to erase. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_memory_ctrl_t *const p_api_ctrl, sf_memory_info_t *const p_info)" id="infoGet"><description>
<![CDATA[<form><p>Returns information about the memory implementation. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_InfoGet </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><li bindent="0" vspace="false"><span font="code">p_info</span> :   Pointer to information structure. All elements of this structure will be set by the function. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_memory_ctrl_t *const p_api_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the module. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_Close </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_api_ctrl</span> :   Control block set in <span font="code">sf_memory_api_t::open</span> call. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false">SF_MEMORY_QSPI_NOR_VersionGet </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_memory_qspi_nor.open" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_memory_qspi_nor.read" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest_address}, ${memory_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_memory_qspi_nor.write" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src_address}, ${memory_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call flush()" id="module.framework.sf_memory_qspi_nor.flush" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="flush" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;flush(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call erase()" id="module.framework.sf_memory_qspi_nor.erase" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="erase" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;erase(${instance}.p_ctrl, ${memory_address}, ${num_bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_memory_qspi_nor.infoGet" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_memory_qspi_nor.close" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_memory_qspi_nor.versionGet" version="1"><moduleRef id="module.framework.sf_memory_qspi_nor"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_memory_qspi_nor.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile" /><description>
<![CDATA[<form><p><span color="header" font="header">BLE Framework Introduction</span></p><p>Bluetooth ®  Low Energy (BLE), sometimes referred to as Bluetooth Smart, is a light-weight subset of Classic Bluetooth, and was introduced as part of the Bluetooth 4.0 core specification. In contrast to Classic Bluetooth, BLE is designed to provide significantly lower power consumption. This allows Internet of Thing (IoT) devices that have stricter power capacity to transfer small amounts of data between nearby devices.</p><p>Application developers access the functionality provided by the BLE stack using its APIs. The BLE stack APIs provided by different vendors are not standardized, and as a result, Application developers have to update their code when porting to different BLE stacks.</p><p>The Synergy BLE Framework handles this issue by providing a generic interface for the underlying BLE stack provided by various vendors, thereby preventing coupling between application and vendor-specific BLE stack code. The use of generic APIs makes application development simpler and portable.</p><p>The BLE Framework provides a high-level API for BLE applications and uses the Synergy Software Package (SSP) communication framework, which in turn enables the UART driver for communication to the underlying BLE module. It also integrates the generic BLE profile framework (g_sf_ble_onboard_profile), which provides a uniform interface to BLE profiles. For the RL78G1D BLE hardware module, the generic BLE profiles are implemented by the BLE module firmware.</p><p><b>BLE Framework Module Features</b></p><li bindent="0" vspace="false">ThreadX ®  RTOS Aware and thread safe</li><li bindent="0" vspace="false">Bluetooth v4.2 compliant framework</li><li bindent="0" vspace="false">Generic Access Profile (GAP) Features</li><li bindent="20" vspace="false">User-defined advertising data</li><li bindent="20" vspace="false">Security modes 1 and 2</li><li bindent="20" vspace="false">Peripheral and central roles</li><li bindent="20" vspace="false">White list support for up to 6 devices</li><li bindent="20" vspace="false">Bonding support</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) features</li><li bindent="20" vspace="false">GATT client and server</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) APIs</li><li bindent="0" vspace="false">Generic Access Profile (GAP) APIs</li><li bindent="0" vspace="false">Generic On-board Profiles APIs</li><p><b>Note</b></p><p>The BLE and GATT on sf_ble_rl78g1d can be used as a lower-level implementation of the On-Board Profile on RL789G1D BLE Framework or on its own. </p><p><span color="header" font="header">BLE Framework Module Features</span></p><li bindent="0" vspace="false">ThreadX ®  RTOS Aware and thread safe</li><li bindent="0" vspace="false">Bluetooth v4.2 compliant framework</li><li bindent="0" vspace="false">Generic Access Profile (GAP) Features</li><li bindent="20" vspace="false">User-defined advertising data</li><li bindent="20" vspace="false">Security modes 1 and 2</li><li bindent="20" vspace="false">Peripheral and central roles</li><li bindent="20" vspace="false">White list support for up to 6 devices</li><li bindent="20" vspace="false">Bonding support</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) features</li><li bindent="20" vspace="false">GATT client and server</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) APIs</li><li bindent="0" vspace="false">Generic Access Profile (GAP) APIs</li><li bindent="0" vspace="false">Generic On-board Profiles APIs</li><p><b>Note</b></p><p>The BLE and GATT on sf_ble_rl78g1d can be used as a lower-level implementation of the On-Board Profile on RL789G1D BLE Framework or on its own. </p></form>]]>
</description><function display="ssp_err_t (*open) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, const sf_ble_onboard_profile_cfg_t *p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the interface for data transfers. </p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to BLE configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_ble_onboard_profile_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>De-initialize the interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpEnable) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_profile_callback_t p_prf_cb, sf_ble_prf_sec_t sec)" id="onbpEnable"><description>
<![CDATA[<form><p>Enable On-Board Profile Enables On-Board profile on given connection handle with specified security type. Registers user callback for the profile. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type to enable </li><li bindent="0" vspace="false"><span font="code">p_prf_cb</span> :   User callback for Profile </li><li bindent="0" vspace="false"><span font="code">sec</span> :   Security type for profile </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpDisable) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile)" id="onbpDisable"><description>
<![CDATA[<form><p>Disable On-Board Profile Disables On-Board profile on given connection handle and unregisters user callback. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type to disable </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpServerWriteData) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t characteristics, const void *p_data)" id="onbpServerWriteData"><description>
<![CDATA[<form><p>Update Server Local Database Update Local GATT database of Profile Server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type </li><li bindent="0" vspace="false"><span font="code">characteristics</span> :   Profile characteristics </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpServerSendNotification) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t characteristics, const void *p_data)" id="onbpServerSendNotification"><description>
<![CDATA[<form><p>Send notification from Server Sends Notification which will be data specific to On-Board Profile to Client. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type </li><li bindent="0" vspace="false"><span font="code">characteristics</span> :   Profile characteristics </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpServerSendIndication) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t characteristics, const void *p_data)" id="onbpServerSendIndication"><description>
<![CDATA[<form><p>Send Indication from Server Sends Indication which contains profile specific data to client. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type </li><li bindent="0" vspace="false"><span font="code">characteristics</span> :   Profile characteristics </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpClientWriteCCCD) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t cccd_char, sf_ble_cccd_val_t cccd_val)" id="onbpClientWriteCCCD"><description>
<![CDATA[<form><p>Writes CCCD configuration in Server This API writes CCCD configuration of Server and which enables or disables notification or indication from server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Parameter_Description </li><li bindent="0" vspace="false"><span font="code">cccd_char</span> :   CCCD Code </li><li bindent="0" vspace="false"><span font="code">cccd_val</span> :   Configuration data of CCCD </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpClientWriteChar) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t characteristics, const void *p_data)" id="onbpClientWriteChar"><description>
<![CDATA[<form><p>Writes GATT characteristics with data passed Writes the GATT characteristics in the Server with the data passed. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type </li><li bindent="0" vspace="false"><span font="code">characteristics</span> :   GATT characteristics code </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*onbpClientReadChar) (sf_ble_onboard_profile_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_onbp_t profile, sf_ble_onbp_char_t characteristics)" id="onbpClientReadChar"><description>
<![CDATA[<form><p>Reads GATT characteristics from Server Reads GATT characteristics from the Server for the profile specified. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure for BLE </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">profile</span> :   Profile type </li><li bindent="0" vspace="false"><span font="code">characteristics</span> :   Profile characteristics </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_ble_rl78g1d_onboard_profile.open" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_ble_rl78g1d_onboard_profile.close" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpEnable()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpEnable" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpEnable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpEnable(${instance}.p_ctrl, ${p_handle}, ${profile}, ${p_prf_cb}, ${sec});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpDisable()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpDisable" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpDisable" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpDisable(${instance}.p_ctrl, ${p_handle}, ${profile});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpServerWriteData()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpServerWriteData" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpServerWriteData" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpServerWriteData(${instance}.p_ctrl, ${p_handle}, ${profile}, ${characteristics}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpServerSendNotification()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpServerSendNotification" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpServerSendNotification" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpServerSendNotification(${instance}.p_ctrl, ${p_handle}, ${profile}, ${characteristics}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpServerSendIndication()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpServerSendIndication" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpServerSendIndication" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpServerSendIndication(${instance}.p_ctrl, ${p_handle}, ${profile}, ${characteristics}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpClientWriteCCCD()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpClientWriteCCCD" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpClientWriteCCCD" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpClientWriteCCCD(${instance}.p_ctrl, ${p_handle}, ${profile}, ${cccd_char}, ${cccd_val});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpClientWriteChar()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpClientWriteChar" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpClientWriteChar" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpClientWriteChar(${instance}.p_ctrl, ${p_handle}, ${profile}, ${characteristics}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call onbpClientReadChar()" id="module.framework.sf_ble_rl78g1d_onboard_profile.onbpClientReadChar" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="onbpClientReadChar" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;onbpClientReadChar(${instance}.p_ctrl, ${p_handle}, ${profile}, ${characteristics});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_ble_rl78g1d_onboard_profile.versionGet" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d_onboard_profile"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d_onboard_profile.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_ble_rl78g1d" /><description>
<![CDATA[<form><p><span color="header" font="header">BLE Framework Introduction</span></p><p>Bluetooth ®  Low Energy (BLE), sometimes referred to as Bluetooth Smart, is a light-weight subset of Classic Bluetooth, and was introduced as part of the Bluetooth 4.0 core specification. In contrast to Classic Bluetooth, BLE is designed to provide significantly lower power consumption. This allows Internet of Thing (IoT) devices that have stricter power capacity to transfer small amounts of data between nearby devices.</p><p>Application developers access the functionality provided by the BLE stack using its APIs. The BLE stack APIs provided by different vendors are not standardized, and as a result, Application developers have to update their code when porting to different BLE stacks.</p><p>The Synergy BLE Framework handles this issue by providing a generic interface for the underlying BLE stack provided by various vendors, thereby preventing coupling between application and vendor-specific BLE stack code. The use of generic APIs makes application development simpler and portable.</p><p>The BLE Framework provides a high-level API for BLE applications and uses the Synergy Software Package (SSP) communication framework, which in turn enables the UART driver for communication to the underlying BLE module. It also integrates the generic BLE profile framework (g_sf_ble_onboard_profile), which provides a uniform interface to BLE profiles. For the RL78G1D BLE hardware module, the generic BLE profiles are implemented by the BLE module firmware.</p><p><b>BLE Framework Module Features</b></p><li bindent="0" vspace="false">ThreadX ®  RTOS Aware and thread safe</li><li bindent="0" vspace="false">Bluetooth v4.2 compliant framework</li><li bindent="0" vspace="false">Generic Access Profile (GAP) Features</li><li bindent="20" vspace="false">User-defined advertising data</li><li bindent="20" vspace="false">Security modes 1 and 2</li><li bindent="20" vspace="false">Peripheral and central roles</li><li bindent="20" vspace="false">White list support for up to 6 devices</li><li bindent="20" vspace="false">Bonding support</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) features</li><li bindent="20" vspace="false">GATT client and server</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) APIs</li><li bindent="0" vspace="false">Generic Access Profile (GAP) APIs</li><li bindent="0" vspace="false">Generic On-board Profiles APIs</li><p><b>Note</b></p><p>The BLE and GATT on sf_ble_rl78g1d can be used as a lower-level implementation of the On-Board Profile on RL789G1D BLE Framework or on its own. </p><p><span color="header" font="header">BLE Framework Module Features</span></p><li bindent="0" vspace="false">ThreadX ®  RTOS Aware and thread safe</li><li bindent="0" vspace="false">Bluetooth v4.2 compliant framework</li><li bindent="0" vspace="false">Generic Access Profile (GAP) Features</li><li bindent="20" vspace="false">User-defined advertising data</li><li bindent="20" vspace="false">Security modes 1 and 2</li><li bindent="20" vspace="false">Peripheral and central roles</li><li bindent="20" vspace="false">White list support for up to 6 devices</li><li bindent="20" vspace="false">Bonding support</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) features</li><li bindent="20" vspace="false">GATT client and server</li><li bindent="0" vspace="false">Generic Attribute Profile (GATT) APIs</li><li bindent="0" vspace="false">Generic Access Profile (GAP) APIs</li><li bindent="0" vspace="false">Generic On-board Profiles APIs</li><p><b>Note</b></p><p>The BLE and GATT on sf_ble_rl78g1d can be used as a lower-level implementation of the On-Board Profile on RL789G1D BLE Framework or on its own. </p></form>]]>
</description><function display="ssp_err_t (*open) (sf_ble_ctrl_t *const p_ctrl, const sf_ble_cfg_t *p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the interface for data transfers. </p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to BLE configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_ble_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>De-initialize the interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_info_t *p_ble_info)" id="infoGet"><description>
<![CDATA[<form><p>Get BLE module information like chipset information and RSSI value. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">p_ble_info</span> :   Pointer to module information </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisionGet) (sf_ble_ctrl_t *const p_ctrl, sf_ble_provisioning_t *p_ble_provisioning)" id="provisionGet"><description>
<![CDATA[<form><p>Reads the current BLE Provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_ble_provisioning</span> :   current provisioning information </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisionSet) (sf_ble_ctrl_t *const p_ctrl, const sf_ble_provisioning_t *p_ble_provisioning)" id="provisionSet"><description>
<![CDATA[<form><p>Provisions the BLE Driver and set bonding and security modes as provisioned. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_ble_provisioning</span> :   Pointer to BLE provisioning structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scan) (sf_ble_ctrl_t *const p_ctrl, sf_ble_scan_t *p_scan, uint8_t *p_cnt, sf_ble_scan_info_t *p_scan_info)" id="scan"><description>
<![CDATA[<form><p>Scans for available BLE devices and return the list to the caller. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_scan</span> :   Pointer to scan information structure </li><li bindent="0" vspace="false"><span font="code">p_cnt</span> :   Pointer to number of BLE devices scanned </li><li bindent="0" vspace="false"><span font="code">p_scan_info</span> :   Pointer to scan information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*advertisementStart) (sf_ble_ctrl_t *const p_ctrl, sf_ble_adv_info_t *const p_advt_info)" id="advertisementStart"><description>
<![CDATA[<form><p>Make the device discoverable by broadcasting device information to remote devices. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_advt_info</span> :   Pointer to advertisement information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*advertisementStop) (sf_ble_ctrl_t *const p_ctrl)" id="advertisementStop"><description>
<![CDATA[<form><p>Stop the device from being discoverable. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*whitelistAdd) (sf_ble_ctrl_t *const p_ctrl, const uint8_t *p_bd_addr)" id="whitelistAdd"><description>
<![CDATA[<form><p>Add specified devices to whitelist. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_bd_addr</span> :   Pointer to BLE address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*whitelistDel) (sf_ble_ctrl_t *const p_ctrl, const uint8_t *p_bd_addr)" id="whitelistDel"><description>
<![CDATA[<form><p>Remove specified devices from whitelist. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_bd_addr</span> :   Pointer to BLE address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*bondingStart) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, const uint8_t *p_bd_addr, sf_ble_bonding_start_t *p_bonding_start)" id="bondingStart"><description>
<![CDATA[<form><p>Initiate bonding process with remote BLE device and exchange security keys if enabled. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle. </li><li bindent="0" vspace="false"><span font="code">p_bd_addr</span> :   Pointer to BLE address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*bondingResponse) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, const uint8_t *p_bd_addr, sf_ble_bonding_response_t *p_bonding_resp)" id="bondingResponse"><description>
<![CDATA[<form><p>Respond to the bonding request from the remote BLE device. Send bonding response on reception of bonding indication. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><li bindent="0" vspace="false"><span font="code">p_bd_addr</span> :   Pointer to BLE address </li><li bindent="0" vspace="false"><span font="code">p_bonding_resp</span> :   Pointer to Bonding address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*startEncryption) (sf_ble_ctrl_t *const p_ctrl, sf_ble_sm_enc_info_t const *p_enc_info)" id="startEncryption"><description>
<![CDATA[<form><p>Start encryption over a connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_enc_info</span> :   information for starting encryption </li><p /></form>]]>
</description></function><function display="ssp_err_t (*connect) (sf_ble_ctrl_t *const p_ctrl, sf_ble_connection_t const *const p_conn, sf_ble_conn_handle_t *p_handle)" id="connect"><description>
<![CDATA[<form><p>Connect to a remote BLE device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_conn</span> :   Pointer to connection information </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*listen) (sf_ble_ctrl_t *const p_ctrl)" id="listen"><description>
<![CDATA[<form><p>Listen for connection request from remote device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*authorization) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle)" id="authorization"><description>
<![CDATA[<form><p>Indicates that the specified remote device has been authorized by user. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*disconnect) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle)" id="disconnect"><description>
<![CDATA[<form><p>Terminate connection with remote BLE device. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle </li><p /></form>]]>
</description></function><function display="ssp_err_t (*setTxPower) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *const p_handle, sf_ble_set_tx_pwr_info_t *p_tx_power_info)" id="setTxPower"><description>
<![CDATA[<form><p>Sets the transmit power for the procedure specified by the connection handle. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the BLE module. </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Pointer to connection handle. If transmit power is to be set before advertisement or connecting to remote device then pass connection handle as SF_BLE_TX_POWER_CONNECTION_HANDLE value else pass connection handle of remote device </li><li bindent="0" vspace="false"><span font="code">p_tx_power_info</span> :   Pointer to TX power information </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattAddCustomProfiles) (sf_ble_ctrl_t *const p_ctrl, sf_ble_svc_attribute_t *p_svc_attr, uint32_t svc_attr_len, sf_ble_char_attribute_t *p_char_attr, uint32_t char_attr_len)" id="gattAddCustomProfiles"><description>
<![CDATA[<form><p>Add Custom Profile to GATT Database. </p><p>This function is called with list of service and characteristics which is to be added to GATT database. Services and characteristics which were previously added will be removed and newly passed services and characteristics will be added.</p><p>If services and characteristics were previously added and now those services and characteristics are to be removed and no new services and characteristics are to be added , then call this API with service and characteristics length as zero</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_svc_attr</span> :   List of Services to add </li><li bindent="0" vspace="false"><span font="code">svc_attr_len</span> :   No of elements in services list </li><li bindent="0" vspace="false"><span font="code">p_char_attr</span> :   List of Characteristics to add </li><li bindent="0" vspace="false"><span font="code">char_attr_len</span> :   No of elements in Characteristics list </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattServiceDiscovery) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_service_discovery_req_t const *const p_sf_ble_svc_dscv_req, sf_ble_service_discovery_rsp_t *const p_sf_ble_svc_dscv_rsp, uint32_t *const p_rsp_cnt)" id="gattServiceDiscovery"><description>
<![CDATA[<form><p>Perform service discovery used by GATT client.Perform service discovery on remote GATT server and get results. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">p_sf_ble_svc_dscv_req</span> :   Pointer to service discovery request </li><li bindent="0" vspace="false"><span font="code">p_sf_ble_svc_dscv_rsp</span> :   Pointer to service discovery response </li><li bindent="0" vspace="false"><span font="code">p_rsp_cnt</span> :   Input Size specifying maximum number of service discovery results which can be stored in response, output specifying number of service discovery results stored in response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharDiscovery) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_char_discovery_req_t const *const p_sf_ble_char_dscv_req, sf_ble_char_discovery_rsp_t *const p_sf_ble_char_dscv_rsp, uint32_t *const p_rsp_cnt)" id="gattCharDiscovery"><description>
<![CDATA[<form><p>Perform characteristics discovery used by GATT client.Perform characteristics discovery on remote GATT server and get results. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">p_sf_ble_char_dscv_req</span> :   Pointer to characteristics discovery request </li><li bindent="0" vspace="false"><span font="code">p_sf_ble_char_dscv_rsp</span> :   Pointer to characteristics discovery response </li><li bindent="0" vspace="false"><span font="code">p_rsp_cnt</span> :   Input Size specifying maximum number of characteristics discovery results which can be stored in response, output specifying number of characteristics discovery results stored in response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharDescDiscovery) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, uint16_t start_handle, uint16_t end_handle, sf_ble_char_desc_discovery_rsp_t *const p_sf_ble_chardesc_dscv_rsp, uint32_t *const p_rsp_cnt)" id="gattCharDescDiscovery"><description>
<![CDATA[<form><p>Perform characteristics descriptor discovery used by GATT client. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">start_handle</span> :   Start handle from set of handle ranges to be used in discovery </li><li bindent="0" vspace="false"><span font="code">end_handle</span> :   End handle from set of handle ranges to be used in discovery </li><li bindent="0" vspace="false"><span font="code">p_sf_ble_chardesc_dscv_rsp</span> :   Pointer to characteristics descriptor discovery response </li><li bindent="0" vspace="false"><span font="code">p_rsp_cnt</span> :   Input Size specifying maximum number of characteristics descriptor discovery results which can be stored in response, output specifying number of characteristics descriptor discovery results stored in response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharRead) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_char_read_req_t const *const p_char_read_req, sf_ble_char_read_rsp_t *const p_char_read_rsp)" id="gattCharRead"><description>
<![CDATA[<form><p>Perform read characteristic used by GATT client.Read characteristic value from remote GATT server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">p_char_read_req</span> :   Pointer to characteristic read request </li><li bindent="0" vspace="false"><span font="code">p_char_read_rsp</span> :   Pointer to characteristic read response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharWrite) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_char_write_req_t const *const p_char_write_req)" id="gattCharWrite"><description>
<![CDATA[<form><p>Perform write characteristic used by GATT client.Write characteristic value on remote GATT server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">p_char_write_req</span> :   Pointer to characteristic write request </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharExecuteWrite) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, sf_ble_execute_write_t execute_flag)" id="gattCharExecuteWrite"><description>
<![CDATA[<form><p>Perform execute write on all pending write operations, used by GATT client.Execute or cancel all prepared writes of characteristics on remote GATT server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">execute_flag</span> :   Flag specifying whether to execute or cancel pending writes </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattCharWriteLocal) (sf_ble_ctrl_t *const p_ctrl, uint16_t char_handle, uint16_t data_length, uint8_t *const p_data)" id="gattCharWriteLocal"><description>
<![CDATA[<form><p>Perform local characteristic write used by GATT server.Writes local characteristic value on GATT server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">char_handle</span> :   Characteristic handle </li><li bindent="0" vspace="false"><span font="code">data_length</span> :   Length of data to write </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to data </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattSendNotify) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, uint16_t char_handle)" id="gattSendNotify"><description>
<![CDATA[<form><p>Send notification to GATT client, used by GATT server. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">char_handle</span> :   Characteristic handle whose value will be notified </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattSendIndicate) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, uint16_t char_handle)" id="gattSendIndicate"><description>
<![CDATA[<form><p>Send indication to GATT client, used by GATT server.Send indication to remote GATT client. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">char_handle</span> :   Characteristic handle whose value will be indicated </li><p /></form>]]>
</description></function><function display="ssp_err_t (*gattWriteResponse) (sf_ble_ctrl_t *const p_ctrl, sf_ble_conn_handle_t *p_handle, uint16_t handle, sf_ble_attribute_error_code_t error_code)" id="gattWriteResponse"><description>
<![CDATA[<form><p>Send response to write operation received by GATT client, used by GATT server.Send response for write request received from remote GATT client. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control structure </li><li bindent="0" vspace="false"><span font="code">p_handle</span> :   Connection handle </li><li bindent="0" vspace="false"><span font="code">handle</span> :   Characteristic handle used for write operation </li><li bindent="0" vspace="false"><span font="code">error_code</span> :   Characteristic write operation error code to be sent in response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_ble_rl78g1d.open" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_ble_rl78g1d.close" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_ble_rl78g1d.infoGet" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_handle}, ${p_ble_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisionGet()" id="module.framework.sf_ble_rl78g1d.provisionGet" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="provisionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;provisionGet(${instance}.p_ctrl, ${p_ble_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisionSet()" id="module.framework.sf_ble_rl78g1d.provisionSet" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="provisionSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;provisionSet(${instance}.p_ctrl, ${p_ble_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scan()" id="module.framework.sf_ble_rl78g1d.scan" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="scan" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;scan(${instance}.p_ctrl, ${p_scan}, ${p_cnt}, ${p_scan_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call advertisementStart()" id="module.framework.sf_ble_rl78g1d.advertisementStart" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="advertisementStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;advertisementStart(${instance}.p_ctrl, ${p_advt_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call advertisementStop()" id="module.framework.sf_ble_rl78g1d.advertisementStop" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="advertisementStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;advertisementStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call whitelistAdd()" id="module.framework.sf_ble_rl78g1d.whitelistAdd" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="whitelistAdd" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;whitelistAdd(${instance}.p_ctrl, ${p_bd_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call whitelistDel()" id="module.framework.sf_ble_rl78g1d.whitelistDel" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="whitelistDel" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;whitelistDel(${instance}.p_ctrl, ${p_bd_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call bondingStart()" id="module.framework.sf_ble_rl78g1d.bondingStart" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="bondingStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;bondingStart(${instance}.p_ctrl, ${p_handle}, ${p_bd_addr}, ${p_bonding_start});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call bondingResponse()" id="module.framework.sf_ble_rl78g1d.bondingResponse" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="bondingResponse" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;bondingResponse(${instance}.p_ctrl, ${p_handle}, ${p_bd_addr}, ${p_bonding_resp});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call startEncryption()" id="module.framework.sf_ble_rl78g1d.startEncryption" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="startEncryption" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;startEncryption(${instance}.p_ctrl, ${p_enc_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call connect()" id="module.framework.sf_ble_rl78g1d.connect" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="connect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;connect(${instance}.p_ctrl, ${p_conn}, ${p_handle});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call listen()" id="module.framework.sf_ble_rl78g1d.listen" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="listen" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;listen(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call authorization()" id="module.framework.sf_ble_rl78g1d.authorization" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="authorization" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;authorization(${instance}.p_ctrl, ${p_handle});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call disconnect()" id="module.framework.sf_ble_rl78g1d.disconnect" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="disconnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;disconnect(${instance}.p_ctrl, ${p_handle});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call setTxPower()" id="module.framework.sf_ble_rl78g1d.setTxPower" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="setTxPower" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;setTxPower(${instance}.p_ctrl, ${p_handle}, ${p_tx_power_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattAddCustomProfiles()" id="module.framework.sf_ble_rl78g1d.gattAddCustomProfiles" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattAddCustomProfiles" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattAddCustomProfiles(${instance}.p_ctrl, ${p_svc_attr}, ${svc_attr_len}, ${p_char_attr}, ${char_attr_len});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattServiceDiscovery()" id="module.framework.sf_ble_rl78g1d.gattServiceDiscovery" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattServiceDiscovery" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattServiceDiscovery(${instance}.p_ctrl, ${p_handle}, ${p_sf_ble_svc_dscv_req}, ${p_sf_ble_svc_dscv_rsp}, ${p_rsp_cnt});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharDiscovery()" id="module.framework.sf_ble_rl78g1d.gattCharDiscovery" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharDiscovery" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharDiscovery(${instance}.p_ctrl, ${p_handle}, ${p_sf_ble_char_dscv_req}, ${p_sf_ble_char_dscv_rsp}, ${p_rsp_cnt});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharDescDiscovery()" id="module.framework.sf_ble_rl78g1d.gattCharDescDiscovery" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharDescDiscovery" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharDescDiscovery(${instance}.p_ctrl, ${p_handle}, ${start_handle}, ${end_handle}, ${p_sf_ble_chardesc_dscv_rsp}, ${p_rsp_cnt});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharRead()" id="module.framework.sf_ble_rl78g1d.gattCharRead" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharRead" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharRead(${instance}.p_ctrl, ${p_handle}, ${p_char_read_req}, ${p_char_read_rsp});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharWrite()" id="module.framework.sf_ble_rl78g1d.gattCharWrite" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharWrite(${instance}.p_ctrl, ${p_handle}, ${p_char_write_req});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharExecuteWrite()" id="module.framework.sf_ble_rl78g1d.gattCharExecuteWrite" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharExecuteWrite" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharExecuteWrite(${instance}.p_ctrl, ${p_handle}, ${execute_flag});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattCharWriteLocal()" id="module.framework.sf_ble_rl78g1d.gattCharWriteLocal" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattCharWriteLocal" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattCharWriteLocal(${instance}.p_ctrl, ${char_handle}, ${data_length}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattSendNotify()" id="module.framework.sf_ble_rl78g1d.gattSendNotify" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattSendNotify" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattSendNotify(${instance}.p_ctrl, ${p_handle}, ${char_handle});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattSendIndicate()" id="module.framework.sf_ble_rl78g1d.gattSendIndicate" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattSendIndicate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattSendIndicate(${instance}.p_ctrl, ${p_handle}, ${char_handle});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call gattWriteResponse()" id="module.framework.sf_ble_rl78g1d.gattWriteResponse" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="gattWriteResponse" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;gattWriteResponse(${instance}.p_ctrl, ${p_handle}, ${handle}, ${error_code});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_ble_rl78g1d.versionGet" version="1"><moduleRef id="module.framework.sf_ble_rl78g1d"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_ble_rl78g1d.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_cat1_socket" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_socket_ctrl_t *p_ctrl, sf_cellular_socket_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular Socket interface configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_socket_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to SSP Version structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ping) (sf_cellular_socket_ctrl_t *const p_ctrl, ULONG *p_ip_addr, uint32_t count, uint32_t interval_ms)" id="ping"><description>
<![CDATA[<form><p>Pointer to a function which is used to ping the IP address.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_ip_addr</span> :   Pointer to IP address to ping </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of ping attempts </li><li bindent="0" vspace="false"><span font="code">interval_ms</span> :   Interval between ping attempts </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_cat1_socket.open" version="1"><moduleRef id="module.framework.sf_cellular_cat1_socket"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat1_socket.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_cat1_socket.close" version="1"><moduleRef id="module.framework.sf_cellular_cat1_socket"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat1_socket.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_cat1_socket.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1_socket"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat1_socket.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ping()" id="module.framework.sf_cellular_cat1_socket.ping" version="1"><moduleRef id="module.framework.sf_cellular_cat1_socket"><function id="ping" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat1_socket.name)}.p_api-&gt;ping(${instance}.p_ctrl, ${p_ip_addr}, ${count}, ${interval_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_cat3_socket" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_socket_ctrl_t *p_ctrl, sf_cellular_socket_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular Socket interface configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_socket_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to SSP Version structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ping) (sf_cellular_socket_ctrl_t *const p_ctrl, ULONG *p_ip_addr, uint32_t count, uint32_t interval_ms)" id="ping"><description>
<![CDATA[<form><p>Pointer to a function which is used to ping the IP address.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_ip_addr</span> :   Pointer to IP address to ping </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of ping attempts </li><li bindent="0" vspace="false"><span font="code">interval_ms</span> :   Interval between ping attempts </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_cat3_socket.open" version="1"><moduleRef id="module.framework.sf_cellular_cat3_socket"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat3_socket.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_cat3_socket.close" version="1"><moduleRef id="module.framework.sf_cellular_cat3_socket"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat3_socket.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_cat3_socket.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3_socket"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat3_socket.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ping()" id="module.framework.sf_cellular_cat3_socket.ping" version="1"><moduleRef id="module.framework.sf_cellular_cat3_socket"><function id="ping" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_cat3_socket.name)}.p_api-&gt;ping(${instance}.p_ctrl, ${p_ip_addr}, ${count}, ${interval_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_socket_ctrl_t *p_ctrl, sf_cellular_socket_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular Socket interface configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_socket_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module Socket interface. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to SSP Version structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ping) (sf_cellular_socket_ctrl_t *const p_ctrl, ULONG *p_ip_addr, uint32_t count, uint32_t interval_ms)" id="ping"><description>
<![CDATA[<form><p>Pointer to a function which is used to ping the IP address.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_ip_addr</span> :   Pointer to IP address to ping </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of ping attempts </li><li bindent="0" vspace="false"><span font="code">interval_ms</span> :   Interval between ping attempts </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_qctlcatm1_socket.open" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_qctlcatm1_socket.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_qctlcatm1_socket.close" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_qctlcatm1_socket.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_qctlcatm1_socket.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_qctlcatm1_socket.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ping()" id="module.framework.sf_cellular_qctlcatm1_socket.ping" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket"><function id="ping" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular_qctlcatm1_socket.name)}.p_api-&gt;ping(${instance}.p_ctrl, ${p_ip_addr}, ${count}, ${interval_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_cellular_qctlcatm1_socket.callback_def.error" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1_socket" /><content>/* ${instance:synergyProperty(module.framework.sf_cellular_qctlcatm1_socket.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_cat1" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_ctrl_t *p_ctrl, sf_cellular_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes and enables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. . </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t *const p_cellular_provisioning)" id="provisioningGet"><description>
<![CDATA[<form><p>Pointer to function to Get the Cellular module provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningSet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t const *const p_cellular_provisioning)" id="provisioningSet"><description>
<![CDATA[<form><p>Pointer to function to Set the Cellular module's provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_info_t *const p_cellular_info)" id="infoGet"><description>
<![CDATA[<form><p>Reads the Cellular module's information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_info</span> :   Pointer to Cellular info structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statisticsGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_stats_t *const p_cellular_device_stats)" id="statisticsGet"><description>
<![CDATA[<form><p>Returns statistics information of Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_device_stats</span> :   Pointer to Cellular statistics information structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*transmit) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_buf, uint32_t length)" id="transmit"><description>
<![CDATA[<form><p>Passes packet buffer to PPP stack for transmission. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_buf</span> :   Pointer to packet buffer to transmit </li><li bindent="0" vspace="false"><span font="code">length</span> :   Length of packet buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkConnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkConnect"><description>
<![CDATA[<form><p>Initiates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkDisconnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkDisconnect"><description>
<![CDATA[<form><p>Terminates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkStatusGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_network_status_t *p_network_status)" id="networkStatusGet"><description>
<![CDATA[<form><p>Get Network Status information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_network_status</span> :   Pointer to Network Status structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simPinSet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_old_pin, uint8_t *const p_new_pin)" id="simPinSet"><description>
<![CDATA[<form><p>Set SIM Pin. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_old_pin</span> :   Pointer to char array containing current 4 digit pin. </li><li bindent="0" vspace="false"><span font="code">p_new_pin</span> :   Pointer to char array containing new 4 digit pin. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simLock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simLock"><description>
<![CDATA[<form><p>Locks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to lock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simUnlock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simUnlock"><description>
<![CDATA[<form><p>Unlocks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to unlock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simIDGet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *p_sim_id)" id="simIDGet"><description>
<![CDATA[<form><p>Gets the SIM ID. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_sim_id</span> :   SIM ID </li><p /></form>]]>
</description></function><function display="ssp_err_t (*commandSend) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_cmd_resp_t *const p_input_at_command, sf_cellular_cmd_resp_t *const p_output, uint32_t const timeout)" id="commandSend"><description>
<![CDATA[<form><p>Send AT command directly to Cellular Modem. </p><p>This API will send AT command provided by user to the Cellular Modem and will collect the response from the Modem and will send it back to the user. If Modem is in Data Mode when this API is called then Framework will first switch Modem to Command Mode, then send the AT command and collect the response and then switches the Modem back to Data Mode.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_input_at_command</span> :   Pointer to structure which contains Modem command to send </li><li bindent="0" vspace="false"><span font="code">p_output</span> :   Pointer to buffer in which response will be sent to user, Also user will pass the size of the buffer which is pointed by p_output </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout for which framework will wait for response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaCheck) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotacheck)" id="fotaCheck"><description>
<![CDATA[<form><p>Checks for Available Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotacheck</span> :   Pointer to fota check specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStart) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastart)" id="fotaStart"><description>
<![CDATA[<form><p>Starts the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastart</span> :   Pointer to fota start specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStop) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastop)" id="fotaStop"><description>
<![CDATA[<form><p>Stops the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastop</span> :   Pointer to fota stop specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_reset_type_t reset_type)" id="reset"><description>
<![CDATA[<form><p>Reset cellular module. This <span font="code">reset()</span> API will only work when module is opened. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">reset_type</span> :   Reset type </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_cat1.open" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_cat1.close" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningGet()" id="module.framework.sf_cellular_cat1.provisioningGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="provisioningGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningGet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningSet()" id="module.framework.sf_cellular_cat1.provisioningSet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="provisioningSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningSet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_cellular_cat1.infoGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_cellular_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statisticsGet()" id="module.framework.sf_cellular_cat1.statisticsGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="statisticsGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;statisticsGet(${instance}.p_ctrl, ${p_cellular_device_stats});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call transmit()" id="module.framework.sf_cellular_cat1.transmit" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="transmit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;transmit(${instance}.p_ctrl, ${p_buf}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_cat1.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkConnect()" id="module.framework.sf_cellular_cat1.networkConnect" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="networkConnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkConnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkDisconnect()" id="module.framework.sf_cellular_cat1.networkDisconnect" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="networkDisconnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkDisconnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkStatusGet()" id="module.framework.sf_cellular_cat1.networkStatusGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="networkStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkStatusGet(${instance}.p_ctrl, ${p_network_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simPinSet()" id="module.framework.sf_cellular_cat1.simPinSet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="simPinSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simPinSet(${instance}.p_ctrl, ${p_old_pin}, ${p_new_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simLock()" id="module.framework.sf_cellular_cat1.simLock" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="simLock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simLock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simUnlock()" id="module.framework.sf_cellular_cat1.simUnlock" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="simUnlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simUnlock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simIDGet()" id="module.framework.sf_cellular_cat1.simIDGet" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="simIDGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simIDGet(${instance}.p_ctrl, ${p_sim_id});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call commandSend()" id="module.framework.sf_cellular_cat1.commandSend" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="commandSend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;commandSend(${instance}.p_ctrl, ${p_input_at_command}, ${p_output}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaCheck()" id="module.framework.sf_cellular_cat1.fotaCheck" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="fotaCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaCheck(${instance}.p_ctrl, ${p_fotacheck});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStart()" id="module.framework.sf_cellular_cat1.fotaStart" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="fotaStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStart(${instance}.p_ctrl, ${p_fotastart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStop()" id="module.framework.sf_cellular_cat1.fotaStop" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="fotaStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStop(${instance}.p_ctrl, ${p_fotastop});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.framework.sf_cellular_cat1.reset" version="1"><moduleRef id="module.framework.sf_cellular_cat1"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${reset_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Data Received callback function definition" id="module.framework.sf_cellular_cat1.callback_def.0" version="1"><moduleRef id="module.framework.sf_cellular_cat1" /><content>/* Data Received callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_cat1.p_recv_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Provisioning callback function definition" id="module.framework.sf_cellular_cat1.callback_def.1" version="1"><moduleRef id="module.framework.sf_cellular_cat1" /><content>/* Provisioning callback function */
ssp_err_t ${callback_function:synergyProperty(module.framework.sf_cellular_cat1.p_prov_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_cat3" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_ctrl_t *p_ctrl, sf_cellular_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes and enables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. . </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t *const p_cellular_provisioning)" id="provisioningGet"><description>
<![CDATA[<form><p>Pointer to function to Get the Cellular module provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningSet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t const *const p_cellular_provisioning)" id="provisioningSet"><description>
<![CDATA[<form><p>Pointer to function to Set the Cellular module's provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_info_t *const p_cellular_info)" id="infoGet"><description>
<![CDATA[<form><p>Reads the Cellular module's information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_info</span> :   Pointer to Cellular info structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statisticsGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_stats_t *const p_cellular_device_stats)" id="statisticsGet"><description>
<![CDATA[<form><p>Returns statistics information of Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_device_stats</span> :   Pointer to Cellular statistics information structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*transmit) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_buf, uint32_t length)" id="transmit"><description>
<![CDATA[<form><p>Passes packet buffer to PPP stack for transmission. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_buf</span> :   Pointer to packet buffer to transmit </li><li bindent="0" vspace="false"><span font="code">length</span> :   Length of packet buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkConnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkConnect"><description>
<![CDATA[<form><p>Initiates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkDisconnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkDisconnect"><description>
<![CDATA[<form><p>Terminates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkStatusGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_network_status_t *p_network_status)" id="networkStatusGet"><description>
<![CDATA[<form><p>Get Network Status information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_network_status</span> :   Pointer to Network Status structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simPinSet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_old_pin, uint8_t *const p_new_pin)" id="simPinSet"><description>
<![CDATA[<form><p>Set SIM Pin. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_old_pin</span> :   Pointer to char array containing current 4 digit pin. </li><li bindent="0" vspace="false"><span font="code">p_new_pin</span> :   Pointer to char array containing new 4 digit pin. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simLock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simLock"><description>
<![CDATA[<form><p>Locks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to lock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simUnlock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simUnlock"><description>
<![CDATA[<form><p>Unlocks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to unlock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simIDGet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *p_sim_id)" id="simIDGet"><description>
<![CDATA[<form><p>Gets the SIM ID. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_sim_id</span> :   SIM ID </li><p /></form>]]>
</description></function><function display="ssp_err_t (*commandSend) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_cmd_resp_t *const p_input_at_command, sf_cellular_cmd_resp_t *const p_output, uint32_t const timeout)" id="commandSend"><description>
<![CDATA[<form><p>Send AT command directly to Cellular Modem. </p><p>This API will send AT command provided by user to the Cellular Modem and will collect the response from the Modem and will send it back to the user. If Modem is in Data Mode when this API is called then Framework will first switch Modem to Command Mode, then send the AT command and collect the response and then switches the Modem back to Data Mode.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_input_at_command</span> :   Pointer to structure which contains Modem command to send </li><li bindent="0" vspace="false"><span font="code">p_output</span> :   Pointer to buffer in which response will be sent to user, Also user will pass the size of the buffer which is pointed by p_output </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout for which framework will wait for response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaCheck) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotacheck)" id="fotaCheck"><description>
<![CDATA[<form><p>Checks for Available Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotacheck</span> :   Pointer to fota check specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStart) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastart)" id="fotaStart"><description>
<![CDATA[<form><p>Starts the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastart</span> :   Pointer to fota start specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStop) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastop)" id="fotaStop"><description>
<![CDATA[<form><p>Stops the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastop</span> :   Pointer to fota stop specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_reset_type_t reset_type)" id="reset"><description>
<![CDATA[<form><p>Reset cellular module. This <span font="code">reset()</span> API will only work when module is opened. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">reset_type</span> :   Reset type </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_cat3.open" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_cat3.close" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningGet()" id="module.framework.sf_cellular_cat3.provisioningGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="provisioningGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningGet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningSet()" id="module.framework.sf_cellular_cat3.provisioningSet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="provisioningSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningSet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_cellular_cat3.infoGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_cellular_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statisticsGet()" id="module.framework.sf_cellular_cat3.statisticsGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="statisticsGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;statisticsGet(${instance}.p_ctrl, ${p_cellular_device_stats});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call transmit()" id="module.framework.sf_cellular_cat3.transmit" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="transmit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;transmit(${instance}.p_ctrl, ${p_buf}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_cat3.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkConnect()" id="module.framework.sf_cellular_cat3.networkConnect" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="networkConnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkConnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkDisconnect()" id="module.framework.sf_cellular_cat3.networkDisconnect" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="networkDisconnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkDisconnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkStatusGet()" id="module.framework.sf_cellular_cat3.networkStatusGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="networkStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkStatusGet(${instance}.p_ctrl, ${p_network_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simPinSet()" id="module.framework.sf_cellular_cat3.simPinSet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="simPinSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simPinSet(${instance}.p_ctrl, ${p_old_pin}, ${p_new_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simLock()" id="module.framework.sf_cellular_cat3.simLock" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="simLock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simLock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simUnlock()" id="module.framework.sf_cellular_cat3.simUnlock" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="simUnlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simUnlock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simIDGet()" id="module.framework.sf_cellular_cat3.simIDGet" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="simIDGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simIDGet(${instance}.p_ctrl, ${p_sim_id});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call commandSend()" id="module.framework.sf_cellular_cat3.commandSend" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="commandSend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;commandSend(${instance}.p_ctrl, ${p_input_at_command}, ${p_output}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaCheck()" id="module.framework.sf_cellular_cat3.fotaCheck" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="fotaCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaCheck(${instance}.p_ctrl, ${p_fotacheck});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStart()" id="module.framework.sf_cellular_cat3.fotaStart" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="fotaStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStart(${instance}.p_ctrl, ${p_fotastart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStop()" id="module.framework.sf_cellular_cat3.fotaStop" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="fotaStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStop(${instance}.p_ctrl, ${p_fotastop});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.framework.sf_cellular_cat3.reset" version="1"><moduleRef id="module.framework.sf_cellular_cat3"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${reset_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Data Received callback function definition" id="module.framework.sf_cellular_cat3.callback_def.0" version="1"><moduleRef id="module.framework.sf_cellular_cat3" /><content>/* Data Received callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_cat3.p_recv_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Provisioning callback function definition" id="module.framework.sf_cellular_cat3.callback_def.1" version="1"><moduleRef id="module.framework.sf_cellular_cat3" /><content>/* Provisioning callback function */
ssp_err_t ${callback_function:synergyProperty(module.framework.sf_cellular_cat3.p_prov_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_qctlcatm1" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_cellular_ctrl_t *p_ctrl, sf_cellular_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes and enables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to Cellular configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_cellular_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Disables the Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. . </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t *const p_cellular_provisioning)" id="provisioningGet"><description>
<![CDATA[<form><p>Pointer to function to Get the Cellular module provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningSet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_provisioning_t const *const p_cellular_provisioning)" id="provisioningSet"><description>
<![CDATA[<form><p>Pointer to function to Set the Cellular module's provisioning information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_provisioning</span> :   Pointer to Cellular provisioning structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_info_t *const p_cellular_info)" id="infoGet"><description>
<![CDATA[<form><p>Reads the Cellular module's information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_info</span> :   Pointer to Cellular info structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statisticsGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_stats_t *const p_cellular_device_stats)" id="statisticsGet"><description>
<![CDATA[<form><p>Returns statistics information of Cellular module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_cellular_device_stats</span> :   Pointer to Cellular statistics information structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*transmit) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_buf, uint32_t length)" id="transmit"><description>
<![CDATA[<form><p>Passes packet buffer to PPP stack for transmission. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_buf</span> :   Pointer to packet buffer to transmit </li><li bindent="0" vspace="false"><span font="code">length</span> :   Length of packet buffer </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkConnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkConnect"><description>
<![CDATA[<form><p>Initiates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkDisconnect) (sf_cellular_ctrl_t *const p_ctrl)" id="networkDisconnect"><description>
<![CDATA[<form><p>Terminates the Data connection. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*networkStatusGet) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_network_status_t *p_network_status)" id="networkStatusGet"><description>
<![CDATA[<form><p>Get Network Status information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_network_status</span> :   Pointer to Network Status structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simPinSet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_old_pin, uint8_t *const p_new_pin)" id="simPinSet"><description>
<![CDATA[<form><p>Set SIM Pin. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_old_pin</span> :   Pointer to char array containing current 4 digit pin. </li><li bindent="0" vspace="false"><span font="code">p_new_pin</span> :   Pointer to char array containing new 4 digit pin. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simLock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simLock"><description>
<![CDATA[<form><p>Locks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to lock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simUnlock) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *const p_pin)" id="simUnlock"><description>
<![CDATA[<form><p>Unlocks SIM. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_pin</span> :   PIN number to unlock the SIM </li><p /></form>]]>
</description></function><function display="ssp_err_t (*simIDGet) (sf_cellular_ctrl_t *const p_ctrl, uint8_t *p_sim_id)" id="simIDGet"><description>
<![CDATA[<form><p>Gets the SIM ID. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_sim_id</span> :   SIM ID </li><p /></form>]]>
</description></function><function display="ssp_err_t (*commandSend) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_cmd_resp_t *const p_input_at_command, sf_cellular_cmd_resp_t *const p_output, uint32_t const timeout)" id="commandSend"><description>
<![CDATA[<form><p>Send AT command directly to Cellular Modem. </p><p>This API will send AT command provided by user to the Cellular Modem and will collect the response from the Modem and will send it back to the user. If Modem is in Data Mode when this API is called then Framework will first switch Modem to Command Mode, then send the AT command and collect the response and then switches the Modem back to Data Mode.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_input_at_command</span> :   Pointer to structure which contains Modem command to send </li><li bindent="0" vspace="false"><span font="code">p_output</span> :   Pointer to buffer in which response will be sent to user, Also user will pass the size of the buffer which is pointed by p_output </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout for which framework will wait for response </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaCheck) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotacheck)" id="fotaCheck"><description>
<![CDATA[<form><p>Checks for Available Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotacheck</span> :   Pointer to fota check specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStart) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastart)" id="fotaStart"><description>
<![CDATA[<form><p>Starts the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastart</span> :   Pointer to fota start specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*fotaStop) (sf_cellular_ctrl_t *const p_ctrl, void *p_fotastop)" id="fotaStop"><description>
<![CDATA[<form><p>Stops the Firmware upgrade. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">p_fotastop</span> :   Pointer to fota stop specific data structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*reset) (sf_cellular_ctrl_t *const p_ctrl, sf_cellular_reset_type_t reset_type)" id="reset"><description>
<![CDATA[<form><p>Reset cellular module. This <span font="code">reset()</span> API will only work when module is opened. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the Cellular module. </li><li bindent="0" vspace="false"><span font="code">reset_type</span> :   Reset type </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_cellular_qctlcatm1.open" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_cellular_qctlcatm1.close" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningGet()" id="module.framework.sf_cellular_qctlcatm1.provisioningGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="provisioningGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningGet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningSet()" id="module.framework.sf_cellular_qctlcatm1.provisioningSet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="provisioningSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;provisioningSet(${instance}.p_ctrl, ${p_cellular_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_cellular_qctlcatm1.infoGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_cellular_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statisticsGet()" id="module.framework.sf_cellular_qctlcatm1.statisticsGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="statisticsGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;statisticsGet(${instance}.p_ctrl, ${p_cellular_device_stats});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call transmit()" id="module.framework.sf_cellular_qctlcatm1.transmit" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="transmit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;transmit(${instance}.p_ctrl, ${p_buf}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_cellular_qctlcatm1.versionGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkConnect()" id="module.framework.sf_cellular_qctlcatm1.networkConnect" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="networkConnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkConnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkDisconnect()" id="module.framework.sf_cellular_qctlcatm1.networkDisconnect" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="networkDisconnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkDisconnect(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call networkStatusGet()" id="module.framework.sf_cellular_qctlcatm1.networkStatusGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="networkStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;networkStatusGet(${instance}.p_ctrl, ${p_network_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simPinSet()" id="module.framework.sf_cellular_qctlcatm1.simPinSet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="simPinSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simPinSet(${instance}.p_ctrl, ${p_old_pin}, ${p_new_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simLock()" id="module.framework.sf_cellular_qctlcatm1.simLock" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="simLock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simLock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simUnlock()" id="module.framework.sf_cellular_qctlcatm1.simUnlock" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="simUnlock" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simUnlock(${instance}.p_ctrl, ${p_pin});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call simIDGet()" id="module.framework.sf_cellular_qctlcatm1.simIDGet" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="simIDGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;simIDGet(${instance}.p_ctrl, ${p_sim_id});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call commandSend()" id="module.framework.sf_cellular_qctlcatm1.commandSend" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="commandSend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;commandSend(${instance}.p_ctrl, ${p_input_at_command}, ${p_output}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaCheck()" id="module.framework.sf_cellular_qctlcatm1.fotaCheck" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="fotaCheck" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaCheck(${instance}.p_ctrl, ${p_fotacheck});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStart()" id="module.framework.sf_cellular_qctlcatm1.fotaStart" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="fotaStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStart(${instance}.p_ctrl, ${p_fotastart});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call fotaStop()" id="module.framework.sf_cellular_qctlcatm1.fotaStop" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="fotaStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;fotaStop(${instance}.p_ctrl, ${p_fotastop});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call reset()" id="module.framework.sf_cellular_qctlcatm1.reset" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1"><function id="reset" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_cellular.name)}.p_api-&gt;reset(${instance}.p_ctrl, ${reset_type});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Provisioning callback function definition" id="module.framework.sf_cellular_qctlcatm1.callback_def.0" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1" /><content>/* Provisioning callback function */
ssp_err_t ${callback_function:synergyProperty(module.framework.sf_cellular_qctlcatm1.p_prov_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Data Received callback function definition" id="module.framework.sf_cellular_qctlcatm1.callback_def.1" version="1"><moduleRef id="module.framework.sf_cellular_qctlcatm1" /><content>/* Data Received callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_cat3.p_recv_callback)}(sf_cellular_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_nsal_nx" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description></api><template category="function_call" display="Invalid Packet Handler callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.0" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Invalid Packet Handler callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_invalid_pkt_callback)}(NX_PACKET *p_packet_ptr)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Link Down callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.1" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Link Down callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_link_down_callback)}(NX_PPP *p_ppp_ptr)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Link Up callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.2" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Link Up callback function */
void ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_link_up_callback)}(NX_PPP *p_ppp_ptr)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="PAP Login callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.3" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* PAP Login callback function */
UINT ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_pap_generate_login_callback)}(CHAR *p_name, CHAR *p_password)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="PAP Verify Login callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.4" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* PAP Verify Login callback function */
UINT ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_pap_verify_login_callback)}(CHAR *p_name, CHAR *p_password)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Get Challenge Values callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.5" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Get Challenge Values callback function */
UINT ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_get_challenge_values_callback)}(CHAR *p_rand_value, CHAR *p_id, CHAR *p_name)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Get Responder Values callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.6" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Get Responder Values callback function */
UINT ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_get_responder_values_callback)}(CHAR *p_system, CHAR *p_name, CHAR *p_secret)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Get Verification callback function definition" id="module.framework.sf_cellular_nsal_nx.callback_def.7" version="1"><moduleRef id="module.framework.sf_cellular_nsal_nx" /><content>/* Get Verification callback function */
UINT ${callback_function:synergyProperty(module.framework.sf_cellular_nsal_nx.p_get_verification_callback)}(CHAR *p_system, CHAR *p_name, CHAR *p_secret)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_cellular_common" /><description>
<![CDATA[<form><p><span color="header" font="header">Cellular Framework Introduction</span></p><p>The Cellular Framework module provides a high-level application layer interface for cellular modem integration in SSP. The Cellular Framework provides a common interface for the applications to interface with the cellular modems from various vendors.</p><p>The Cellular Framework provides a set of APIs to provision, configure, and communicate with the cellular network for data communication. The Cellular Framework uses the UART Comms Framework to communicate with cellular modems over a serial interface by using AT commands. The Cellular framework creates the serial data pipe over a serial interface for the data communication, leveraging the PPP WAN protocol provided by NetX™. Data communication using TCP/IP can be established over this Wide Area Network (WAN) link using NetX Application protocols, sockets or IoT protocols such as MQTT.</p><p>The Cellular Framework also provides the framework-level socket APIs to communicate with the TCP/IP stack present on-chip (inside cellular hardware module) in certain cellular hardware modules and with the TCP/IP link for the network using socket APIs.</p><p><b>Cellular Framework Module Features</b></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p><p><span color="header" font="header">Cellular Framework Module Features</span></p><li bindent="0" vspace="false">Supports connectivity using:</li><li bindent="20" vspace="false">BSD Socket interface for On-Chip stack present on the Cellular Module</li><li bindent="20" vspace="false">NetX Stack on Synergy MCU (Host) using NSAL interface</li><li bindent="0" vspace="false">Supports a common a set of APIs to interface to the networking stack and a generic interface for the different Cellular hardware modules.</li><li bindent="0" vspace="false">Using generic APIs and abstraction, applications developed for the cellular hardware module can be easily migrated to work with another cellular hardware module.</li><li bindent="0" vspace="false">Supported Cellular modems:</li><li bindent="20" vspace="false">RYZ014A CAT M1 (PMOD Expansion Board for RYZ014A) (For information on this kit, see: <a href="https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a">https://www.renesas.com/us/en/products/interface-connectivity/wireless-communications/cellular-iot-modules/rtkyz014a0b00000be-pmod-expansion-board-ryz014a</a>)</li><li bindent="20" vspace="false">Quectel BG96 (CAT M1, NB-IoT and GPRS) Rev F</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TSVG, REVISION 17.01.571) Verizon-US</li><li bindent="0" vspace="false">NimbeLink CAT3 (NL-SW-LTE-TEUG, REVISION 17.01.571) India and Europe</li><li bindent="0" vspace="false">NimbeLink CAT1 (NL-SW-LTE-GELS3-B and NL-SW-LTE-GELS3-C, REVISION 4.3.3.0c ) Verizon-US</li><p><b>Note</b></p><p>Any of the four BSD Socket On-Chip stacks can implement any of the four Cellular Framework modules below it. Similarly, the NetX Port on <span font="code">sf_cellular_nsal_nx</span> can implement any of the four Cellular Framework modules below it.</p></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi Framework Introduction</span></p><p>The Wi-Fi framework provides a high-level API for configuring and provisioning Wi-Fi modules as well as performing data transfers with or without on-chip networking capability. Currently, only the Qualcomm GT202 module is supported. The Wi-Fi framework communicates through the SPI with the underlying GT202 module.</p><p><b>Wi-Fi Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p><p><span color="header" font="header">Wi-Fi Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_wifi_onchip_stack_ctrl_t *p_ctrl, sf_wifi_onchip_stack_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers. </p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_wifi_onchip_stack_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ipAddressCfg) (sf_wifi_onchip_stack_ctrl_t *const p_ctrl, sf_wifi_onchip_stack_ip_cfg_t *const p_cfg)" id="ipAddressCfg"><description>
<![CDATA[<form><p>Configures IP address of the interface. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to IP configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dhcpServerStart) (sf_wifi_onchip_stack_ctrl_t *const p_ctrl, sf_wifi_ip_addr_t const *const p_start_ip, sf_wifi_ip_addr_t const *const p_end_ip)" id="dhcpServerStart"><description>
<![CDATA[<form><p>Starts DHCP server on the interface. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_start_ip</span> :   Pointer to start IP address </li><li bindent="0" vspace="false"><span font="code">p_end_ip</span> :   Pointer to end IP address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dhcpServerStop) (sf_wifi_onchip_stack_ctrl_t *const p_ctrl)" id="dhcpServerStop"><description>
<![CDATA[<form><p>Stop DHCP server on the interface. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.open" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.close" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ipAddressCfg()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.ipAddressCfg" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="ipAddressCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;ipAddressCfg(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dhcpServerStart()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.dhcpServerStart" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="dhcpServerStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;dhcpServerStart(${instance}.p_ctrl, ${p_start_ip}, ${p_end_ip});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dhcpServerStop()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.dhcpServerStop" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="dhcpServerStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;dhcpServerStop(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_wifi_onchip_stack_gt202_v2.versionGet" version="1"><moduleRef id="module.framework.sf_wifi_onchip_stack_gt202_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_onchip_stack_v2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_gt202_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi Framework Introduction</span></p><p>The Wi-Fi framework provides a high-level API for configuring and provisioning Wi-Fi modules as well as performing data transfers with or without on-chip networking capability. Currently, only the Qualcomm GT202 module is supported. The Wi-Fi framework communicates through the SPI with the underlying GT202 module.</p><p><b>Wi-Fi Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p><p><span color="header" font="header">Wi-Fi Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_wifi_ctrl_t *p_ctrl, sf_wifi_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the network interface for data transfers. </p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to WiFi configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_wifi_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>De-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*multicastListAdd) (sf_wifi_ctrl_t *const p_ctrl, uint8_t const *const p_mac_addr)" id="multicastListAdd"><description>
<![CDATA[<form><p>Add the given MAC address to the multicast filter list. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac_addr</span> :   Pointer to the Mac address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*multicastListDelete) (sf_wifi_ctrl_t *const p_ctrl, uint8_t const *const p_mac_addr)" id="multicastListDelete"><description>
<![CDATA[<form><p>Delete the given MAC address from the multicast filter list.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac_addr</span> :   Pointer to the Mac address. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*statisticsGet) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_stats_t *const p_wifi_device_stats)" id="statisticsGet"><description>
<![CDATA[<form><p>Get the interface statistics. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_device_stats</span> :   Pointer to the WiFi module data statistics. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*transmit) (sf_wifi_ctrl_t *const p_ctrl, uint8_t *const p_buf, uint32_t length)" id="transmit"><description>
<![CDATA[<form><p>Transmit data packet. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_buf</span> :   Pointer to transmit buffer </li><li bindent="0" vspace="false"><span font="code">length</span> :   Transmit buffer length </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningSet) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_provisioning_t const *const p_wifi_provisioning)" id="provisioningSet"><description>
<![CDATA[<form><p>Set WiFi module provisioning which will configure the module in AP or Client mode. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_provisioning</span> :   Pointer to WiFi provisioning structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningGet) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_provisioning_t *const p_wifi_provisioning)" id="provisioningGet"><description>
<![CDATA[<form><p>Get the provisioning information of WiFi module. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_provisioning</span> :   Pointer to WiFi provisioning structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*infoGet) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_info_t *const p_wifi_info)" id="infoGet"><description>
<![CDATA[<form><p>Get WiFi module information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_info</span> :   Pointer to WiFi module information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scan) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_scan_t *const p_scan, uint8_t *const p_cnt)" id="scan"><description>
<![CDATA[<form><p>Scan for WiFi SSIDs. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_scan</span> :   Pointer to structure which will hold scan result. It is the responsibility of the caller to ensure that adequate space is available to hold scan results. </li><li bindent="0" vspace="false"><span font="code">p_cnt</span> :   Pointer to variable, specifying maximum number of SSID's to scan and will be updated to number of actual SSIDs scanned by device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ACLAdd) (sf_wifi_ctrl_t *const p_ctrl, uint8_t const *const p_mac)" id="ACLAdd"><description>
<![CDATA[<form><p>Adds a MAC address to the Access Control List. Valid in AP mode only. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac</span> :   Pointer to MAC address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ACLDelete) (sf_wifi_ctrl_t *const p_ctrl, uint8_t const *const p_mac)" id="ACLDelete"><description>
<![CDATA[<form><p>Deletes a MAC address from Access Control List. Valid in AP mode only. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac</span> :   Pointer to MAC address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*macAddressGet) (sf_wifi_ctrl_t *const p_ctrl, uint8_t *const p_mac)" id="macAddressGet"><description>
<![CDATA[<form><p>Get WiFi module MAC address. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac</span> :   Pointer to MAC address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*macAddressSet) (sf_wifi_ctrl_t *const p_ctrl, uint8_t const *const p_mac)" id="macAddressSet"><description>
<![CDATA[<form><p>Set WiFi module MAC address. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_mac</span> :   Pointer to MAC address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*wpsStart) (sf_wifi_ctrl_t *const p_ctrl, sf_wifi_wps_t const *const p_wps)" id="wpsStart"><description>
<![CDATA[<form><p>Start WiFi WPS. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wps</span> :   Pointer to WiFi WPS configuration </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_wifi_gt202_v2.open" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_wifi_gt202_v2.close" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call multicastListAdd()" id="module.framework.sf_wifi_gt202_v2.multicastListAdd" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="multicastListAdd" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;multicastListAdd(${instance}.p_ctrl, ${p_mac_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call multicastListDelete()" id="module.framework.sf_wifi_gt202_v2.multicastListDelete" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="multicastListDelete" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;multicastListDelete(${instance}.p_ctrl, ${p_mac_addr});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call statisticsGet()" id="module.framework.sf_wifi_gt202_v2.statisticsGet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="statisticsGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;statisticsGet(${instance}.p_ctrl, ${p_wifi_device_stats});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call transmit()" id="module.framework.sf_wifi_gt202_v2.transmit" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="transmit" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;transmit(${instance}.p_ctrl, ${p_buf}, ${length});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningSet()" id="module.framework.sf_wifi_gt202_v2.provisioningSet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="provisioningSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;provisioningSet(${instance}.p_ctrl, ${p_wifi_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningGet()" id="module.framework.sf_wifi_gt202_v2.provisioningGet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="provisioningGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;provisioningGet(${instance}.p_ctrl, ${p_wifi_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call infoGet()" id="module.framework.sf_wifi_gt202_v2.infoGet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="infoGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;infoGet(${instance}.p_ctrl, ${p_wifi_info});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scan()" id="module.framework.sf_wifi_gt202_v2.scan" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="scan" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;scan(${instance}.p_ctrl, ${p_scan}, ${p_cnt});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ACLAdd()" id="module.framework.sf_wifi_gt202_v2.ACLAdd" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="ACLAdd" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;ACLAdd(${instance}.p_ctrl, ${p_mac});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ACLDelete()" id="module.framework.sf_wifi_gt202_v2.ACLDelete" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="ACLDelete" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;ACLDelete(${instance}.p_ctrl, ${p_mac});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call macAddressGet()" id="module.framework.sf_wifi_gt202_v2.macAddressGet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="macAddressGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;macAddressGet(${instance}.p_ctrl, ${p_mac});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call macAddressSet()" id="module.framework.sf_wifi_gt202_v2.macAddressSet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="macAddressSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;macAddressSet(${instance}.p_ctrl, ${p_mac});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call wpsStart()" id="module.framework.sf_wifi_gt202_v2.wpsStart" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="wpsStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;wpsStart(${instance}.p_ctrl, ${p_wps});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_wifi_gt202_v2.versionGet" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_v2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_wifi_gt202_v2.callback_def.0" version="1"><moduleRef id="module.framework.sf_wifi_gt202_v2" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_wifi_v2.p_callback)}(sf_wifi_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_nsal_nx_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi Framework Introduction</span></p><p>The Wi-Fi framework provides a high-level API for configuring and provisioning Wi-Fi modules as well as performing data transfers with or without on-chip networking capability. Currently, only the Qualcomm GT202 module is supported. The Wi-Fi framework communicates through the SPI with the underlying GT202 module.</p><p><b>Wi-Fi Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p><p><span color="header" font="header">Wi-Fi Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p></form>]]>
</description></api><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_socket_wifi_gt202_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi Framework Introduction</span></p><p>The Wi-Fi framework provides a high-level API for configuring and provisioning Wi-Fi modules as well as performing data transfers with or without on-chip networking capability. Currently, only the Qualcomm GT202 module is supported. The Wi-Fi framework communicates through the SPI with the underlying GT202 module.</p><p><b>Wi-Fi Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p><p><span color="header" font="header">Wi-Fi Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a Wi-Fi module</li><li bindent="0" vspace="false">Provides four different implementations for:</li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_gt202 framework.</li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A BSD socket stack using the sf_wifi_onchip_stack framework.</li><li bindent="20" vspace="false">A NetX and NetX Duo port using the sf_wifi_nsal_nx framework.</li><li bindent="0" vspace="false">Using NetX and NASL:</li><li bindent="20" vspace="false">Allows the same application code to be used across different Wi-Fi modules.</li><li bindent="20" vspace="false">Allows for easy migration of the Ethernet-based application to a Wi-Fi based application.</li><li bindent="20" vspace="false">Allows for debugging and fine-tuning the application and TCP/IP stack as required by the application.</li><li bindent="20" vspace="false">The current NSAL implementation only provides NetX NSAL. Adding support for a new network stack requires implementing the appropriate NSAL.</li><li bindent="0" vspace="false">Using the On-chip networking stack:</li><li bindent="20" vspace="false">Is beneficial when using MCUs with a small memory footprint.</li><li bindent="20" vspace="false">Provides a BSD sockets interface to create socket-based applications with the On-chip TCP/UDP.</li><li bindent="0" vspace="false">Provides an option to integrate 3rd-party application protocols on top of TCP/IP such as MQTT and COAP without using the NetX stack.</li><li bindent="0" vspace="false">Provides support for Wi-Fi Protected Setup (<b>WPS</b>) router configuration using Push-Button and PIN methods.</li><p><b>Note</b></p><p>The On-Chip Stack on GT202 Wi-Fi Framework can be used as a lower-level implementation of the BSD Socket Framework or on its own.  The GT202 Wi-Fi Device Driver and its lower-level modules is included below all other Wi-Fi Framework implementations.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_socket_ctrl_t *p_ctrl, sf_socket_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_socket_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_socket_wifi_gt202_v2.open" version="1"><moduleRef id="module.framework.sf_socket_wifi_gt202_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_socket_v2.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_socket_wifi_gt202_v2.close" version="1"><moduleRef id="module.framework.sf_socket_wifi_gt202_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_socket_v2.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_socket_wifi_gt202_v2.versionGet" version="1"><moduleRef id="module.framework.sf_socket_wifi_gt202_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_socket_v2.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_el_nx" /><description>
<![CDATA[<form><p><span color="header" font="header">NetX Port Ether Module Introduction</span></p><p>The Azure RTOS NetX Port Ether module (sf_el_nx) for NetX and NetX Duo is integrated into the SSP. Its function is to interface the NetX and NetX Duo software with the Synergy hardware. This module includes the MAC driver, the PHY driver, additional glue logic and utility functions.</p><p><b>Note</b></p><p>Unless otherwise stated, there is no difference in how this module works between NetX or NetX Duo projects.</p><p><b>NetX Port Ether Module Features</b></p><li bindent="0" vspace="false">High-level interface for NetX and NetX Duo for the Synergy Platform</li><li bindent="0" vspace="false">Channel Selection</li><li bindent="0" vspace="false">PHY Reset support</li><li bindent="0" vspace="false">Static MAC Address configuration</li><li bindent="0" vspace="false">Dynamic MAC Address configuration</li><li bindent="0" vspace="false">Callbacks are provided for unknown packet reception</li><li bindent="0" vspace="false">Selectable Ethernet Interrupt Priority</li><li bindent="0" vspace="false">Link status monitoring support</li><li bindent="0" vspace="false">Configurable Number of Receive/Transmit Buffer Descriptors</li><li bindent="0" vspace="false">Supports the use of an external PHY chip</li><p><span color="header" font="header">NetX Port Ether Module Features</span></p><li bindent="0" vspace="false">High-level interface for NetX and NetX Duo for the Synergy Platform</li><li bindent="0" vspace="false">Channel Selection</li><li bindent="0" vspace="false">PHY Reset support</li><li bindent="0" vspace="false">Static MAC Address configuration</li><li bindent="0" vspace="false">Dynamic MAC Address configuration</li><li bindent="0" vspace="false">Callbacks are provided for unknown packet reception</li><li bindent="0" vspace="false">Selectable Ethernet Interrupt Priority</li><li bindent="0" vspace="false">Link status monitoring support</li><li bindent="0" vspace="false">Configurable Number of Receive/Transmit Buffer Descriptors</li><li bindent="0" vspace="false">Supports the use of an external PHY chip</li><p><span color="header" font="header">NetX Port Ether Module APIs Overview</span></p><p>The NetX Port Ether module has a narrow API, used internally by NetX and by the module itself. It includes the Ethernet driver entry point (nx_ether_driver_eth0, nx_ether_driver_eth1), the Ethernet interrupt handler and other functions used internally by the module but externally visible.</p></form>]]>
</description></api><template category="function_call" display="MAC address change callback function definition" id="module.framework.sf_el_nx.callback_def.0" version="1"><moduleRef id="module.framework.sf_el_nx" /><content>/* MAC address change callback function */
void ${callback_function:synergyProperty(module.framework.sf_el_nx.mac_update_callback)}(nx_mac_address_t *p_mac_config)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Unknown packet receive callback function definition" id="module.framework.sf_el_nx.callback_def.1" version="1"><moduleRef id="module.framework.sf_el_nx" /><content>/* Unknown packet receive callback function */
void ${callback_function:synergyProperty(module.framework.sf_el_nx.receive_callback)}(NX_PACKET *packet_ptr, USHORT packet_type)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_console" /><description>
<![CDATA[<form><p><span color="header" font="header">Console Framework Introduction</span></p><p>The Console Framework provides a complete API implementation for a menu-driven console command line interface (CLI) using the ThreadX RTOS. The Console Framework module uses a lower-level communications interface, which connects to a hardware option for either UART, USB or Ethernet Telnet connectivity. The Console Framework module has a user-defined menu of commands and various APIs to present a prompt, identify and issue a callback for menu commands and read, write and parse input strings.</p><p><b>Console Framework Module Features</b></p><p>The console framework supports the following features:</p><li bindent="0" vspace="false">Creation of a menu-based command-line interface</li><li bindent="0" vspace="false">Submenus and navigation through multiple menus in a single call</li><li bindent="0" vspace="false">Menu navigation to go up to the parent menu or back to the root</li><li bindent="0" vspace="false">A help menu for each menu</li><li bindent="0" vspace="false">Writing NULL terminated strings and reading until return character is received</li><li bindent="0" vspace="false">An API to help parse arguments to the command line</li><li bindent="0" vspace="false">Case-insensitive inputs</li><p>The Console Framework module organization, as depicted in the thread stack window in the SSP configurator, is shown in the following figure. Each implementation choice, Ethernet, UART, and USB has its own lower-level modules that are added automatically based on the developer's implementation choice. In most cases, all the needed configuration information is automatically added to the modules leaving the developer with just a few important configuration settings that need to be selected.</p><p><span color="header" font="header">Console Framework Module Features</span></p><p>The console framework supports the following features:</p><li bindent="0" vspace="false">Creation of a menu-based command-line interface</li><li bindent="0" vspace="false">Submenus and navigation through multiple menus in a single call</li><li bindent="0" vspace="false">Menu navigation to go up to the parent menu or back to the root</li><li bindent="0" vspace="false">A help menu for each menu</li><li bindent="0" vspace="false">Writing NULL terminated strings and reading until return character is received</li><li bindent="0" vspace="false">An API to help parse arguments to the command line</li><li bindent="0" vspace="false">Case-insensitive inputs</li><p>The Console Framework module organization, as depicted in the thread stack window in the SSP configurator, is shown in the following figure. Each implementation choice, Ethernet, UART, and USB has its own lower-level modules that are added automatically based on the developer's implementation choice. In most cases, all the needed configuration information is automatically added to the modules leaving the developer with just a few important configuration settings that need to be selected.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_console_ctrl_t *const p_ctrl, sf_console_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>This function configures the console. This function must be called before any other console functions. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a device structure allocated by user. The device control structure is initialized in this function. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_console_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>The close API handles cleans up internal driver data. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for UART driver. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*prompt) (sf_console_ctrl_t *const p_ctrl, sf_console_menu_t const *const p_menu, UINT const timeout)" id="prompt"><description>
<![CDATA[<form><p>Prints prompt string from menu, waits for input, parses input based on menu, and calls callback function if a command is identified. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Prompt()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for UART driver. </li><li bindent="0" vspace="false"><span font="code">p_menu</span> :   Set to NULL to stay on current menu maintained by the console framework. To change menus, pass a pointer to the new menu. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*parse) (sf_console_ctrl_t *const p_ctrl, sf_console_menu_t const *const p_cmd_list, uint8_t const *const p_input, uint32_t const bytes)" id="parse"><description>
<![CDATA[<form><p>Looks for input string in menu, and calls callback function if found. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Parse()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for UART driver. </li><li bindent="0" vspace="false"><span font="code">p_cmd_list</span> :   Pointer to a menu of valid input commands for this prompt </li><li bindent="0" vspace="false"><span font="code">p_input</span> :   Pointer to a null terminated string to search for in the command list </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Length of the input string. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*read) (sf_console_ctrl_t *const p_ctrl, uint8_t *const p_dest, uint32_t const bytes, uint32_t const timeout)" id="read"><description>
<![CDATA[<form><p>Reads data into the destination byte by byte and echos input to the console. Backspace, delete, and left/right arrow keys supported. Read completes when a line ending CR, CR+LF, or CR+NULL is received, or when the input exceeds the number of bytes input. If the buffer overflows SF_CONSOLE_MAX_INPUT_LENGTH, read will return an error code. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Read()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for UART driver. </li><li bindent="0" vspace="false"><span font="code">p_dest</span> :   Destination address to read data out </li><li bindent="0" vspace="false"><span font="code">bytes</span> :   Read data length </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*write) (sf_console_ctrl_t *const p_ctrl, uint8_t const *const p_src, uint32_t const timeout)" id="write"><description>
<![CDATA[<form><p>The write API gets mutex object and handles UART data transmission at UART HAL layer. gets event flag to synchronize to completion of data transfer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_Write()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to device control block initialized in Open call for UART driver. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to a NULL terminated string. Length must be less than SF_CONSOLE_MAX_WRITE_LENGTH. </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   ThreadX timeout. Options include TX_NO_WAIT (0x00000000), TX_WAIT_FOREVER (0xFFFFFFFF), and timeout value (0x00000001 through 0xFFFFFFFE) in ThreadX tick counts. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*argumentFind) (uint8_t const *const p_arg, uint8_t const *const p_str, int32_t *const p_index, int32_t *const p_data)" id="argumentFind"><description>
<![CDATA[<form><p>Finds a command line argument in an input string and returns the index of the character immediately following the argument and any string numbers converted to integers. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_ArgumentFind()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_arg</span> :   Pointer to argument to find. </li><li bindent="0" vspace="false"><span font="code">p_src</span> :   Pointer to source string to find the argument in. </li><li bindent="0" vspace="false"><span font="code">p_index</span> :   Pointer to location to store index. Set to -1 if argument is not found in input string. Pass NULL if index is not requested. </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Pointer to location to store data following the argument. Set to -1 if argument is not found in input string. Pass NULL if data is not requested. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Stores version information in provided pointer. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_CONSOLE_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used stored here. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_console.open" version="1"><moduleRef id="module.framework.sf_console"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_console.close" version="1"><moduleRef id="module.framework.sf_console"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call prompt()" id="module.framework.sf_console.prompt" version="1"><moduleRef id="module.framework.sf_console"><function id="prompt" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;prompt(${instance}.p_ctrl, ${p_menu}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call parse()" id="module.framework.sf_console.parse" version="1"><moduleRef id="module.framework.sf_console"><function id="parse" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;parse(${instance}.p_ctrl, ${p_cmd_list}, ${p_input}, ${bytes});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call read()" id="module.framework.sf_console.read" version="1"><moduleRef id="module.framework.sf_console"><function id="read" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;read(${instance}.p_ctrl, ${p_dest}, ${bytes}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call write()" id="module.framework.sf_console.write" version="1"><moduleRef id="module.framework.sf_console"><function id="write" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;write(${instance}.p_ctrl, ${p_src}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call argumentFind()" id="module.framework.sf_console.argumentFind" version="1"><moduleRef id="module.framework.sf_console"><function id="argumentFind" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;argumentFind(${p_arg}, ${p_str}, ${p_index}, ${p_data});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_console.versionGet" version="1"><moduleRef id="module.framework.sf_console"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_console.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_console.callback_def.error" version="1"><moduleRef id="module.framework.sf_console" /><content>/* ${instance:synergyProperty(module.framework.sf_console.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_message" /><description>
<![CDATA[<form><p><span color="header" font="header">Messaging Framework Module Introduction</span></p><p>The Messaging Framework implements a lightweight and event-driven API for passing messages between threads. The Messaging Framework module allows applications to communicate messages between two or more threads. The framework uses the ThreadX message-queue primitive for message passing and provides more benefits than the ThreadX RTOS message-queue services alone. The Messaging Framework API is purely a software API and does not access any hardware peripherals. The Messaging Framework callback is used to allow an event-producer thread and a message-subscriber thread to handshake after the message passing is done.</p><p>The <b>Messaging</b> tab is used to either create custom event classes, events and subscribers for the Messaging Framework module or to customize preconfigured events such as the touch event used by the Touch Panel Framework module.</p><p><b>Messaging Framework Module Features</b></p><p>The Messaging Framework module supports the following functions:</p><li bindent="0" vspace="false">Inter-Thread communication - The framework allows application threads which control disparate devices or manage subsystems to communicate with each other.</li><li bindent="0" vspace="false">Publishing/Subscribe scheme - The framework design is based on the loosely-coupled messaging paradigm. The design allows multiple threads to listen to an event class. The message producer thread does not need to know who is subscribing to a message for the event class. Subscribers do not need to know who produces the message.</li><li bindent="0" vspace="false">Message management - The framework supports buffer control blocks to manage each message including flags to control the buffer and a callback function pointer for handshaking.</li><li bindent="0" vspace="false">Message buffering - The framework manages buffer allocation and release for messaging. An application can make use of the allocated buffer to write a message and discard the message if it is no longer needed.</li><li bindent="0" vspace="false">Synchronous communication - The framework supports asynchronous messaging by using the ThreadX message-queue but also provides an option to create a handshake between a message producer and a subscriber thread. The handshake is implemented by invoking a user-callback function of the producer thread from a subscriber thread.</li><li bindent="0" vspace="false">Message formatting - The framework provides a predefined common message header. It also provides some typical payload structure templates as examples.</li><li bindent="0" vspace="false">Message Priority - The framework can send a high-priority message so that a subscriber thread can retrieve the message prior to other messages which are located in the message queue.</li><p><span color="header" font="header">Messaging Framework Module Features</span></p><p>The Messaging Framework module supports the following functions:</p><li bindent="0" vspace="false">Inter-Thread communication - The framework allows application threads which control disparate devices or manage subsystems to communicate with each other.</li><li bindent="0" vspace="false">Publishing/Subscribe scheme - The framework design is based on the loosely-coupled messaging paradigm. The design allows multiple threads to listen to an event class. The message producer thread does not need to know who is subscribing to a message for the event class. Subscribers do not need to know who produces the message.</li><li bindent="0" vspace="false">Message management - The framework supports buffer control blocks to manage each message including flags to control the buffer and a callback function pointer for handshaking.</li><li bindent="0" vspace="false">Message buffering - The framework manages buffer allocation and release for messaging. An application can make use of the allocated buffer to write a message and discard the message if it is no longer needed.</li><li bindent="0" vspace="false">Synchronous communication - The framework supports asynchronous messaging by using the ThreadX message-queue but also provides an option to create a handshake between a message producer and a subscriber thread. The handshake is implemented by invoking a user-callback function of the producer thread from a subscriber thread.</li><li bindent="0" vspace="false">Message formatting - The framework provides a predefined common message header. It also provides some typical payload structure templates as examples.</li><li bindent="0" vspace="false">Message Priority - The framework can send a high-priority message so that a subscriber thread can retrieve the message prior to other messages which are located in the message queue.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_message_ctrl_t *const p_ctrl, sf_message_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initialize message framework. Initiate the messaging framework control block, configure the work memory corresponding to the configuration parameters. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_message_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Finalize message framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*bufferAcquire) (sf_message_ctrl_t const *const p_ctrl, sf_message_header_t **pp_buffer, sf_message_acquire_cfg_t const *const p_acquire_cfg, uint32_t const wait_option)" id="bufferAcquire"><description>
<![CDATA[<form><p>Acquire buffer for message passing from the block. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_BufferAcquire()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><li bindent="0" vspace="false"><span font="code">pp_buffer</span> :   Pointer to the pointer to the allocated buffer memory </li><li bindent="0" vspace="false"><span font="code">p_acquire_cfg</span> :   Pointer to the buffer acquisition configuration </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Wait option (TX_NO_WAIT, TX_WAIT_FOREVER or numerical values) </li><p /></form>]]>
</description></function><function display="ssp_err_t (*bufferRelease) (sf_message_ctrl_t *const p_ctrl, sf_message_header_t *const p_buffer, sf_message_release_option_t const option)" id="bufferRelease"><description>
<![CDATA[<form><p>Release buffer obtained from <span font="code">SF_MESSAGE_BufferAcquire()</span>. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_BufferRelease()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the buffer allocated by <span font="code">SF_MESSAGE_BufferAcquire()</span> </li><li bindent="0" vspace="false"><span font="code">option</span> :   Buffer release option (SF_MESSAGE_RELEASE_OPTION_NONE, SF_MESSAGE_RELEASE_OPTION_ACK, SF_MESSAGE_RELEASE_OPTION_NAK, SF_MESSAGE_RELEASE_OPTION_FORCED_RELEASE) </li><p /></form>]]>
</description></function><function display="ssp_err_t (*post) (sf_message_ctrl_t *const p_ctrl, sf_message_header_t const *const p_buffer, sf_message_post_cfg_t const *const p_post_cfg, sf_message_post_err_t *const p_post_err, uint32_t const wait_option)" id="post"><description>
<![CDATA[<form><p>Post message to the subscribers. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_Post()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><li bindent="0" vspace="false"><span font="code">p_buffer</span> :   Pointer to the buffer allocated by <span font="code">SF_MESSAGE_BufferAcquire()</span> </li><li bindent="0" vspace="false"><span font="code">p_post_cfg</span> :   Pointer to the message post configuration </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Wait option (TX_NO_WAIT, TX_WAIT_FOREVER or numerical values) </li><p /></form>]]>
</description></function><function display="ssp_err_t (*pend) (sf_message_ctrl_t const *const p_ctrl, TX_QUEUE const *const p_queue, sf_message_header_t **pp_buffer, uint32_t const wait_option)" id="pend"><description>
<![CDATA[<form><p>Pend message. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_Pend()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the messaging control block </li><li bindent="0" vspace="false"><span font="code">p_queue</span> :   Pointer to a threadX message queue object </li><li bindent="0" vspace="false"><span font="code">pp_buffer</span> :   Pointer to the pointer to the buffer where message is stored. </li><li bindent="0" vspace="false"><span font="code">wait_option</span> :   Wait option (TX_NO_WAIT, TX_WAIT_FOREVER or numerical values) </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get the version of the messaging framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_MESSAGE_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to the memory where to store the version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_message.open" version="1"><moduleRef id="module.framework.sf_message"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_message.close" version="1"><moduleRef id="module.framework.sf_message"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call bufferAcquire()" id="module.framework.sf_message.bufferAcquire" version="1"><moduleRef id="module.framework.sf_message"><function id="bufferAcquire" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;bufferAcquire(${instance}.p_ctrl, ${pp_buffer}, ${p_acquire_cfg}, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call bufferRelease()" id="module.framework.sf_message.bufferRelease" version="1"><moduleRef id="module.framework.sf_message"><function id="bufferRelease" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;bufferRelease(${instance}.p_ctrl, ${p_buffer}, ${option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call post()" id="module.framework.sf_message.post" version="1"><moduleRef id="module.framework.sf_message"><function id="post" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;post(${instance}.p_ctrl, ${p_buffer}, ${p_post_cfg}, ${p_post_err}, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call pend()" id="module.framework.sf_message.pend" version="1"><moduleRef id="module.framework.sf_message"><function id="pend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;pend(${instance}.p_ctrl, ${p_queue}, ${pp_buffer}, ${wait_option});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_message.versionGet" version="1"><moduleRef id="module.framework.sf_message"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_message.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.sf_message.callback_def.error" version="1"><moduleRef id="module.framework.sf_message" /><content>/* ${instance:synergyProperty(module.framework.sf_message.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Power Profiles V2 Framework Introduction</span></p><p>The Power Profiles V2 Framework provides a high-level API used to control the system clocks, the I/O ports, the operating modes (indirectly through the clock control) and the low power modes of the MCU. The Power Profiles V2 Framework, when used with the LPM V2 Driver, CGC Driver and I/O Port Driver, gives the user advanced control over the power consumption of the MCU.</p><p><b>Power Profiles V2 Framework Module Features</b></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li><p><span color="header" font="header">Power Profiles V2 Framework Module Features</span></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*runApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_run_cfg_t const *const p_cfg)" id="runApply"><description>
<![CDATA[<form><p>Applies a Run profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_RunApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_low_power_cfg_t const *const p_cfg)" id="lowPowerApply"><description>
<![CDATA[<form><p>Applies a Low Power profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_LowPowerApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_power_profiles_v2_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2.open" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_common.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call runApply()" id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2.runApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2"><function id="runApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_common.name)}.p_api-&gt;runApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerApply()" id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2.lowPowerApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2"><function id="lowPowerApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_common.name)}.p_api-&gt;lowPowerApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2.close" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_common.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2.versionGet" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_common_on_sf_power_profiles_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_common.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Power Profiles V2 Framework Introduction</span></p><p>The Power Profiles V2 Framework provides a high-level API used to control the system clocks, the I/O ports, the operating modes (indirectly through the clock control) and the low power modes of the MCU. The Power Profiles V2 Framework, when used with the LPM V2 Driver, CGC Driver and I/O Port Driver, gives the user advanced control over the power consumption of the MCU.</p><p><b>Power Profiles V2 Framework Module Features</b></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li><p><span color="header" font="header">Power Profiles V2 Framework Module Features</span></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*runApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_run_cfg_t const *const p_cfg)" id="runApply"><description>
<![CDATA[<form><p>Applies a Run profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_RunApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_low_power_cfg_t const *const p_cfg)" id="lowPowerApply"><description>
<![CDATA[<form><p>Applies a Low Power profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_LowPowerApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_power_profiles_v2_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.open" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_low_power.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call runApply()" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.runApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2"><function id="runApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_low_power.name)}.p_api-&gt;runApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerApply()" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.lowPowerApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2"><function id="lowPowerApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_low_power.name)}.p_api-&gt;lowPowerApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.close" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_low_power.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.versionGet" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_low_power.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Callback function definition" id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2.callback_def.0" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_low_power_on_sf_power_profiles_v2" /><content>/* Callback function */
void ${callback_function:synergyProperty(module.framework.sf_power_profiles_v2_low_power.p_callback)}(sf_power_profiles_v2_callback_args_t *p_args)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2" /><description>
<![CDATA[<form><p><span color="header" font="header">Power Profiles V2 Framework Introduction</span></p><p>The Power Profiles V2 Framework provides a high-level API used to control the system clocks, the I/O ports, the operating modes (indirectly through the clock control) and the low power modes of the MCU. The Power Profiles V2 Framework, when used with the LPM V2 Driver, CGC Driver and I/O Port Driver, gives the user advanced control over the power consumption of the MCU.</p><p><b>Power Profiles V2 Framework Module Features</b></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li><p><span color="header" font="header">Power Profiles V2 Framework Module Features</span></p><li bindent="0" vspace="false">Uses Low Power Modes V2</li><li bindent="0" vspace="false">Sets CGC clock configuration and I/O Port pin configuration when entering and exiting the configured low power mode</li><li bindent="0" vspace="false">Supports both threaded and non-threaded operations</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Open()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*runApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_run_cfg_t const *const p_cfg)" id="runApply"><description>
<![CDATA[<form><p>Applies a Run profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_RunApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*lowPowerApply) (sf_power_profiles_v2_ctrl_t *const p_ctrl, sf_power_profiles_v2_low_power_cfg_t const *const p_cfg)" id="lowPowerApply"><description>
<![CDATA[<form><p>Applies a Low Power profile. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_LowPowerApply()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. Elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_power_profiles_v2_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Closes the framework. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_Close()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to control block set in <span font="code">SF_POWER_PROFILES_V2_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_POWER_PROFILES_V2_VersionGet()</span></li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Code and API version used. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2.open" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_run.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call runApply()" id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2.runApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2"><function id="runApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_run.name)}.p_api-&gt;runApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call lowPowerApply()" id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2.lowPowerApply" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2"><function id="lowPowerApply" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_run.name)}.p_api-&gt;lowPowerApply(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2.close" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_run.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2.versionGet" version="1"><moduleRef id="module.framework.sf_power_profiles_v2_run_on_sf_power_profiles_v2"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_power_profiles_v2_run.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.thread_monitor" /><description>
<![CDATA[<form><p><span color="header" font="header">Thread Monitor Framework Module Introduction</span></p><p>The Thread Monitor Framework provides a high-level API for system monitoring applications using the watchdog timer (WDT) or independent watchdog timer (IWDT) to monitor program execution. The Thread Monitor Framework uses the WDT or IWDT peripherals on the Synergy MCU device.</p><p><b>Thread Monitor Framework Module Features</b></p><li bindent="0" vspace="false">The Thread Monitor Framework interface monitors RTOS threads using a watchdog timer. The Thread Monitor forces a watchdog reset of the microcontroller when any of the monitored threads do not behave as expected.</li><li bindent="0" vspace="false">The Thread Monitor is designed to support any Synergy device with either a WDT or IWDT peripheral and a HAL module with no changes to the API.</li><li bindent="0" vspace="false">In profiling mode, the minimum and maximum counter values for registered threads can be determined. When in profiling mode, the watchdog timer is always refreshed and does not reset the device.</li><li bindent="0" vspace="false">Both the WDT and IWDT HAL modules are supported by this framework module.</li><p><span color="header" font="header">Thread Monitor Framework Module Features</span></p><li bindent="0" vspace="false">The Thread Monitor Framework interface monitors RTOS threads using a watchdog timer. The Thread Monitor forces a watchdog reset of the microcontroller when any of the monitored threads do not behave as expected.</li><li bindent="0" vspace="false">The Thread Monitor is designed to support any Synergy device with either a WDT or IWDT peripheral and a HAL module with no changes to the API.</li><li bindent="0" vspace="false">In profiling mode, the minimum and maximum counter values for registered threads can be determined. When in profiling mode, the watchdog timer is always refreshed and does not reset the device.</li><li bindent="0" vspace="false">Both the WDT and IWDT HAL modules are supported by this framework module.</li></form>]]>
</description><function display="ssp_err_t (*open) (sf_thread_monitor_ctrl_t *const p_ctrl, sf_thread_monitor_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Configures the WDT or IWDT module. From the configuration data the timeout period of the WDT/IWDT is determined and a thread created monitoring registered threads. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_Open()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to a structure allocated by user. Elements initialized here. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. All elements of the structure must be set by user. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_thread_monitor_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Suspends the thread monitoring thread. Watchdog peripheral no longer refreshed. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_Close()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control structure set in <span font="code">SF_THREAD_MONITOR_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*threadRegister) (sf_thread_monitor_ctrl_t *const p_ctrl, sf_thread_monitor_counter_min_max_t const *p_counter_min_max)" id="threadRegister"><description>
<![CDATA[<form><p>Registers a thread for monitoring. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_ThreadRegister()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control structure set in <span font="code">SF_THREAD_MONITOR_Open</span>. </li><li bindent="0" vspace="false"><span font="code">p_counter_min_max</span> :   Pointer to structure containing min and max values for thread to be registered values. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*threadUnregister) (sf_thread_monitor_ctrl_t *const p_ctrl)" id="threadUnregister"><description>
<![CDATA[<form><p>Removes a thread from being monitored. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_ThreadUnregister()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control structure set in <span font="code">SF_THREAD_MONITOR_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*countIncrement) (sf_thread_monitor_ctrl_t *const p_ctrl)" id="countIncrement"><description>
<![CDATA[<form><p>Safely increments a monitored thread's count value. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_CountIncrement()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Control structure set in <span font="code">SF_THREAD_MONITOR_Open</span>. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Get version and store it in provided pointer p_version. </p><p><b>Implemented as</b></p><li bindent="0" vspace="false"><span font="code">SF_THREAD_MONITOR_VersionGet()</span> </li><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   Pointer to structure storing API and code versions. </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.thread_monitor.open" version="1"><moduleRef id="module.framework.thread_monitor"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.thread_monitor.close" version="1"><moduleRef id="module.framework.thread_monitor"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call threadRegister()" id="module.framework.thread_monitor.threadRegister" version="1"><moduleRef id="module.framework.thread_monitor"><function id="threadRegister" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;threadRegister(${instance}.p_ctrl, ${p_counter_min_max});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call threadUnregister()" id="module.framework.thread_monitor.threadUnregister" version="1"><moduleRef id="module.framework.thread_monitor"><function id="threadUnregister" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;threadUnregister(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call countIncrement()" id="module.framework.thread_monitor.countIncrement" version="1"><moduleRef id="module.framework.thread_monitor"><function id="countIncrement" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;countIncrement(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.thread_monitor.versionGet" version="1"><moduleRef id="module.framework.thread_monitor"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_thread_monitor.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Error callback function definition" id="module.framework.thread_monitor.callback_def.error" version="1"><moduleRef id="module.framework.thread_monitor" /><content>/* ${instance:synergyProperty(module.framework.sf_thread_monitor.name)} error callback function */
void ${instance}_err_callback(void *p_instance, void *p_data)
{
    /* TODO: add your own code here */
}
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_qca4010" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi QCA4010 Framework Introduction</span></p><p>The SX-ULPGN is a low-power, compact IEEE 802.11b/g/n 2.4GHz 1x1 Wireless LAN module equipped with the Qualcomm® QCA4010 Wireless SOC. </p><p>The Wi-Fi QCA4010 framework provides a high-level API for configuring and provisioning Silex QCA4010 ULPGN module as well as perform TCP and UDP data transfers with on-chip networking capability.</p><p><b>Wi-Fi QCA4010 Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p><p><span color="header" font="header">Wi-Fi QCA4010 Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_wifi_qca4010_ctrl_t *p_ctrl, sf_wifi_qca4010_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Initializes the network interface for data transfers. </p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to WiFi configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_wifi_qca4010_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>De-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*provisioningSet) (sf_wifi_qca4010_ctrl_t *const p_ctrl, sf_wifi_qca4010_provisioning_t const *const p_wifi_provisioning)" id="provisioningSet"><description>
<![CDATA[<form><p>Set WiFi module provisioning which will configure the module in AP or Client mode. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_provisioning</span> :   Pointer to WiFi provisioning structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*wifiStatusGet) (sf_wifi_qca4010_ctrl_t *const p_ctrl, sf_wifi_qca4010_status_t *const p_wifi_status)" id="wifiStatusGet"><description>
<![CDATA[<form><p>Get WiFi module information. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_wifi_info</span> :   Pointer to WiFi module information structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*scan) (sf_wifi_qca4010_ctrl_t *const p_ctrl, sf_wifi_qca4010_scan_t *const p_scan, uint8_t count)" id="scan"><description>
<![CDATA[<form><p>Scan for WiFi SSIDs. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_scan</span> :   Pointer to structure which will hold scan result. It is the responsibility of the caller to ensure that adequate space is available to hold scan results. </li><li bindent="0" vspace="false"><span font="code">count</span> :   Variable specifying maximum number of SSID's to scan and will be updated to number of actual SSIDs scanned by device </li><p /></form>]]>
</description></function><function display="ssp_err_t (*CommandSend) (sf_wifi_qca4010_ctrl_t *const p_ctrl, sf_wifi_qca4010_cmd_resp_t *const p_input_at_command, sf_wifi_qca4010_cmd_resp_t *const p_output, uint32_t const timeout)" id="CommandSend"><description>
<![CDATA[<form><p>Send AT command given by user. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block for the WiFi module. </li><li bindent="0" vspace="false"><span font="code">p_input_at_command</span> :   Pointer to structure which contains Modem command to send </li><li bindent="0" vspace="false"><span font="code">p_output</span> :   Pointer to buffer in which response will be sent to user, Also user will pass the size of the buffer which is pointed by p_output </li><li bindent="0" vspace="false"><span font="code">timeout</span> :   Timeout for which framework will wait for response in milliseconds </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_wifi_qca4010.open" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_wifi_qca4010.close" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call provisioningSet()" id="module.framework.sf_wifi_qca4010.provisioningSet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="provisioningSet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;provisioningSet(${instance}.p_ctrl, ${p_wifi_provisioning});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call wifiStatusGet()" id="module.framework.sf_wifi_qca4010.wifiStatusGet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="wifiStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;wifiStatusGet(${instance}.p_ctrl, ${p_wifi_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call scan()" id="module.framework.sf_wifi_qca4010.scan" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="scan" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;scan(${instance}.p_ctrl, ${p_scan}, ${count});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call CommandSend()" id="module.framework.sf_wifi_qca4010.CommandSend" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="CommandSend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;CommandSend(${instance}.p_ctrl, ${p_input_at_command}, ${p_output}, ${timeout});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_wifi_qca4010.versionGet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_qca4010_socket" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi QCA4010 Framework Introduction</span></p><p>The SX-ULPGN is a low-power, compact IEEE 802.11b/g/n 2.4GHz 1x1 Wireless LAN module equipped with the Qualcomm® QCA4010 Wireless SOC. </p><p>The Wi-Fi QCA4010 framework provides a high-level API for configuring and provisioning Silex QCA4010 ULPGN module as well as perform TCP and UDP data transfers with on-chip networking capability.</p><p><b>Wi-Fi QCA4010 Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p><p><span color="header" font="header">Wi-Fi QCA4010 Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, sf_wifi_qca4010_socket_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Open lower level driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_wifi_qca4010_socket_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Close lower level driver. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketCreate) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no, sf_wifi_socket_type_t type, uint8_t ipversion)" id="socketCreate"><description>
<![CDATA[<form><p>Create a socket. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><li bindent="0" vspace="false"><span font="code">type</span> :   TCP/UDP socket </li><li bindent="0" vspace="false"><span font="code">ipversion</span> :   Protocol version </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketConnect) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no, const struct sockaddr *p_serv_addr, socklen_t addrlen)" id="socketConnect"><description>
<![CDATA[<form><p>Connect to socket. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><li bindent="0" vspace="false"><span font="code">p_serv_addr</span> :   IP address to connect </li><li bindent="0" vspace="false"><span font="code">addrlen</span> :   Size of socket address structure </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketDisconnect) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no)" id="socketDisconnect"><description>
<![CDATA[<form><p>Disconnect socket. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketSend) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no, const uint8_t *p_data, uint32_t length, uint32_t timeout_ms)" id="socketSend"><description>
<![CDATA[<form><p>Send data to connected socket. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   send buffer </li><li bindent="0" vspace="false"><span font="code">length</span> :   Data length to be sent </li><li bindent="0" vspace="false"><span font="code">timeout_ms</span> :   timeout in milliseconds </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketRecv) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no, uint8_t *const p_data, uint32_t length, uint32_t timeout_ms)" id="socketRecv"><description>
<![CDATA[<form><p>Receive data from connected socket. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><li bindent="0" vspace="false"><span font="code">p_data</span> :   Data Receive buffer </li><li bindent="0" vspace="false"><span font="code">length</span> :   Data length to be received </li><li bindent="0" vspace="false"><span font="code">timeout_ms</span> :   timeout in milliseconds </li><p /></form>]]>
</description></function><function display="ssp_err_t (*socketStatusGet) (sf_wifi_qca4010_socket_ctrl_t *p_ctrl, uint8_t socket_no, uint32_t *p_socket_status)" id="socketStatusGet"><description>
<![CDATA[<form><p>Get Socket status. </p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   pointer to control block </li><li bindent="0" vspace="false"><span font="code">socket_no</span> :   Socket ID number </li><li bindent="0" vspace="false"><span font="code">p_socket_status</span> :   Pointer to an integer to hold the socket return status </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_wifi_qca4010_socket.open" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_wifi_qca4010_socket.close" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_wifi_qca4010_socket.versionGet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketCreate()" id="module.framework.sf_wifi_qca4010_socket.socketCreate" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketCreate" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketCreate(${instance}.p_ctrl, ${socket_no}, ${type}, ${ipversion});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketConnect()" id="module.framework.sf_wifi_qca4010_socket.socketConnect" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketConnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketConnect(${instance}.p_ctrl, ${socket_no}, ${p_serv_addr}, ${addrlen});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketDisconnect()" id="module.framework.sf_wifi_qca4010_socket.socketDisconnect" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketDisconnect" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketDisconnect(${instance}.p_ctrl, ${socket_no});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketSend()" id="module.framework.sf_wifi_qca4010_socket.socketSend" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketSend" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketSend(${instance}.p_ctrl, ${socket_no}, ${p_data}, ${length}, ${timeout_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketRecv()" id="module.framework.sf_wifi_qca4010_socket.socketRecv" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketRecv" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketRecv(${instance}.p_ctrl, ${socket_no}, ${p_data}, ${length}, ${timeout_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call socketStatusGet()" id="module.framework.sf_wifi_qca4010_socket.socketStatusGet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_socket"><function id="socketStatusGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_socket.name)}.p_api-&gt;socketStatusGet(${instance}.p_ctrl, ${socket_no}, ${p_socket_status});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack" /><description>
<![CDATA[<form><p><span color="header" font="header">Wi-Fi QCA4010 Framework Introduction</span></p><p>The SX-ULPGN is a low-power, compact IEEE 802.11b/g/n 2.4GHz 1x1 Wireless LAN module equipped with the Qualcomm® QCA4010 Wireless SOC. </p><p>The Wi-Fi QCA4010 framework provides a high-level API for configuring and provisioning Silex QCA4010 ULPGN module as well as perform TCP and UDP data transfers with on-chip networking capability.</p><p><b>Wi-Fi QCA4010 Framework Module Features</b></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p><p><span color="header" font="header">Wi-Fi QCA4010 Framework Module Features</span></p><li bindent="0" vspace="false">Provides high-level APIs to configure and provision a SX-ULPGN Wi-Fi module.</li><li bindent="0" vspace="false">Provides three different implementations for: </li><li bindent="20" vspace="false">A Wi-Fi device driver stack using the sf_wifi_qca4010 framework. </li><li bindent="20" vspace="false">An on-chip stack using the sf_wifi_qca4010_onchip_stack framework.</li><li bindent="20" vspace="false">A socket stack using the sf_wifi_qca4010_socket framework.</li><li bindent="0" vspace="false">Provides a socket interface to create socket-based applications with the On-chip TCP/UDP.</li><p><b>Note</b></p><p> The On-Chip Stack on qca4010 Wi-Fi Framework, qca4010 Wi-Fi Device Driver  on sf_wifi_qca4010 can be used as a lower-level implementation of the Socket Framework or on its own.</p></form>]]>
</description><function display="ssp_err_t (*open) (sf_wifi_qca4010_onchip_stack_ctrl_t *p_ctrl, sf_wifi_qca4010_onchip_stack_cfg_t const *const p_cfg)" id="open"><description>
<![CDATA[<form><p>Pointer to function which initializes the network interface for data transfers</p><p>Initial driver configuration, enable the driver link, enable interrupts and make device ready for data transfer.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to user-provided storage for the control block. </li><li bindent="0" vspace="false"><span font="code">p_cfg</span> :   Pointer to configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*close) (sf_wifi_qca4010_onchip_stack_ctrl_t *const p_ctrl)" id="close"><description>
<![CDATA[<form><p>Pointer to function which un-initialize the network interface and may put it in low power mode or power it off. Close the driver, disable the driver link, disable interrupt.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ipAddressCfg) (sf_wifi_qca4010_onchip_stack_ctrl_t *const p_ctrl, sf_wifi_qca4010_onchip_stack_ip_cfg_t *const p_ip_cfg)" id="ipAddressCfg"><description>
<![CDATA[<form><p>Configures IP address of the interface.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_ip_cfg</span> :   Pointer to IP configuration structure. </li><p /></form>]]>
</description></function><function display="ssp_err_t (*ping) (sf_wifi_qca4010_onchip_stack_ctrl_t *const p_ctrl, ULONG *p_ip_addr, uint32_t count, uint32_t interval_ms)" id="ping"><description>
<![CDATA[<form><p>Configures IP address of the interface.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_ip_addr</span> :   Pointer to IP address to ping </li><li bindent="0" vspace="false"><span font="code">count</span> :   Number of ping attempts </li><li bindent="0" vspace="false"><span font="code">interval_ms</span> :   Timeout in milliseconds </li><p /></form>]]>
</description></function><function display="ssp_err_t (*versionGet) (ssp_version_t *const p_version)" id="versionGet"><description>
<![CDATA[<form><p>Gets version and stores it in provided pointer p_version.</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_version</span> :   pointer to memory location to return version number </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dhcpServerStart) (sf_wifi_qca4010_onchip_stack_ctrl_t *const p_ctrl, ULONG *p_start_ip, ULONG *p_end_ip)" id="dhcpServerStart"><description>
<![CDATA[<form><p>Starts DHCP server</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_start_ip</span> :   Pointer to Start IP address </li><li bindent="0" vspace="false"><span font="code">p_end_ip</span> :   Pointer to End IP address </li><p /></form>]]>
</description></function><function display="ssp_err_t (*dhcpServerStop) (sf_wifi_qca4010_onchip_stack_ctrl_t *const p_ctrl, ULONG *p_start_ip, ULONG *p_end_ip)" id="dhcpServerStop"><description>
<![CDATA[<form><p>Stops DHCP server</p><p><b>Parameters</b></p><li bindent="0" vspace="false"><span font="code">p_ctrl</span> :   Pointer to the control block </li><li bindent="0" vspace="false"><span font="code">p_start_ip</span> :   Pointer to Start IP address </li><li bindent="0" vspace="false"><span font="code">p_end_ip</span> :   Pointer to End IP address </li><p /></form>]]>
</description></function></api><template category="function_call" display="Call open()" id="module.framework.sf_wifi_qca4010_onchip_stack.open" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="open" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;open(${instance}.p_ctrl, ${instance}.p_cfg);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call close()" id="module.framework.sf_wifi_qca4010_onchip_stack.close" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="close" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;close(${instance}.p_ctrl);
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ipAddressCfg()" id="module.framework.sf_wifi_qca4010_onchip_stack.ipAddressCfg" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="ipAddressCfg" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;ipAddressCfg(${instance}.p_ctrl, ${p_ip_cfg});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call ping()" id="module.framework.sf_wifi_qca4010_onchip_stack.ping" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="ping" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;ping(${instance}.p_ctrl, ${p_ip_addr}, ${count}, ${interval_ms});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call versionGet()" id="module.framework.sf_wifi_qca4010_onchip_stack.versionGet" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="versionGet" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;versionGet(${p_version});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dhcpServerStart()" id="module.framework.sf_wifi_qca4010_onchip_stack.dhcpServerStart" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="dhcpServerStart" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;dhcpServerStart(${instance}.p_ctrl, ${p_start_ip}, ${p_end_ip});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><template category="function_call" display="Call dhcpServerStop()" id="module.framework.sf_wifi_qca4010_onchip_stack.dhcpServerStop" version="1"><moduleRef id="module.framework.sf_wifi_qca4010_onchip_stack"><function id="dhcpServerStop" /></moduleRef><content>${status:localVar(ssp_err_t)} = ${instance:synergyProperty(module.framework.sf_wifi_qca4010_onchip_stack.name)}.p_api-&gt;dhcpServerStop(${instance}.p_ctrl, ${p_start_ip}, ${p_end_ip});
</content><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /></template><api version="1"><platform id="ssp" max="" min="2.6.1" /><ssp max="" min="2.6.1" /><moduleRef id="module.framework.sf_touch_ctsu_on_sf_touch_ctsuv2" /><description>
<![CDATA[<form><p><span color="header" font="header">Capacitive Touch v2 Module Introduction</span></p><p>The Capacitive Touch v2 Framework uses the <span font="code">CTSU v2 Driver</span> API and provides application-level APIs for scanning touch buttons, sliders, and wheels. This module is configured via the <a href="https://www.renesas.com/qe-capacitive-touch">QE for Capacitive Touch</a>.</p><p><span color="header" font="header">Capacitive Touch v2 Module Features</span></p><li bindent="0" vspace="false">Supports touch buttons (Self and Mutual), sliders, and wheels</li><li bindent="0" vspace="false">Can retrieve the status of up to 64 buttons at once</li><li bindent="0" vspace="false">Software and external triggering</li><li bindent="0" vspace="false">Callback on scan end</li><li bindent="0" vspace="false">Collects and calculates usable scan results:</li><li bindent="20" vspace="false">Slider position from 0 to 100 (percent)</li><li bindent="20" vspace="false">Wheel position from 0 to 359 (degrees)</li><li bindent="0" vspace="false">Optional (build time) support for real-time monitoring functionality through the QE tool over UART  </li></form>]]>
</description></api></developerSupport>